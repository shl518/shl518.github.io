<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2023/03/22/ce-shi/"/>
      <url>/2023/03/22/ce-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/22/hello-world/"/>
      <url>/2023/03/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web_Scraping</title>
      <link href="/2022/06/27/web-scraping/"/>
      <url>/2022/06/27/web-scraping/</url>
      
        <content type="html"><![CDATA[<p>urlparse模块主要是用于解析url中的参数 对url按照一定格式进行 拆分或拼接 </p><p>1.urlparse.urlparse</p><p>将url分为6个部分，返回一个包含6个字符串项目的元组：协议、位置、路径、参数、查询、片段。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urlparseurl_change <span class="token operator">=</span> urlparse<span class="token punctuation">.</span>urlparse<span class="token punctuation">(</span><span class="token string">'https://i.cnblogs.com/EditPosts.aspx?opt=1'</span><span class="token punctuation">)</span><span class="token keyword">print</span> url_change<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><p><code>ParseResult(scheme=&#39;https&#39;, netloc=&#39;i.cnblogs.com&#39;, path=&#39;/EditPosts.aspx&#39;, params=&#39;&#39;, query=&#39;opt=1&#39;, fragment=&#39;&#39;)</code></p><p>其中 scheme 是协议 ,netloc 是域名服务器, path 相对路径 params是参数，query是查询的条件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> urlopen<span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> urlparse<span class="token keyword">import</span> re<span class="token keyword">import</span> datetime<span class="token keyword">import</span> randompages <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">getInternalLinks</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> includeUrl<span class="token punctuation">)</span><span class="token punctuation">:</span>    includeUrl <span class="token operator">=</span> <span class="token string">'&#123;&#125;://&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>urlparse<span class="token punctuation">(</span>includeUrl<span class="token punctuation">)</span><span class="token punctuation">.</span>scheme<span class="token punctuation">,</span> urlparse<span class="token punctuation">(</span>includeUrl<span class="token punctuation">)</span><span class="token punctuation">.</span>netloc<span class="token punctuation">)</span>    internalLinks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> link <span class="token keyword">in</span> bs<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> href<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'^(/|.*)'</span> <span class="token operator">+</span> includeUrl <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> internalLinks<span class="token punctuation">:</span>                <span class="token keyword">if</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>startwith<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    internalLinks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>includeUrl <span class="token operator">+</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    internalLinks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> internalLinks<span class="token keyword">def</span> <span class="token function">getExternalLinks</span><span class="token punctuation">(</span>bs<span class="token punctuation">,</span> excludeUrl<span class="token punctuation">)</span><span class="token punctuation">:</span>    externalLinks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> link <span class="token keyword">in</span> bs<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> href<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">'^(http|www)((?!'</span> <span class="token operator">+</span> excludeUrl <span class="token operator">+</span> <span class="token string">').)*$'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span> <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> externalLinks<span class="token punctuation">:</span>                externalLinks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>link<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> externalLinks<span class="token keyword">def</span> <span class="token function">getRandomExternalLink</span><span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token punctuation">:</span>    html <span class="token operator">=</span> urlopen<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span>    bs <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    externalLinks <span class="token operator">=</span> getExternalLinks<span class="token punctuation">(</span>bs<span class="token punctuation">,</span> urlparse<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token punctuation">.</span>netloc<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>externalLinks<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"No external Links"</span><span class="token punctuation">)</span>        domain <span class="token operator">=</span> <span class="token string">'&#123;&#125;://&#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>urlparse<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token punctuation">.</span>scheme<span class="token punctuation">,</span> urlparse<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token punctuation">.</span>netloc<span class="token punctuation">)</span>        internalLinks <span class="token operator">=</span> getInternalLinks<span class="token punctuation">(</span>bs<span class="token punctuation">,</span> domain<span class="token punctuation">)</span>        <span class="token keyword">return</span> getRandomExternalLink<span class="token punctuation">(</span>internalLinks<span class="token punctuation">[</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>internalLinks<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> externalLinks<span class="token punctuation">[</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>externalLinks<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">followExternalOnly</span><span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token punctuation">:</span>    externalLink <span class="token operator">=</span> getRandomExternalLink<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> HasContainsUrl<span class="token punctuation">(</span>externalLink<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Random external Link is : &#123;&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>externalLink<span class="token punctuation">)</span><span class="token punctuation">)</span>        pages<span class="token punctuation">.</span>add<span class="token punctuation">(</span>externalLink<span class="token punctuation">)</span>    followExternalOnly<span class="token punctuation">(</span>startingPage<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">HasContainsUrl</span><span class="token punctuation">(</span>externalLink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> pages    <span class="token keyword">for</span> page <span class="token keyword">in</span> pages<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page <span class="token operator">==</span> externalLink<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment">#main</span>followExternalOnly<span class="token punctuation">(</span><span class="token string">'https://www.py.cn/faq/python/15298.html'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab4实验报告</title>
      <link href="/2022/06/23/2022-cao-zuo-xi-tong-lab4-shi-yan-bao-gao/"/>
      <url>/2022/06/23/2022-cao-zuo-xi-tong-lab4-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab4实验报告"><a href="#Lab4实验报告" class="headerlink" title="Lab4实验报告"></a>Lab4实验报告</h2><h3 id="1-1-思考题"><a href="#1-1-思考题" class="headerlink" title="1.1 思考题"></a>1.1 思考题</h3><p><strong>Thinking 4.1</strong>. <em>思考并回答下面的问题：</em></p><ul><li><em>内核在保存现场的时候是如何避免破坏通用寄存器的？</em></li></ul><p>:label:<strong>答</strong>：查阅相关代码，发现其实在Lab3的时候我们就已经见识到了这个问题的答案，那就是通过SAVE_ALL宏来保存用户态的所有寄存器到栈帧里。在Lab3的handle_int函数里我们就可以见到他的身影，之后如果再使用这些通用寄存器并进行改写，也不会对已经存储的值造成影响。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">NESTED(handle_int, TF_SIZE, sp).setnoatnopSAVE_ALL #在这里在这里在这里,我将用户态的所有寄存器到栈帧里CLI.setatmfc0t0, CP0_CAUSEmfc0t2, CP0_STATUSandt0, t2andit1, t0, STATUSF_IP4bnezt1, timer_irqnopEND(handle_int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息吗？</em></li></ul><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">lw a0, TF_REG4(sp) #a0lw a1, TF_REG5(sp) #a1lw a2, TF_REG6(sp) #a2lw a3, TF_REG7(sp) #a3addiu sp, sp, -24sw t3, 16(sp)sw t4, 20(sp)         jalr    t2    #跳转到对应的系统调用函数   nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>:label:<strong>答</strong>：可以，阅读代码我们可以发现在handle_sys函数里，msyscall里的6个参数，前四个被保存在了a0-a3，后两个保存在了栈内8字节空间内。紧接着handle_sys函数执行内核态对应的系统调用，a0−a3寄存器的值没有被改变过，因此可以直接使用。</p><ul><li><em>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</em></li></ul><p>:label:<strong>答</strong>：这个问题其实可以用上一个问题的答案来解释，原因在于使用了handle_sys函数将msyscall前四个参数放在对应的a0-a3寄存器上，后两个参数存在栈上的相同位置。</p><ul><li><em>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？</em></li></ul><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">lwt0, TF_EPC(sp)addiut0, t0, 4 #EPC &#x3D; EPC + 4swt0, TF_EPC(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>:label:<strong>答</strong>：在handle_sys代码里可以找到答案，即修改了EPC的值，用户态返回的时候可以继续执行下一条指令</p><p><strong>Thinking 4.2</strong>. 思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib&#x2F;env.c 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现 与 <code>envid2env()</code> 函数的行为进行解释。</p><p>:label:<strong>答</strong>：因为envid2env里面对于id&#x3D;0的进程返回当前进程curenv，我们要用envid &#x3D; 0特殊标识curenv。有了这个特殊标识以后就向envid2env传入0而快速的得到当前进程的env块。</p><p><strong>另一个更重要的原因</strong>在于实现fork.c过程中，我们要求子进程返回<code>newenvid = 0</code>而父进程<code>newenvid !=0</code>（阅读代码我们发现父进程返回的newenvid其实是子进程的真实envid）。<code>mkenvid()</code> 函数不会返回 0的原因在于不能让任何一个进程的envid &#x3D; 0，否则在返回newenvid的时候就可能父进程也返回0，子进程也返回0，无法区分父子进程。</p><p><strong>Thinking 4.3</strong>. <em>思考下面的问题，并对这两个问题谈谈你的理解：</em></p><ul><li><em>子进程完全按照 fork() 之后父进程的代码执行，说明了什么？</em></li></ul><p>:label:<strong>答</strong>：说明子进程和父进程共享代码段。</p><ul><li><em>但是子进程却没有执行 fork() 之前父进程的代码，又说明了什么？</em></li></ul><p>:label:<strong>答</strong>：说明子进程恢复到的上下文位置是fork函数</p><p><strong>Thinking 4.4</strong>. <em>关于 fork 函数的两个返回值，下面说法正确的是：</em></p><p><em>A、fork 在父进程中被调用两次，产生两个返回值</em></p><p><em>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值</em></p><p><em>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</em></p><p><em>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</em></p><p>:label:<strong>答</strong>：C</p><p><strong>Thinking 4.5</strong>. <em>我们并不应该对所有的用户空间页都使用<code>duppage</code>进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？ 请结合本章的后续描述、mm&#x2F;pmap.c 中 <code>mips_vm_init</code> 函数进行的页面映射以及 include&#x2F;mmu.h 里的内存布局图进行思考。</em></p><p><img src="https://note.youdao.com/yws/api/personal/file/F2B59E4132B6478E8B36A8880D1A8322?method=download&shareKey=cfa1ccb508bd72c7b0a0729d99bdfa72" alt="image-20220514210021387"></p><p>:label:<strong>答</strong>:</p><ul><li>UTOP以上的用户空间对于用户进程来说不可改变；系统空间对于每个进程来说是相同且不可改变的，因此UTOP以上空间不用进行保护；</li><li>UXSTACKTOP - BY2PG到UXSTACKTOP的空间是用户进程的异常栈，若进行写时复制保护可能陷入死循环，因此不能被保护。</li><li>USTACKTOP到USTACKTOP + BY2PG的空间在空间分布图上是Invalid memory，用不到所以无需保护。</li><li>去除上述这些，需要保护的是在0与USTACKTOP之间且在父进程中有效的页面。并且在<strong>如下代码</strong>中我们看到也确实如此。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;fork.cif(newenvid)&#123;        for (i &#x3D; 0; i &lt; VPN(USTACKTOP); i++) &#123; &#x2F;&#x2F;0 --- USTACKTOP之间！！！！！！！！！！！！！！            if ((((Pde *)(*vpd))[i &gt;&gt; 10] &amp; PTE_V) &amp;&amp; (((Pte *)(*vpt))[i] &amp; PTE_V)) &#123;                duppage(newenvid, i);            &#125;        &#125;        syscall_mem_alloc(newenvid, UXSTACKTOP - BY2PG, PTE_V|PTE_R);        syscall_set_pgfault_handler(newenvid, __asm_pgfault_handler, UXSTACKTOP);        syscall_set_env_status(newenvid, ENV_RUNNABLE);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Thinking 4.6</strong>. <em>在遍历地址空间存取页表项时你需要使用到vpd和vpt这两个“指针的指针”，请参考 user&#x2F;entry.S 和 include&#x2F;mmu.h 中的相关实现，思考并回答这几个问题：</em></p><p>:label:<strong>答</strong>：首先我们可以在mmu.h中找到他们的定义</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">extern volatile Pte* vpt[]; extern volatile Pde* vpd[]; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><em>vpt和vpd的作用是什么？怎样使用它们？</em></li></ul><p>:label:<strong>答</strong>：vpt存放着二级页表，vpd存放着一级页表，使用时把它们当作数组头。对于虚拟地址va，<code>（*vpd）[PDX(va)]</code>为二级页表的物理地址，<code>(*vpt)[PTX(va)]</code>为va对应的物理页面。此外，我们在duppage里这样使用它。总而言之，我们可以通过vpt,vpd访问一级页目录与二级页表。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">duppage(u_int envid, u_int pn)&#123;    u_int addr;    u_int perm;    int flag &#x3D; 0;    addr &#x3D; pn &lt;&lt; PGSHIFT;    perm &#x3D; (*vpt)[pn] &amp; (BY2PG - 1);&#x2F;&#x2F;使用(*vpt)[pn]取出对应页表项！！！！！！！！    if ((perm &amp; PTE_R) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;        perm |&#x3D; PTE_COW;        flag &#x3D; 1;    &#125;    syscall_mem_map(0, addr, envid, addr, perm);    if (flag) syscall_mem_map(0, addr, 0, addr, perm);    &#x2F;&#x2F;  user_panic(&quot;duppage not implemented&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><em>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</em></li></ul><p>:label:<strong>答</strong>：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">#entry.S.globl vpt  vpt:          .word UVPT      .globl vpd vpd:          .word (UVPT+(UVPT&gt;&gt;12)*4) #自映射机制 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在entry.S中定义vpt，vpd,很明显这里使用了自映射机制。vpt指向了UVPT是进程页表所在之处,vpd通过自映射机制指向了<code>(UVPT+(UVPT&gt;&gt;12)*4)</code>,是自映射机制下的一级页表地址。通过这样的定义，进程能够通过这种方式来存取自身的页表。</p><ul><li><em>它们是如何体现自映射设计的？</em></li></ul><p>:label:<strong>答</strong>：上一问已经谈到，在<code>entry.S</code>的对vpd定义里可以明显看到自映射机制的存在。</p><ul><li><em>进程能够通过这种方式来修改自己的页表项吗？</em></li></ul><p>:label:<strong>答</strong>：不可以，用户进程无权限直接修改页表项。如果非要修改的话，我们在<code>duppage</code>里使用了系统调用<code>syscall_mem_map</code>的这种方式进行修改。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">static void duppage(u_int envid, u_int pn)&#123;    u_int addr;    u_int perm;    int flag &#x3D; 0;    addr &#x3D; pn &lt;&lt; PGSHIFT;    perm &#x3D; (*vpt)[pn] &amp; (BY2PG - 1);    if ((perm &amp; PTE_R) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;        perm |&#x3D; PTE_COW;        flag &#x3D; 1;    &#125;    syscall_mem_map(0, addr, envid, addr, perm);    if (flag) syscall_mem_map(0, addr, 0, addr, perm);    &#x2F;&#x2F;上面这句话通过系统调用syscall_mem_map的方式陷入内核，进程间接通过内核修改了页表项，但是无论如何进程不能通过vpt，vpd直接修改页表项    &#x2F;&#x2F;  user_panic(&quot;duppage not implemented&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Thinking 4.7</strong>. <code>page_fault_handler</code> 函数中，你可能注意到了一个向异常处理栈复制Trapframe运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？</li></ul><p>:label:<strong>答</strong>：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">BUILD_HANDLER mod page_fault_handler cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过全局grep可以发现在全文中只有一处汇编调用了<code>page_fault_handler</code>，即handle_mod，而该中断处理函数与写时复制的中断缺页有关，所以间接说明 写时复制时可能导致中断重入。在用户发生写时复制引发的缺页中断并进行处理时，可能会再次发生缺页中断，从而“中断重入”。</p><ul><li>内核为什么需要将异常的现场Trapframe复制到用户空间？</li></ul><p>:label:<strong>答</strong>：因为指导书也提到：</p><p><strong>“事实上，我们的MOS操作系统按照微内核的设计理念， 尽可能地将功能实现在用户空间中，其中也包括了页写入异常的处理，因此主要的处理过程是在用户态下完成的。”</strong></p><p>因此我们在用户进程处理此缺页中断，需要将现场的信息保存在用户态。再具体来看，页写入异常处理会返回到entry.S中的 <code>__asm_pgfault_handler</code>函数。</p><p>这个函数在用户态下，从内核返回后，此时的栈指针是由内核设置的，处于异常处理栈中，且指向一个由内核复制好的 Trapframe 结构体的底部,<strong>我们需要使用之前复制到异常处理栈中的TrapFrame里面的信息跳转到真正的异常处理函数</strong>。如果之前内核没有吧现场的TrapFrame复制到异常处理栈，那么我们在这里也无法跳转到真正的异常处理函数。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">__asm_pgfault_handler:lw      a0, TF_BADVADDR(sp)lw      t1, __pgfault_handlerjalr    t1noplw      v1, TF_LO(sp)mtlo    v1lw      v0, TF_HI(sp)lw      v1, TF_EPC(sp)mthi    v0mtc0    v1, CP0_EPClw      $31, TF_REG31(sp)lw      $1, TF_REG1(sp)lw      k0, TF_EPC(sp)jr      k0lw      sp, TF_REG29(sp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Thinking 4.8</strong>. 到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：</p><ul><li>在用户态处理页写入异常，相比于在内核态处理有什么优势？</li></ul><p>:label:<strong>答</strong>：这里应用了微内核的设计理念，具有微内核的优势即具有可扩展性，灵活性，同时具有可靠性与安全性，能够易于进行移植。</p><ul><li>从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？</li></ul><p>:label:<strong>答</strong>：首先使用存放函数调用返回值的$v0, v1恢复非通用寄存器，之后通过v1恢复非通用寄存器，之后通过sp恢复通用寄存器，最后恢复$sp，保证了恢复后个寄存器值正确。</p><p><strong>Thinking 4.9</strong>. <em>请思考并回答以下几个问题：</em></p><ul><li>为什么需要将<code>set_pgfault_handler</code>的调用放置在<code>syscall_env_alloc</code>之前？</li></ul><p>:label:<strong>答</strong>：syscall_env_alloc过程中也可能需要进行异常处理。</p><ul><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul><p>:label:<strong>答</strong>：此时进程给__pgfault_handler变量赋值时就会触发缺页中断，但中断处理没有设置好，故无法进行正常处理。</p><ul><li>子进程是否需要对在entry.S定义的字__pgfault_handler赋值？</li></ul><p>:label:<strong>答</strong>：不需要，子进程已经复制了父进程中__pgfault_handler变量值。</p><h3 id="1-2-实验难点"><a href="#1-2-实验难点" class="headerlink" title="1.2 实验难点"></a>1.2 实验难点</h3><h4 id="1-2-1难点一-系统调用的流程理解"><a href="#1-2-1难点一-系统调用的流程理解" class="headerlink" title="1.2.1难点一 系统调用的流程理解"></a>1.2.1难点一 系统调用的流程理解</h4><p>系统调用是为了用户能够使用一部分内核提供的标准接口，同时不会破坏内核的正常运行。理解本次作业系统调用的流程是完成整个系统调用部分的关键。下面是帮助理解的流程图。</p><p><img src="https://note.youdao.com/yws/api/personal/file/6137CDDF844746B2BDE2121A82403B4D?method=download&shareKey=f08006b63ee83ad2cf1346314a114b90" alt="image-20220531164442906"></p><h4 id="1-2-2-难点二-关于fork流程的理解"><a href="#1-2-2-难点二-关于fork流程的理解" class="headerlink" title="1.2.2 难点二 关于fork流程的理解"></a>1.2.2 难点二 关于fork流程的理解</h4><p>关于fork的理解是本次实验的一大难点，涉及函数很多，同时要灵活应用刚刚完成的系统调用部分。这里是我在完成fork部分填写的时候总结的fork相关流程和页写入异常的实现操作。有了这些流程的概念，脑子里会更清晰整体的思路。</p><p><img src="https://note.youdao.com/yws/api/personal/file/1009BAA3F9E445159836B9D6F4A13DF7?method=download&shareKey=e5eeabc96d3183e0fb8efbecac5967a1" alt="9b7db18b82d428e1a5cf819f6070007"></p><h3 id="1-3-心得体会"><a href="#1-3-心得体会" class="headerlink" title="1.3 心得体会"></a>1.3 心得体会</h3><p>这次实验对于我来说感到很困难，相对于前几个单元的实验，涉及到了更多函数的填写，涉及到了更多汇编文件的理解（汇编文件的理解一直是我的弱点），尤其是后半部分的fork操作部分难度很高。在这一部分我再一次体会到思路清晰的好处，一定要自己梳理一遍各个文件，各个函数之间的关系，也要梳理一遍完成某一功能需要怎样的流程，围绕各个功能是如何实现的这一中心点来梳理会有更加清晰的思路与框架。正是因为我在课下实验中梳理了一遍fork和系统调用实现的流程，在课上考试时我明显感受到我能很快的定位某一函数的位置，某一函数的功能和这个函数与其他函数的关系与用法，我想这便是自己梳理一遍的好处所在，同时使用这个方法，我阅读代码的能力也得到了很大的提升。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象第4单元作业总结</title>
      <link href="/2022/06/22/mian-xiang-dui-xiang-di-4-dan-yuan-zuo-ye-zong-jie/"/>
      <url>/2022/06/22/mian-xiang-dui-xiang-di-4-dan-yuan-zuo-ye-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="OO第四单元课程总结"><a href="#OO第四单元课程总结" class="headerlink" title="OO第四单元课程总结"></a>OO第四单元课程总结</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次内容主要是对第四单元和整个OO课程的总结，主要内容有总结本单元作业的架构设计，总结自己在四个单元中架构设计思维及OO方法理解的演进，总结自己在四个单元中测试理解与实践的演进，总结自己的课程收获，最后立足于自己的体会给课程提三个具体的改进建议。如有错误，谢谢指正！</p><h2 id="1-1-本单元架构设计"><a href="#1-1-本单元架构设计" class="headerlink" title="1.1 本单元架构设计"></a>1.1 本单元架构设计</h2><h3 id="1-1-1-第一次作业——类图"><a href="#1-1-1-第一次作业——类图" class="headerlink" title="1.1.1 第一次作业——类图"></a>1.1.1 第一次作业——类图</h3><p> 之前每次作业总结博客都会用UML类图描述程序，这次作业要自己来实现一个UML类图的功能，因为是第一次作业，所以只要实现对类图的元素信息提取，功能也比较简单，主要考察的就是对类图的理解，包括UmlClass，UmlInterFace，UmlAttribute，UmlOperation,UmlParameter等等类图元素的理解，其实本次作业的难点在于，利用面向对象的方法对类图元素进行解析，重点在于熟悉UML类图中各个元素之间的关系，其他的代码编写难度并不高。</p><p>要实现各种查询指令，必须先把UML类图这棵“树”建立起来，首先在构造函数里一个一个元素地识别并存储。这里我遍历了三遍，这是为了保证不出现空指针，一层一层利用面向对象的方法对类图进行解析，因此我的设计是分三遍识别：</p><ul><li><p>第一遍UMLClass，UMLInterface，和UMLAssociationEnd，将每个类的name与id建立name2Id映射，方便之后解析查询指令中传入的name；id与类建立class映射，因为id是唯一的；此外建立双重HashMap表即HashMap&lt;name,HashMap&lt;id,MyUmlClass&gt;&gt;，用于之后识别重复类。</p></li><li><p>第二遍UMLAttribute，UMLOperation，UMLAssociation，UMLInterfaceRealization，UMLGeneralization，这些信息都直接存入MyClass类中。</p></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/A131A0BB76CC48BA83C8AAF6F82DDAC9?method=download&shareKey=b7a78ba861794468699439d13722e54c" alt="image-20220621230127982"></p><ul><li>最后一遍UMLParameter，这是因为parameter-operation-class是一层层依赖的。这样可以保证每个元素所依赖的上一层元素都比自己先识别。</li></ul><p>　　作为类图中是最主要的元素，为了将UMLClass和它相关的属性、方法、关联关系、继承关系和实现关系等元素与类本身联系起来，我建立了一个MyClass类，在UMLClass的基础上，将它的各种关系都记录在里面，方便查询。同时我以同样的方法将MyInterFace和他相关联的Umloperation等也关联并封装了起来。</p><h3 id="1-1-2-第二次作业：UML顺序图的查询、UML状态图的查询"><a href="#1-1-2-第二次作业：UML顺序图的查询、UML状态图的查询" class="headerlink" title="1.1.2 第二次作业：UML顺序图的查询、UML状态图的查询"></a>1.1.2 第二次作业：UML顺序图的查询、UML状态图的查询</h3><p>和上一次不同，由于在Myimplementation里面实现所有的代码会造成代码过长，因此我在本次作业中将类图，顺序图，状态图分别建立三个大类，在三个大类中实现各自图的对应操作，MyImplementation只需要调用三个大类里面的方法即可。</p><p><img src="https://note.youdao.com/yws/api/personal/file/62CFFBE85AB544C68B38E184E67E628D?method=download&shareKey=7b3d10054cd177de9aa891298f309f59" alt="image-20220621231818060"></p><p>我针对状态图建立了MyStateGraph和MyStatus，Mytransition三个类，跟类图分析的模式一样，在Mystatus中封装更多与status相关的类，来实现树的构建，比如transitions等等，Mytransition里封装Umlevent等。</p><p>针对顺序图建立了MyinteractGraph和MyLifeLine两个类，这两个类比较简单，我在MyLifeLine中封装了相关lost、found类型消息的个数，方便直接查询，同时封装了create这个生命线的MyLifeLine，同样是方便直接查询。</p><p>这次的指令实现起来都比较简单，唯一一个比较难的是判断一个状态是否是关键状态，我采用的方法是DFS，从起始状态出发，屏蔽掉我们需要判断的这个点，如果DFS的最终结果包含至少一个最终状态，那么这个点就不是关键状态。</p><p>有一点需要注意的是：<code>如果状态机模型本来就无法从 Initial State 到达任意一个 Final State（包括 Final State 不存在的情况），则该状态机中所有状态都不是关键状态；</code>这一点我一开始没有注意到，和伙伴对拍的时候才发现这个问题，这告诉我们本单元认真阅读指导书的重要性。</p><h3 id="1-1-3-第三次作业：UML的有效性检验。"><a href="#1-1-3-第三次作业：UML的有效性检验。" class="headerlink" title="1.1.3 第三次作业：UML的有效性检验。"></a>1.1.3 第三次作业：UML的有效性检验。</h3><p>第三次作业主要是学习了UML图中的错误情况判断，基本不需要再构建新的类。本次作业要求我们实现9个错误的判断，我认为比较难的是以下三个</p><ul><li>循环继承的判断，这个是实现起来有一定难度，需要利用图DFS来解决，即利用DFS来判断有向图是否存在环。</li><li>重复继承的判断，我是用递归的方式，将每个类或接口无论是直接继承或间接继承的类或接口全部记录下来，判断的时候只要判断有无重复即可。</li><li>R002错误判断，<code>针对类图中的类（UMLClass），其成员属性（UMLAttribute）和关联的另一端所连接的 UMLAssociationEnd 这两者构成的整体中，不能有重名的成员</code>，这个主要是理解有困难，问了助教和同学才最终理解。</li></ul><p>最后是本单元的类图,可以看到层层梳理下来，逻辑还是很清晰的。</p><p><img src="https://note.youdao.com/yws/api/personal/file/A3FAAA7C970E495B90F7362C08158760?method=download&shareKey=449e486d30db9dca2e7eb0932adeb1bc"></p><h2 id="1-2-总结自己在四个单元中架构设计思维及OO方法理解的演进"><a href="#1-2-总结自己在四个单元中架构设计思维及OO方法理解的演进" class="headerlink" title="1.2 总结自己在四个单元中架构设计思维及OO方法理解的演进"></a>1.2 总结自己在四个单元中架构设计思维及OO方法理解的演进</h2><h3 id="1-2-1-Unit1"><a href="#1-2-1-Unit1" class="headerlink" title="1.2.1 Unit1"></a>1.2.1 Unit1</h3><p>本单元实现的是一个多项式化简的问题，我认为这一单元是最难的一单元，难在第一次面对OOP的编程，即使做了Pre，还是有一种不知所措，无从下手的压力感。我在本单元第一次切身体会到了面向对象这种语言逻辑，也体会到了递归下降解析的魅力。<strong>本单元最大的难点在于，利用面向对象的思想，架构出多项式本身的层层结构</strong>，比如最顶层是表达式，下来是项，再下来是因子，再下来是元素，变量等，我构造了Expression，Term，Factor等类。其实只要架构好，本单元的迭代其实很简单，在做本单元作业之前一定要在纸上大致架构好要实现哪些类，要把表达式分成哪些层。这一单元主要锻炼的是同学们面向对象的思想。</p><h3 id="1-2-2-Unit2"><a href="#1-2-2-Unit2" class="headerlink" title="1.2.2 Unit2"></a>1.2.2 Unit2</h3><p>这次我认为是第二难的一次作业，因为针对于线程的编程还是头一次。线程的debug过程非常困难，所以与其一点点debug，不如在写代码的过程中理清思路，注重细节。这次作业主要学习了同步和互斥访问，预防线程死锁以及线程的wait，sleep，notify和notifyall。进一步了解了线程的工作原理和锁的配置，而且更注重于类与类之间的信息传递与配合。这一单元锻炼的是线程和线程安全的知识。</p><h3 id="1-2-3-Unit3"><a href="#1-2-3-Unit3" class="headerlink" title="1.2.3 Unit3"></a>1.2.3 Unit3</h3><p>这一单元主要是是针对JML的理解，但实际解决的是图论问题。这一单元主要是每次需求的扩充，到这里的时候我几乎不需要重构了，这是很大的一个进步，在每次写代码时都考虑一下以后的需求增加。这次还学习了Junit自动检测。这一单元只要细致阅读JML，基本不会出什么Bug问题，因为毕竟JML是一套标准的规格。</p><h3 id="1-2-4-Unit4"><a href="#1-2-4-Unit4" class="headerlink" title="1.2.4 Unit4"></a>1.2.4 Unit4</h3><p>这一单元解析UML图。这次是针对主要的几个元素建立了单独的类，其他元素加入到这些类中当作属性。这次写起来就很顺手了，各个功能分配到不同的类中完成，最后在总合起来，思路很清晰，架构也比较直观。本单元重点在于对于UML类图，顺序图，状态图的一些元素要了如指掌，条理清晰，代码的编写基本还是第一单元面向对象，层层解构的思想，难度不大。</p><h2 id="1-3-总结自己在四个单元中测试理解与实践的演进"><a href="#1-3-总结自己在四个单元中测试理解与实践的演进" class="headerlink" title="1.3 总结自己在四个单元中测试理解与实践的演进"></a>1.3 总结自己在四个单元中测试理解与实践的演进</h2><p>关于测试，我在<strong>第一单元</strong>没有自己写测评机，导致强测出现了Bug，互测也出现了好几次Bug，现在回头想来可能也是当时因为时间太紧了，光编写代码就用好长时间，没有编写评测机的时间。但是看到一些同学编写完评测机后真的是事半功倍，互测的时候直接开着评测机就把Bug自动Hack到了，同时自己课下测试的时候也可以自动化测试，不用自己死盯着电脑屏幕，因此我在第二单元之后编写了自己的评测机，<strong>事实证明编写了评测机之后，无论是强测还是互测，至少正确性相关的问题我没有再出现，其他的问题更多的是性能的问题</strong>。</p><p><strong>二单元</strong>难度也很大，线程、线程安全的知识都是第一次接触，在测试的时候采用测评机和手动数据结合的方式，比如针对某个到达模式输入一些刁钻的数据，测试电梯调度，调头等问题，但感觉除了非常明显的死锁，偶发的死锁应该还是需要大量随机数据的轰炸。这一单元我用自己的评测机找出了自己的Bug，同样也自动Hack到了别人的Bug，自动评测机yyds！</p><p><strong>三单元</strong>主要采用测评机验证正确性，读代码查时间复杂度的方式，当然也用了JUnit等工具链进行测试（虽然依旧觉得没啥用），还面向某部分指令写了专门的数据生成。这一单元起数据生成不再是纯随机的，不然测到的绝大部分都是抛出来的异常。数据生成时，我才用先加入大量person，关系relation，group等元素，再进行随机大量的查询指令轰炸，这样起到的效果也不错，也能很好的找到一些Bug。</p><p><strong>四单元</strong>依旧测评机，本单元只需要在三单元的基础上对数据生成做修改，其余均可保留原样，方法仍是在生成器里建起图，在图里随机用结点。同时本单元我也自己用starUML手绘了一些针对性更强的类图，状态图和顺序图。</p><h2 id="1-4-课程收获"><a href="#1-4-课程收获" class="headerlink" title="1.4 课程收获"></a>1.4 课程收获</h2><p>一路走来，本学期的OO课程也告一段落，这一学期充满了欢乐，也不乏很多痛苦，但正是这些困难和挫折才让回忆更有力量。在面对OO第一单元的第一次作业时，尽管做了Pre，但是还是一脸懵逼，面对多项式的化简，脑子里最多的问题就是，指导书这里是啥意思？指导书读不明白啊？这该怎么实现？这该怎么架构？好难！记得当时指导书都整整读了两天，开始架构代码的时候生怕ddl前交不上去，熬夜写代码。我觉得第一单元的第一次作业是最痛苦的，绞尽脑汁的想架构，第一次转变为面向对象的逻辑编写代码，这对我来说都是挑战。</p><p>这可能就是万事开头难吧，在后来的作业中，我渐渐对面向对象的思想熟能生巧，在写第二单元、第四单元的时候，习惯性的就会对整体架构进行层层分析与解构，一层一层的实现具体功能，不知不觉面向对象的思想已经在第一单元刻入我的脑海。</p><p>总而言之，在这学期的OO课程中，我学到了许多知识，包括UML，JML，线程，线程安全，Java的各种语法，Java的语言风格，Junit测试，python自动评测机的编写等等。</p><p>当然课程中收获的最重要的还是面向对象的思想，在一次次实践中学会了如何进行抽象，我们操作的不是一个具体的类，而是抽象出来的接口，继承和实现像是一条线索贯穿了OO的始终，灵活运用可以使代码更加简洁优雅。</p><h2 id="1-5-给课程提三个具体的改进建议"><a href="#1-5-给课程提三个具体的改进建议" class="headerlink" title="1.5 给课程提三个具体的改进建议"></a>1.5 给课程提三个具体的改进建议</h2><ol><li>课程网站的讨论区能否设置成带评论回复功能的？翻起来太麻烦了，就比如第四单元第15次作业的讨论区，由于问题太多，问题和回复往往隔了好多条问题，只能通过@符号来判断助教回答的是哪个问题，实在是太不方便了。在评论里设置回复功能，直接点开评论就可以看到助教的解答不是更好吗？</li><li>在JML单元，如果这个单元主要内容是让大家学会JML的阅读和理解的话，我觉得可能不需要三次作业，1~2次作业我觉得已经足够,第三次作业的话感觉就是在学习写更多的算法，其中JML的东西还是第1,2次作业那些东西，没有学到什么新的JML的知识，感觉没有必要。可以把第三次作业设计成其他JML相关的内容。</li><li>最重要的是关于互测的问题。<ul><li>建议把房间数增多，每个房间分配3~4个人即可，因为我觉得<strong>互测的本质目的是为了让同学们学习别人的代码</strong>，而不是下载下来代码拿自己写的评测机来Hack别人。如果房间人数7~8人的话，就我的想法而言，我第一感觉就是：7、8份代码好多啊，我读代码找到Bug的概率好低，我还是用评测机自动Hack吧，让评测机自己评测，我去干其他的事。如果代码份数少一点的话，我觉得至少有阅读代码的动力。</li><li>第二，感觉目前的互测还是<strong>偏离了“让同学们学习其他同学代码”的初衷</strong>，而是一味地追求Hack别人加分。我认为可以把互测的内容增加一些，除了找他人的Bug，还可以给同房间的同学互相提出设计优化建议，总结互相学习到的代码或者架构方面的知识，这样会不会更符合初衷一点呢？</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象第3单元作业总结</title>
      <link href="/2022/06/22/mian-xiang-dui-xiang-di-3-dan-yuan-zuo-ye-zong-jie/"/>
      <url>/2022/06/22/mian-xiang-dui-xiang-di-3-dan-yuan-zuo-ye-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象第三次单元总结"><a href="#面向对象第三次单元总结" class="headerlink" title="面向对象第三次单元总结"></a>面向对象第三次单元总结</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本单元学习了JML相关内容。本篇文章讲解了三次作业中如何选择正确的容器，如何选择正确的算法解决可能出现的性能问题。同时也阐释了本次作业的测试方法与Hack策略。最后完成了对于Network的一个拓展，实现了一个买卖广告系统，完成了对三个核心方法的JML的撰写。如有错误，谢谢指正！</p><hr><h2 id="阅读JML和实现JML的策略"><a href="#阅读JML和实现JML的策略" class="headerlink" title="阅读JML和实现JML的策略"></a>阅读JML和实现JML的策略</h2><p>在本单元的代码实现过程中，由于已经用JML为我们定义了方法的规格，所以只需要将JML翻译成代码语言即可。在翻译的过程中需要确保实现的逻辑严谨以及严格符合JML的规格。</p><p>在我看来，在本单元中认真阅读JML和掌握JML各项含义，实现正确的架构基本没有太大的问题，但前提是要认真阅读JML并提取出其全部信息，否则正确性肯定难以保证。</p><ul><li><p>第一个策略：在本次中我认为更快实现JML的一个策略就是<strong>按一定顺序，从底到上的实现JML</strong>，按照这样实现的顺序逻辑会更加通畅并且架构更加清晰。我的设计策略是首先实现异常类，然后分别实现不同的类。从类的包含关系来看，首先实现较为简单的Person类和Mesage类，接着实现包含这两个类的Gruop类，最后实现较为复杂的Network类。</p></li><li><p>第二个策略：另一个实现JML的策略便是<strong>容器的选择</strong>，在本单元中我第一次见到了HashMap的 威力，在之前单元我一直采取的都是常用的ArrayList动态方法来进行存储。在本单元首次使用HashMap这类的数据结构才知道真香啊😍。Hashmap可以实现更快的查找，但也要存储更多的信息，是一种以空间换时间的策略，但我们的作业几乎不用考虑空间不够的问题，考虑时间才是第一要务，因此本单元我几乎所有的数据存储结构全部采用HashMap来实现。此外在本单元中我还学习到了更多的容器，例如HashSet集合，优先队列PriorityList，链表LinkedList，<strong>这些容器都视不同的需求而使用，慎重、机智的选择不同的容器也是本单元的一大重点</strong>。</p></li></ul><h2 id="三次作业分析"><a href="#三次作业分析" class="headerlink" title="三次作业分析"></a>三次作业分析</h2><p>如我刚刚所述，只要JML认真阅读，实现的正确性有很好的保证，因此接下来的分析主要围绕<strong>容器的选择</strong>与<strong>性能问题的解决</strong>。这里不再分三次作业逐步叙述，而是整体进行叙述，因为三次作业没有明显的迭代关系，更像是一个整体被分为三个部分来完成。</p><h3 id="1-1-不同类中容器的选择"><a href="#1-1-不同类中容器的选择" class="headerlink" title="1.1 不同类中容器的选择"></a>1.1 不同类中容器的选择</h3><p>在本次作业中自己主要采用了 <code>HashMap</code> ，<code>HashSet</code> 以及 <code>LinkedList</code> 容器。下面具体列出实现中采用的容器以及如此选择容器的依据。</p><h3 id="Person"><a href="#Person" class="headerlink" title="Person"></a>Person</h3><ul><li><code>private HashMap&lt;Person, Integer&gt; acquaintance</code></li></ul><p>用来储存一个人的有关系的人以及这些关系的对应value值，因为我们在person类中只需要使用Person和value的映射关系，因此我们不需要将二者分开存储，而是将其统一存放在Hashmap中，既可以减小空间的占用，又能很好的实现功能的查找，总而言之这是一个技巧，类似的映射关系都可以采用Hashmap这种容器来存储。</p><ul><li><code>private LinkedList&lt;Message&gt; messages;</code></li></ul><p> 储存一个人接收到的 Message。由于 <code>getReceivedMessages</code> 方法以及 <code>Network</code> 中 <code>sendMessage</code> 方法的规格对 <code>messages</code> 的顺序有要求，故采用 <code>List</code> 进行存储；又由于 <code>sendMessage</code> 对 <code>messages</code> 进行的是头插操作，且没有涉及到对这个 <code>List</code> 的按下标访问，故相较于 <code>ArrayList</code> 而言选用了更适合头插与顺序遍历的 链表<code>LinkedList</code></p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><ul><li><code>HashMap: &lt;Person.id, Person&gt;</code></li></ul><p> 该容器储存该 group 内含有的人。这里选用了 <code>HashMap</code> 是出于考虑到我们实现的 <code>Network</code> 需要大量的根据 <code>id</code> 查询到某个Person的操作，所以将 id 和实体建立 <code>HashMap</code> 以便于查询。</p><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ul><li><code>HashMap: &lt;Person.id, Person&gt;</code></li></ul><p>用于实现id–&gt;person的快速查找。</p><ul><li><code>HashMap: &lt;Message.id, Message&gt;</code></li></ul><p>用于实现id–&gt;message的快速查找。</p><ul><li><code>HashMap: &lt;Group.id, Group&gt;</code></li></ul><p>用于实现id–&gt;group的快速查找。</p><ul><li><code>HashMap: &lt;Emoji.id, Emoji.heat&gt;</code></li></ul><p>用于存储该 Network 中含有的表情以及表情对应的热度。</p><ul><li><code>HashMap&lt;Person.id, Person.id&gt; father;//id-father</code></li></ul><p>用于实现并查集的基本结构，并查集可以用于查找是否连通isCircle()和查询最小生成树queryLeastConnection()</p><ul><li><code>HashMap&lt;emoji.id, heat&gt; // emoji id-heat</code></li></ul><p>用于实现emoji.id—&gt;heat的快速查找。</p><h3 id="1-2-性能问题的解决"><a href="#1-2-性能问题的解决" class="headerlink" title="1.2 性能问题的解决"></a>1.2 性能问题的解决</h3><p>在本部分我将围绕三次作业中可能出现性能问题的几个函数进行阐述，并解释我如何解决这些性能问题。在三次作业中我们需要根据JMl实现许多函数功能，一旦这些函数设计到O(n^2)及以上的复杂度，我们就要慎重的考虑其实现方式，尽可能的降低其时间复杂度。</p><h4 id="1-2-1-getValueSum-qgvs-—-维护方式实现"><a href="#1-2-1-getValueSum-qgvs-—-维护方式实现" class="headerlink" title="1.2.1 getValueSum (qgvs) —-维护方式实现"></a>1.2.1 getValueSum (qgvs) —-维护方式实现</h4><p>求一个 Group 中所有边的边权之和。对于该方法如果直接按照规格去对组内的 Person 进行二重循环遍历并两两判断是否有边，则单次执行该方法时间复杂度为 O(n^2)，如果强测数据中有大量的 qgvs 指令便可能会超时 。我的方式是采取维护的方式实现，实现方法是采用一个变量来记录当前 Group 中所有边的边权之和，在对该组 <code>addPerson</code> 与 <code>delPerson</code> ，以及对组内的人进行 <code>addRelation</code> 时对边权和进行维护，对value值进行更新，使得 <code>getValueSum</code> 方法本身的复杂度为 O(1) ，可以满足性能要求。</p><h4 id="1-2-2-getAgeMean与getAgeVar-—-维护方式实现"><a href="#1-2-2-getAgeMean与getAgeVar-—-维护方式实现" class="headerlink" title="1.2.2 getAgeMean与getAgeVar —-维护方式实现"></a>1.2.2 getAgeMean与getAgeVar —-维护方式实现</h4><p>求一个用户组内所有用户的年龄平均值与年龄方差，如果按照JML方式来实现，是一个O(n)的一重循环，虽然数据少时不会产生性能问题，但是多次查询时，每次都要重新计算，难免会降低性能。因此同样采用维护的方式实现，在此我们引入年龄平方和<em>ageSqrSum</em>，<em>ageSum</em>在<code>addPerson</code>和<code>delPerson</code>时对<em>ageAqrSum</em>，<em>ageSum</em>进行更新（相应的加减操作），getAgeMean与getAgeVar可以用公式</p><p><img src="https://note.youdao.com/yws/api/personal/file/B47023C3E9EB4605BF16E42A3FB89425?method=download&shareKey=2e2d32060012aca862c8a88e8434eb38"></p><p>求出，注意公式的计算一定要按照JML展开且不能随意化简，否则会出现精度问题。</p><h4 id="1-2-3-isCircle-—-并查集实现"><a href="#1-2-3-isCircle-—-并查集实现" class="headerlink" title="1.2.3 isCircle —- 并查集实现"></a>1.2.3 isCircle —- 并查集实现</h4><p> 该方法实际意义为判断无向图上的两个节点是否连通，可采用并查集来实现。并查集 相关资料在网上很多，阅读之后很快就可以理解，其精华在于<strong>记录每个节点所在的组号（这里的组不是我们实现的Group的意思，而是这个节点所在的子图），边查找边更新</strong>。用并查集的方法，两个节点连通只要查找其组号是否相同。</p><h4 id="1-2-4-queryBlockSum-—-维护实现"><a href="#1-2-4-queryBlockSum-—-维护实现" class="headerlink" title="1.2.4 queryBlockSum —- 维护实现"></a>1.2.4 queryBlockSum —- 维护实现</h4><p>该方法求无向图中连通块的数量，引入变量blockSum初始化为0。addPeson时，该Person与任何人都无关系，blockSum肯定加1，在addRelation时，如果联通的两人不属于同一个子图，联通二者以后blockSum减1。</p><h4 id="1-2-5-sendIndirectMessage-—-堆优化的Dijkstra-算法"><a href="#1-2-5-sendIndirectMessage-—-堆优化的Dijkstra-算法" class="headerlink" title="1.2.5 sendIndirectMessage —-  堆优化的Dijkstra 算法"></a>1.2.5 sendIndirectMessage —-  堆优化的Dijkstra 算法</h4><p>该方法的返回值是两个人之间的最短路，需采用 Dijkstra 算法对无向图中的单源最短路进行求解。注意使用 Dijkstra 时需要采用堆优化。</p><h4 id="1-2-6-queryLeastConnection-—-并查集-kruskal算法实现最小生成树"><a href="#1-2-6-queryLeastConnection-—-并查集-kruskal算法实现最小生成树" class="headerlink" title="1.2.6 queryLeastConnection —- 并查集+kruskal算法实现最小生成树"></a>1.2.6 queryLeastConnection —- 并查集+kruskal算法实现最小生成树</h4><p>这个函数要求我们找到某一节点所在的子图的最小生成树。首先我们利用之前实现的并查集可以找到该节点所在的子图，接下来使之前学过的的Kruskal算法实现最小生成树即可（当然使用其他的最小生成树算法例如Prim也可以）。</p><h2 id="2-1-Hack策略与测试方法"><a href="#2-1-Hack策略与测试方法" class="headerlink" title="2.1 Hack策略与测试方法"></a>2.1 Hack策略与测试方法</h2><h3 id="2-1-2-测试方法"><a href="#2-1-2-测试方法" class="headerlink" title="2.1.2 测试方法"></a>2.1.2 测试方法</h3><p>本单元中再进行测试时，我一开始尝试学习了Junit方法，但是感觉作用不大，不如和伙伴们一起对拍来的快且高效。下面是编写的一个简单的数据自动生成程序，总体上采用随机生成的策略，先加入必要的元素，再加入大量的query查询方法。用这种方法我和伙伴们也确实有效快速地找到了一些Bug，因此本单元强测互测都没有出现Bug。总而言之，这个单元与前两个单元相比，生成数据的方法更加简单，同时输出的结果也是一定的，采用对拍的方式对于第三单元来说非常有效。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#数据自动生成器</span><span class="token keyword">import</span> os<span class="token keyword">import</span> random<span class="token comment"># 1000人 id 0 ---- 4000</span>numof_person <span class="token operator">=</span> <span class="token number">1000</span><span class="token comment"># 25组   id 0 ---- 10</span>numof_group <span class="token operator">=</span> <span class="token number">10</span><span class="token comment"># 3000条关系</span>numof_relation <span class="token operator">=</span> <span class="token number">3000</span><span class="token comment"># 500 for 3 kinds of message</span>numof_red_envelop_message <span class="token operator">=</span> <span class="token number">250</span>  <span class="token comment"># 250 type0,250type1 total 500</span>numof_notice_message <span class="token operator">=</span> <span class="token number">250</span>  <span class="token comment"># 250 type0,250type1 total 500</span>numof_emoji_message <span class="token operator">=</span> <span class="token number">250</span>  <span class="token comment"># 250 type0,250type1 total 500</span>numof_message <span class="token operator">=</span> <span class="token number">250</span>  <span class="token comment"># 250 type0,250type1 total 500</span><span class="token comment"># 实现messeageid独一无二</span><span class="token keyword">def</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    total <span class="token operator">=</span> <span class="token number">0</span>    f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"testPoints.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>    cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        cnt<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># ag 10</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_group<span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"ag "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token comment"># ap 1000 times and add to random group</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_person<span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"ap "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">" testname"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" \n"</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"atg "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token comment"># ar 3000</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_relation<span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"ar "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token comment"># am 250type1 250 type0</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_message<span class="token punctuation">)</span><span class="token punctuation">:</span>        m0 <span class="token operator">=</span> <span class="token string">"am "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        m1 <span class="token operator">=</span> <span class="token string">"am "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>numof_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m0<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m1<span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> numof_message    <span class="token comment"># arem add red envelop</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_red_envelop_message<span class="token punctuation">)</span><span class="token punctuation">:</span>        m0 <span class="token operator">=</span> <span class="token string">"arem "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        m1 <span class="token operator">=</span> <span class="token string">"arem "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> numof_red_envelop_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m0<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m1<span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> numof_red_envelop_message    <span class="token comment"># add notice</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_notice_message<span class="token punctuation">)</span><span class="token punctuation">:</span>        m0 <span class="token operator">=</span> <span class="token string">"anm "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token string">"goodluck"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        m1 <span class="token operator">=</span> <span class="token string">"anm "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> numof_notice_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token string">"goodluck"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m0<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m1<span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> numof_notice_message    <span class="token comment"># store some emoji</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"sei "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"sei "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>numof_emoji_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    <span class="token comment"># add emoji</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>numof_emoji_message<span class="token punctuation">)</span><span class="token punctuation">:</span>        m0 <span class="token operator">=</span> <span class="token string">"aem "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        m1 <span class="token operator">=</span> <span class="token string">"aem "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>total <span class="token operator">+</span> numof_emoji_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>numof_emoji_message <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> \             <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> \             <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m0<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>m1<span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> numof_emoji_message    <span class="token comment">##########################################</span>    <span class="token comment"># now we start query!!!!!!!!!!!!</span>    <span class="token comment">##########################################</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">:</span>        number <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> number <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qci "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                    <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qbs\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qgps "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qgvs "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qgav "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"sm "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qsv "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qrm "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qlc "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>                <span class="token string">"dfg "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_group<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"cn "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">11</span><span class="token punctuation">:</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"sei "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> numof_emoji_message<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">:</span>  <span class="token comment"># qp</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qp "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> numof_emoji_message<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">:</span>  <span class="token comment"># qm</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"qm "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> numof_person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> number <span class="token operator">==</span> <span class="token number">14</span><span class="token punctuation">:</span>  <span class="token comment">#</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"sim "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>  <span class="token comment"># dce 不能加太多</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"dce "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    spawn<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-3-Hack策略"><a href="#2-1-3-Hack策略" class="headerlink" title="2.1.3 Hack策略"></a>2.1.3 Hack策略</h3><p>在本单元Hack时，大家出问题的地方往往是没有认真仔细阅读JML，比如组内人数不能超过1111等等。另一个就是性能问题，我在Hack时采用的是阅读代码，针对容易出问题的地方比如说1111这类的问题，直接在代码里看有没有出问题。再一个就是针对每次作业中容易出问题的性能问题的方法比如qgvs,qgbs,qic等等方法，构造大量的查询query数据来看其是否超时。这两个策略都比较简单而且有效。</p><h2 id="3-1-Network图模型架构的扩展"><a href="#3-1-Network图模型架构的扩展" class="headerlink" title="3.1 Network图模型架构的扩展"></a>3.1 Network图模型架构的扩展</h2><h3 id="3-1-1-需求分析"><a href="#3-1-1-需求分析" class="headerlink" title="3.1.1 需求分析"></a>3.1.1 需求分析</h3><p>假设出现了几种不同的Person</p><ul><li><code>Advertiser</code>：持续向外发送产品广告</li><li><code>Producer</code>：产品生产商，通过Advertiser来销售产品</li><li><code>Customer</code>：消费者，会关注广告并选择和自己偏好匹配的产品来购买 – 所谓购买，就是直接通过<code>Advertiser</code>给相应<code>Producer</code>发一个购买消息</li><li><code>Person</code>：吃瓜群众，不发广告，不买东西，不卖东西</li></ul><ol><li>NetWork可以支持市场营销，并能查询某种商品的销售额和销售路径</li><li>请讨论如何对Network扩展，给出相关接口方法，并选择3个核心业务功能的接口方法撰写JML规格</li></ol><h3 id="3-1-2-设想架构"><a href="#3-1-2-设想架构" class="headerlink" title="3.1.2 设想架构"></a>3.1.2 设想架构</h3><ol><li><code>Advertiser</code>, <code>Producer</code>, <code>Customer</code>本质上都是Person，可以让他们均继承Person类</li><li>广告本质上是一条Message，新增广告类Advertisement继承 Message</li><li>此外我们还需要商品类Product，新增商品类Product</li></ol><p><strong>一下是上述类内部的大致属性与方法(一些不重要的方法类似getter，setter没有列出)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Product</span><span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span> <span class="token comment">//商品id独一无二</span><span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span> <span class="token comment">//商品价格</span><span class="token keyword">private</span> <span class="token keyword">int</span> type ；<span class="token comment">//商品的种类，这里用int来代表</span>        <span class="token comment">//Advertisement</span><span class="token keyword">private</span> <span class="token keyword">int</span> id <span class="token punctuation">;</span><span class="token comment">//独一无二的id</span><span class="token keyword">private</span> <span class="token class-name">Product</span> product<span class="token punctuation">;</span><span class="token comment">//该广告所对应的商品</span><span class="token keyword">private</span> <span class="token class-name">Person</span> advertiser<span class="token punctuation">;</span><span class="token comment">//该广告的源头广告商</span><span class="token keyword">private</span> <span class="token class-name">Group</span> group<span class="token punctuation">;</span> <span class="token comment">//一般广告不止发给某一个人，在这里我们默认直接发往某一组的所有人</span><span class="token comment">//Adevertiser</span><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Advertisement</span><span class="token punctuation">></span></span> ads<span class="token punctuation">;</span> <span class="token comment">//待发送的广告</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendAd</span><span class="token punctuation">(</span><span class="token class-name">Advertisement</span> ad<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发一条广告，要想实现“Advertiser持续向外发送产品广告”可以将Adevertiser实现为进程然后不断操作该方法</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addAd</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product，<span class="token class-name">Person</span> person，<span class="token class-name">Group</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ads加入一条关于product的广告</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendBuymessage</span><span class="token punctuation">(</span><span class="token class-name">Advertisement</span> ad<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给Producer发送一条购买消息</span><span class="token comment">//Producer</span><span class="token keyword">private</span> <span class="token class-name">Advertiser</span> advertiser<span class="token punctuation">;</span><span class="token comment">//对接的广告商，发送广告时通过他</span><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">></span></span> products<span class="token punctuation">;</span><span class="token comment">//已生产的商品</span><span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> sales<span class="token punctuation">;</span><span class="token comment">//type类型商品对应销售额</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">,</span><span class="token class-name">Group</span> group<span class="token punctuation">)</span><span class="token comment">//售卖product，通过广告商发一条广告给group里的所有人</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生产一个product</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySales</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//查询某一产品销售额</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalesAmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//得到HashMap对应type种类商品的销售额</span><span class="token comment">//Customer</span><span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> like<span class="token punctuation">;</span> <span class="token comment">//type的商品对应的喜爱值 type - likevalue</span><span class="token keyword">private</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Advertisement</span><span class="token punctuation">></span></span> recieveAds<span class="token punctuation">;</span><span class="token comment">//目前为止接受到的广告</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从目前的收到的广告里挑一个最爱的type类型的商品购买，如果有多个最喜爱的商品的广告，只卖最早接收到的那个，一次只买一个</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addReceiveAds</span><span class="token punctuation">(</span><span class="token class-name">Advertisement</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//收到一条广告</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-3-核心类JML撰写"><a href="#3-1-3-核心类JML撰写" class="headerlink" title="3.1.3 核心类JML撰写"></a>3.1.3 核心类JML撰写</h3><p>下面挑选了三个核心方法的JML类进行撰写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Producer</span><span class="token comment">/*@ public normal_behavior  @ requires !(\exists int i; 0 &lt;= i &amp;&amp; i &lt; products.length;                               @       products[i].equals(product));  @ assignable products;  @ ensures products.length == \old(products.length) + 1;  @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(products.length);  @          (\exists int j; 0 &lt;= j &amp;&amp; j &lt; products.length; products[j] == (\old(products[i]))));  @ ensures (\exists int i; 0 &lt;= i &amp;&amp; i &lt; products.length; products[i] == product);  @ also  @ public exceptional_behavior  @ signals (EqualProductIdException e) (\exists int i; 0 &lt;= i &amp;&amp; i &lt; products.length;  @                                     products[i].equals(product));  @*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">EqualProductIdException</span><span class="token punctuation">;</span><span class="token comment">//Advertiser</span>    <span class="token comment">/*@ public normal_behavior      @ requires containsAd(ad)      @ assignable ad.group.people[*].recieveAds,ads;      @ ensures !containsAd(id) &amp;&amp; ads.length == \old(ads.length) - 1 &amp;&amp;      @         (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(ads.length) &amp;&amp; \old(ads[i].getId()) != id;      @         (\exists int j; 0 &lt;= j &amp;&amp; j &lt; ads.length; ads[j].equals(\old(ads[i]))));      @ ensures (\forall Person p; ad.getGroup().hasPerson(p) &amp;&amp; (p instance of Customer);                        @p.receiveAds.length == \old(p.receiveAds.length) + 1;      @         &amp;&amp; (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(p.receiveAds.length);      @             (\exists int j; 0 &lt;= j &amp;&amp; j &lt; p.receiveAds.length;                         @                     p.receiveAds[j].equals(\old(p.receiveAds[i]))));      @         &amp;&amp; (\exists int i; 0 &lt;= i &amp;&amp; i &lt; p.receiveAds.length; p.receiveAds[i].equals(ad));      @ also      @ public exceptional_behavior      @ signals (AdNotFoundException e) !containsAd(ad);      @*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendAd</span><span class="token punctuation">(</span><span class="token class-name">Advertisement</span> ad<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Producer</span><span class="token comment">/*@ public normal_behavior      @ requires containsType(type);      @ ensures \result == getSalesAmount();      @ also      @ public exceptional_behavior      @ signals (TypeNotFoundException e) !containsType(type);      @*/</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">querySales</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本单元难度不大，主要是在学习一些JML的功能，同时在这一单元也学习到了一些算法的内容类似并查集，堆优化的迪杰斯特拉算法等等。</p><p>在这里有一个小建议，如果这个单元主要内容是让大家学会JML的阅读和理解的话，我觉得可能不需要三次作业，1~2次作业我觉得已经足够,第三次作业的话感觉就是在学习写更多的算法，其中JML的东西还是第1,2次作业那些东西，没有学到什么新的JML的知识，感觉没有必要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab5实验报告</title>
      <link href="/2022/06/20/2022-cao-zuo-xi-tong-lab5-shi-yan-bao-gao/"/>
      <url>/2022/06/20/2022-cao-zuo-xi-tong-lab5-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab5-实验报告"><a href="#Lab5-实验报告" class="headerlink" title="Lab5 实验报告"></a>Lab5 实验报告</h2><h3 id="1-1-思考题"><a href="#1-1-思考题" class="headerlink" title="1.1 思考题"></a>1.1 思考题</h3><h4 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h4><p>:label:<strong>查阅资料，了解 Linux&#x2F;Unix 的 &#x2F;proc 文件系统是什么？有什么作用？ Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好处和可以改进的地方？</strong></p><p><strong>答：</strong>proc文件系统是一个伪文件系统，他只存在内存当中，而不占用外存空间。它以文件系统的方式为访问文件系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。</p><p>其<strong>作用</strong>在于使用一种新的方法在 Linux内核空间和用户间之间进行通信。</p><p>对于Windows，其通过系统调用改变内核运行状态和查看进程信息</p><ul><li><p>好处：对系统调用进一步抽象，用户可以直接通过proc伪文件系统访问内核，降低用户操作复杂度，提升了系统运行效率。</p></li><li><p>缺点：proc伪文件系统需要在内存中实现，占用内存空间。</p></li><li><p>改进：proc伪文件系统由于需要占用内存，我想改进之处在于采用更好的数据结构减少其在内存中的大小，减少占用内存的空间。</p></li></ul><h4 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h4><p>:label:<strong>如果我们通过 kseg0 读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0 访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。</strong></p><p><strong>答：</strong>因为内核被放在kseg0区域，该区域需要通过cache访问；如果对设备的写入缓存到cache中，就会导致以后想访问内核时却错误访问了写入设备的内容，导致访问错误。</p><p>对于不同设备的操作有差异，例如串口设备读写比IDE频繁，发生读写错误的概率更高。</p><h4 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h4><p>:label:<strong>比较 MOS 操作系统的文件控制块和 Unix&#x2F;Linux 操作系统的 inode 及相关概念，试述二者的不同之处。</strong></p><p><strong>答：</strong>下图展示了 Unix&#x2F;Linux 操作系统的 inode 存储的重要信息。</p><p><img src="https://note.youdao.com/yws/api/personal/file/10E9DB77968D43E6A426E27A251DB455?method=download&shareKey=d75f2b4f48fe7dc3917e58ceebe5c06a"></p><p>可以看到MOS系统的文件控制块与Linux的inode都存储的是文件基本信息。但是我们可以发现inode<strong>不</strong>包含文件名，而Mos系统的文件控制块包含文件名，这便是二者的区别。</p><p><strong>为什么Linux系统inode不需要存储文件名？</strong>是因为，每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix&#x2F;Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><h4 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h4><p>:label:<strong>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件 控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为 多大？</strong></p><p><strong>答：</strong>文件控制块大小256B，磁盘块4KB，故最多16个控制块</p><p>目录4096KB，一个文件控制块256B，故最多<code>4096KB/256B = 16384</code>个文件；</p><p>十个直接指针指向的磁盘块一共40KB，间接指针最多<code>1024-10 = 1014 </code>个，间接指针的磁盘块大小<code>1014*4KB = 4056KB</code>,总共<code>4056KB+40KB = 4096KB</code>.</p><p>我们的文件系统支持的单个文件最大为4096KB.</p><h4 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h4><p>:label:<strong>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</strong></p><p><strong>答：</strong>我们的操作系统中，文件系统服务是一个用户进程，一个进程可以拥有4G 的虚拟内存空间，将DISKMAP 到DISKMAP+DISKMAX 这一段虚存地址空间(0x10000000-0x4ffffff) 作为缓冲区，当磁盘读入内存时，用来映射相关的页。由此可见，为了满足块缓存的设计，我们实验使用的内核支持的最大磁盘大小是<code>0x40000000 = 1GB</code>.</p><h4 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h4><p>:label:<strong>如果将 DISKMAX 改成 0xC0000000, 超过用户空间，我们的文件系统还能正常工作吗？为什么？</strong></p><p><strong>答：</strong>不能，因为缓存磁盘块的时候可能会把内核的内容覆盖掉，导致系统运行异常</p><h4 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h4><p>:label:<strong>在 lab5 中，fs&#x2F;fs.h、include&#x2F;fs.h 等文件中出现了许多结构体和宏定 义，写出你认为比较重要或难以理解的部分，并进行解释。</strong></p><p><strong>答：</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;一些需要理解的宏#define BY2BLKBY2PG &#x2F;&#x2F;一个块的大小正好是一页4096Byte#define BIT2BLK(BY2BLK*8) &#x2F;&#x2F;这里算的是BLK的bit，所以自然是*8#define BY2FILE     256 &#x2F;&#x2F;一个file结构体的大小 256Byte#define NBLOCK 1024  &#x2F;&#x2F;一个disk里面有1024块#define FILE2BLK  (BY2BLK&#x2F;sizeof(struct File)) &#x2F;&#x2F;一个块里面有多少个file结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;需要重点理解的文件控制块结构体struct File &#123;    u_char f_name[MAXNAMELEN];  &#x2F;&#x2F; filename 件名的最大长度 MAXNAMELEN 值为 128    u_int f_size;           &#x2F;&#x2F; file size in bytes    u_int f_type;           &#x2F;&#x2F; file type为文件类型，有普通文件 (FTYPE_REG) 和文件夹 (FTYPE_DIR) 两种。    u_int f_direct[NDIRECT];&#x2F;&#x2F;f_direct[NDIRECT] 为文件的直接指针，每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。    &#x2F;&#x2F;每个磁盘块的大小为 4KB，也就是说，这十个直接指针能够表示最大 40KB 的文件，而当文件的大小大于 40KB 时，就需要用到间接指针。    u_int f_indirect; &#x2F;&#x2F;f_indirect指向一个间接磁盘块，用来存储许多指针，这些指针指向文件内容的磁盘块。有点像二重指针？指针指向存储指针的磁盘块，这些指针才真正指向文件内容磁盘块。    struct File *f_dir;     &#x2F;&#x2F; f_dir指向文件所属的文件目录    u_char f_pad[BY2FILE - MAXNAMELEN - 4 - 4 - NDIRECT * 4 - 4 - 4];    &#x2F;&#x2F;f_pad则是为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-5-8"><a href="#Thinking-5-8" class="headerlink" title="Thinking 5.8"></a>Thinking 5.8</h4><p>:label:<strong>阅读 user&#x2F;file.c，你会发现很多函数中都会将一个 struct Fd* 型的 指针转换为 struct Filefd* 型的指针，请解释为什么这样的转换可行。</strong></p><p><strong>答：</strong>因为在结构体Filefd中储存的第一个元素就是struct Fd。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; file descriptor + filestruct Filefd &#123;    struct Fd f_fd; &#x2F;&#x2F;结构体Filefd中储存的第一个元素就是struct Fd*。    u_int f_fileid;    struct File f_file;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因而对于相匹配的一对struct Fd和struct Filefd，他们的指针实际上指向了相同的虚拟地址，所以可以通过指针转化访问struct Filefd中的其他元素。</p><h4 id="Thinking-5-9"><a href="#Thinking-5-9" class="headerlink" title="Thinking 5.9"></a>Thinking 5.9</h4><p>:label:<strong>在lab4 的实验中我们实现了极为重要的fork 函数。那么fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成练习5.8和5.9的基础上编写一个程序进行验证。</strong></p><p><strong>答：</strong>首先在磁盘上挂载一个文件lab5test，接下来是我编写的程序</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;lib.h&quot;  void umain()&#123;    int a &#x3D; 0;    int id &#x3D; 0;    int fd;    if((fd &#x3D; open(&quot;&#x2F;lab5test&quot;,O_RDWR))&lt;0)&#123;        user_panic(&quot;open &#x2F;lab5test :%d&quot;,fd);    &#125;    writef(&quot;father write fd : %d\n&quot;,fd);    char  buf[30]&#x3D;&quot;I want to write1&quot;;    char buf2[30] &#x3D; &quot;I want to write2&quot;;    write(fd,buf,30);    write(fd,buf2,30);    if((id &#x3D; fork()) &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F; son        char sonbuf[30];        writef(&quot;son read fd : %d\n&quot;,fd);        read(fd,sonbuf,30);        writef(&quot;son read %s\n&quot;,sonbuf);    &#125;    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是结果</p><p><img src="https://note.youdao.com/yws/api/personal/file/0CB56299D5394430941D24A655F73DAA?method=download&shareKey=555281891a8fc52cb56cbf4120a066c6"></p><p>首先可以看到文件描述符fd确实是继承了，再看<strong>子进程读到的数据是一个空串</strong>，说明文件定位指针也继承了，因为如果未继承的话，子进程read又会从头开始读，读到的是“I want to write1”.</p><h4 id="Thinking-5-10"><a href="#Thinking-5-10" class="headerlink" title="Thinking 5.10"></a>Thinking 5.10</h4><p>:label:<strong>请解释Fd, Filefd, Open 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</strong></p><p><strong>答：</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; file descriptorstruct Fd &#123;    u_int fd_dev_id;&#x2F;&#x2F;外设id    u_int fd_offset;&#x2F;&#x2F;读或写的当前位置    u_int fd_omode;&#x2F;&#x2F;打开方式&#125;;&#x2F;&#x2F; file descriptor + filestruct Filefd &#123;    struct Fd f_fd; &#x2F;&#x2F;记录了文件描述符    u_int f_fileid;&#x2F;&#x2F;记录了文件的id    struct File f_file; &#x2F;&#x2F;文件控制块&#125;;struct Open &#123;    struct File *o_file; &#x2F;&#x2F;指向了对应的文件控制块    u_int o_fileid;     &#x2F;&#x2F; 表示文件id用于在数组opentab中查找对应的Open    int o_mode;     &#x2F;&#x2F;记录文件打开的状态    struct Filefd *o_ff;    &#x2F;&#x2F;指向对应的Filefd结构体&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在完成课下实验时，上述结构体在open,read,write函数中用到了。</p><h4 id="Thinking-5-11"><a href="#Thinking-5-11" class="headerlink" title="Thinking 5.11"></a>Thinking 5.11</h4><p>:label:<strong>UML时序图中有多种不同形式的箭头，请结合UML 时序图的规范，解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</strong></p><p><strong>答：</strong>这个UML时序图里面只涉及两种箭头。</p><ul><li><p>同步消息：<strong>用黑三角箭头搭配黑实线表示</strong></p></li><li><p>返回消息，用黑三角箭头搭配黑色虚线表示</p></li></ul><p>返回消息和同步消息结合使用，进程发出同步消息后等待得到返回消息才可继续执行。</p><p><code>“并思考我们的操作系统是如何实现对应类型的进程间通信的。</code>这个问题表述的不是很清楚？没太看懂，我的理解是解释我们的操作系统是如何利用进程通信实现文件系统服务的。在我们的操作系统中，用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体（fsreq）中进行消息的传递，fs_serv 进程收到其他进行的IPC 请求后，IPC 传递的消息包含了请求的类型（定义在include&#x2F;fs.h中）和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过IPC 反馈给用户程序。</p><h4 id="Thinking-5-12"><a href="#Thinking-5-12" class="headerlink" title="Thinking 5.12"></a>Thinking 5.12</h4><p>:label:<strong>阅读serv.c&#x2F;serve函数的代码，我们注意到函数中包含了一个死循环for (;;) {…}，为什么这段代码不会导致整个内核进入panic 状态？</strong></p><p><strong>答：</strong>因为调用ipc_recv的时候这个进程会等待其他进程向他发送请求文件系统调用再继续执行，如果没有接收到请求就会在这里一直等待，因此不会造成死循环。</p><h3 id="1-2-实验难点"><a href="#1-2-实验难点" class="headerlink" title="1.2 实验难点"></a>1.2 实验难点</h3><p>实验难点在于多个结构体和需要记忆理解的宏，经过总结，本次实验一共出现了6个重要结构体，加下来将其进行了总结。</p><h4 id="1-2-1-6个重要结构体"><a href="#1-2-1-6个重要结构体" class="headerlink" title="1.2.1 6个重要结构体"></a>1.2.1 6个重要结构体</h4><ul><li>超级块结构体</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/CFAB2AA4D1624F5FAAE29D9299479A2B?method=download&shareKey=76a4319cc51d5109b6533ebc6ff6c268" alt="image-20220520221159768"></p><ul><li>Block结构体</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct Block &#123;    uint8_t data[BY2BLK];  &#x2F;&#x2F;数据区512Byte    uint32_t type; &#x2F;&#x2F;类型包括下面的enum&#125; disk[NBLOCK];enum &#123;    BLOCK_FREE  &#x3D; 0,    BLOCK_BOOT  &#x3D; 1,    BLOCK_BMAP  &#x3D; 2,    BLOCK_SUPER &#x3D; 3,    BLOCK_DATA  &#x3D; 4,    BLOCK_FILE  &#x3D; 5,    BLOCK_INDEX &#x3D; 6,&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>File文件结构体</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct File &#123;    u_char f_name[MAXNAMELEN];  &#x2F;&#x2F; filename 件名的最大长度 MAXNAMELEN 值为 128    u_int f_size;           &#x2F;&#x2F; file size in bytes    u_int f_type;           &#x2F;&#x2F; file type为文件类型，有普通文件 (FTYPE_REG) 和文件夹 (FTYPE_DIR) 两种。    u_int f_direct[NDIRECT];&#x2F;&#x2F;f_direct[NDIRECT] 为文件的直接指针，每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。    &#x2F;&#x2F;每个磁盘块的大小为 4KB，也就是说，这十个直接指针能够表示最大 40KB 的文件，而当文件的大小大于 40KB 时，就需要用到间接指针。    u_int f_indirect; &#x2F;&#x2F;f_indirect指向一个间接磁盘块，用来存储许多指针，这些指针指向文件内容的磁盘块。有点像二重指针？指针指向存储指针的磁盘块，这些指针才真正指向文件内容磁盘块。    struct File *f_dir;     &#x2F;&#x2F; f_dir指向文件所属的文件目录    u_char f_pad[BY2FILE - MAXNAMELEN - 4 - 4 - NDIRECT * 4 - 4 - 4];    &#x2F;&#x2F;f_pad则是为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设备结构体</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct Dev &#123;    int dev_id;    char *dev_name;    &#x2F;&#x2F;接下来定义了一些设备操作函数    int (*dev_read)(struct Fd *, void *, u_int, u_int);    int (*dev_write)(struct Fd *, const void *, u_int, u_int);    int (*dev_close)(struct Fd *);    int (*dev_stat)(struct Fd *, struct Stat *);    int (*dev_seek)(struct Fd *, u_int);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>文件描述符结构体</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// file descriptor</span><span class="token keyword">struct</span> <span class="token class-name">Fd</span> <span class="token punctuation">&#123;</span>    u_int fd_dev_id<span class="token punctuation">;</span><span class="token comment">//外设id</span>    u_int fd_offset<span class="token punctuation">;</span><span class="token comment">//读或写的当前位置</span>    u_int fd_omode<span class="token punctuation">;</span><span class="token comment">//打开方式</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Filefd结构体</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; file descriptor + filestruct Filefd &#123;    struct Fd f_fd;    u_int f_fileid;    struct File f_file;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重要的宏</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;一些宏#define BY2BLKBY2PG &#x2F;&#x2F;一个块的大小正好是一页4096Byte#define BIT2BLK(BY2BLK*8) &#x2F;&#x2F;这里算的是BLK的bit，所以自然是*8#define BY2FILE     256 &#x2F;&#x2F;一个file结构体的大小 256Byte#define NBLOCK 1024  &#x2F;&#x2F;一个disk里面有1024块#define FILE2BLK  (BY2BLK&#x2F;sizeof(struct File)) &#x2F;&#x2F;一个块里面有多少个file结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-个重要理解函数（主要是花费很长时间理解的两个函数，在这里把他们记录下来）"><a href="#1-2-2-个重要理解函数（主要是花费很长时间理解的两个函数，在这里把他们记录下来）" class="headerlink" title="1.2.2 个重要理解函数（主要是花费很长时间理解的两个函数，在这里把他们记录下来）"></a>1.2.2 个重要理解函数（主要是花费很长时间理解的两个函数，在这里把他们记录下来）</h4><ul><li>fs&#x2F;fs.c: dir_lookup()</li></ul><p>给定一个File* dir自然能找到它对应在内存中的block块。</p><p>然后因为block中放的就是File结构体，所以，遍历一个block块中的File结构体，将file_name一一对比就行。</p><ul><li>fd_lookup(fdnum, Fd)</li></ul><p>给定fdnum，将fd变成要的。这个很重要，有了fd，就有了ffd，有了ffd，就有了file。</p><h3 id="1-3-心得体会"><a href="#1-3-心得体会" class="headerlink" title="1.3 心得体会"></a>1.3 心得体会</h3><p>lab5相对于上次lab4难度有所降低，只要认真阅读代码基本上可以理解。本次作业更让我意识到进程通信的重要性，原来文件系统也可以通过进程通信实现，真是奇妙。lab5的结束也代表着os实验部分进入了尾声，通过这段时间的学习，让我收获最大的就是对C语言的了解更加充分、更加透彻，其次就是对操作系统的工作原理有了具体的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab6实验报告</title>
      <link href="/2022/06/20/2022-cao-zuo-xi-tong-lab6-shi-yan-bao-gao/"/>
      <url>/2022/06/20/2022-cao-zuo-xi-tong-lab6-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab6-实验报告"><a href="#Lab6-实验报告" class="headerlink" title="Lab6 实验报告"></a>Lab6 实验报告</h2><h3 id="1-1-思考题"><a href="#1-1-思考题" class="headerlink" title="1.1 思考题"></a>1.1 思考题</h3><h4 id="label-Thinking-6-1-示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？"><a href="#label-Thinking-6-1-示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？" class="headerlink" title=":label:Thinking 6.1 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？"></a>:label:Thinking 6.1 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</h4><p><strong>答：</strong>把原来fd[]数组的0、1互换即可,read,write操作互换即可。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int fildes[2];&#x2F;* buf size is 100 *&#x2F;char buf[100];int status;int main()&#123;status &#x3D; pipe(fildes);if (status &#x3D;&#x3D; -1 ) &#123;&#x2F;* an error occurred *&#x2F;printf(&quot;error\n&quot;);&#125;switch (fork()) &#123;case -1: &#x2F;* Handle error *&#x2F;break;case 0: &#x2F;* Child - reads from pipe *&#x2F;close(fildes[0]); &#x2F;* Read end is unused *&#x2F;write(fildes[1], &quot;Hello world\n&quot;, 12); &#x2F;* Write data on pipe *&#x2F;printf(&quot;child-process Write:%s&quot;,buf); &#x2F;* Print the data *&#x2F;close(fildes[1]); &#x2F;* Finished with pipe *&#x2F;exit(EXIT_SUCCESS);default: &#x2F;* Parent - writes to pipe *&#x2F;close(fildes[1]); &#x2F;* Write end is unused *&#x2F;read(fildes[0], buf, 100); &#x2F;* Read data from pipe *&#x2F;close(fildes[0]); &#x2F;* Child will see EOF *&#x2F;exit(EXIT_SUCCESS);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="label-Thinking-6-2-上面这种不同步修改-pp-ref-而导致的进程竞争问题在-user-x2F-fd-c-中的dup-函数中也存在。请结合代码模仿上述情景，分析一下我们的-dup-函数中为什么会出现预想之外的情况？"><a href="#label-Thinking-6-2-上面这种不同步修改-pp-ref-而导致的进程竞争问题在-user-x2F-fd-c-中的dup-函数中也存在。请结合代码模仿上述情景，分析一下我们的-dup-函数中为什么会出现预想之外的情况？" class="headerlink" title=":label: Thinking 6.2 上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user&#x2F;fd.c 中的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？"></a>:label: Thinking 6.2 上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user&#x2F;fd.c 中的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？</h4><p><strong>答：</strong>假设父子进程，有一对管道<code>p[2]</code>，其中父进程关闭<code>p[0]</code>完毕，准备测试<code>ispipeclosed(p[1])</code>。子进程<code>dup(p[1])</code>刚dup完毕fd，还没开始dup Pipe结构体。</p><p>此时<code>p[1]</code>引用数为3，<code>p[0]</code>引用数为1，Pipe结构体所在页因为被map到父进程的<code>p[0]</code>和子进程的<code>p[0]</code>、<code>p[1]</code>的fdData处，引用数也为3，此时pageref(wfd) &#x3D; pageref(pipe)父进程的<code>ispipeclosed(p[1])</code>就会被误判为true。</p><h4 id="label-Thinking-6-3-阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。"><a href="#label-Thinking-6-3-阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。" class="headerlink" title=":label:Thinking 6.3 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。"></a>:label:Thinking 6.3 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。</h4><p><strong>答：</strong>所有的系统调用都是原子操作。用户进程执行syscall后到操作系统完成操作返回的过程中，不会有其他程序执行。系统调用开始时，操作系统就会关闭中断（syscall.S中的CLI指令）。因此系统调用不会被打断。对于sys_ipc_recv，应理解为设置进程进入recv状态，这个设置过程不会被打断，因而也是原子操作。</p><h4 id="label-Thinking-6-4-仔细阅读上面这段话，并思考下列问题"><a href="#label-Thinking-6-4-仔细阅读上面这段话，并思考下列问题" class="headerlink" title=":label:Thinking 6.4 仔细阅读上面这段话，并思考下列问题"></a>:label:Thinking 6.4 仔细阅读上面这段话，并思考下列问题</h4><p>• 按照上述说法控制 pipeclose 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</p><p><strong>答：</strong>可以，因为原情况出现的原因是：a, b二值, a &gt; b当先减少a再减少b时，就可能会出现a &#x3D;&#x3D; b的中间态。改变顺序后b先减少 a &gt; b &gt; b* 不会出现这种状态。</p><p>• 我们只分析了 close 时的情形，那么对于 dup 中出现的情况又该如何解决？请模仿上述材料写写你的理解。</p><p><strong>答：</strong>dup是类似的，只不过情况变成了先增加b再增加a，改变顺序之后先增加a再增加b，也就不会有这种情况发生。</p><h4 id="label-Thinking-6-5-bss-在-ELF-中并不占空间，但-ELF-加载进内存后，bss-段的数据占据了空间，并且初始值都是-0。请回答你设计的函数是如何实现上面这点的？"><a href="#label-Thinking-6-5-bss-在-ELF-中并不占空间，但-ELF-加载进内存后，bss-段的数据占据了空间，并且初始值都是-0。请回答你设计的函数是如何实现上面这点的？" class="headerlink" title=":label:Thinking 6.5 bss 在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回答你设计的函数是如何实现上面这点的？"></a>:label:Thinking 6.5 bss 在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回答你设计的函数是如何实现上面这点的？</h4><p><strong>答：</strong>Load二进制文件时，根据bss段数据的memsz属性分配对应的内存空间并清零。</p><h4 id="label-Thinking-6-6-为什么我们的-b-的-text-段偏移值都是一样的，为固定值？"><a href="#label-Thinking-6-6-为什么我们的-b-的-text-段偏移值都是一样的，为固定值？" class="headerlink" title=":label:Thinking 6.6 为什么我们的 *.b 的 text 段偏移值都是一样的，为固定值？"></a>:label:Thinking 6.6 为什么我们的 *.b 的 text 段偏移值都是一样的，为固定值？</h4><p><strong>答：</strong>user.lds中有如下内容，规定了.text段在链接中第一个被链接，因此开始位置相同。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C"> . &#x3D; 0x00400000; _text &#x3D; .;    &#x2F;* Text and read-only data *&#x2F; .text : &#123;*(.text)*(.fixup)*(.gnu.warning)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="label-Thinking-6-7-在哪步，0-和-1-被”-安排”-为标准输入和标准输出？请分析代码执行流程，给出答案。"><a href="#label-Thinking-6-7-在哪步，0-和-1-被”-安排”-为标准输入和标准输出？请分析代码执行流程，给出答案。" class="headerlink" title=":label:Thinking 6.7 在哪步，0 和 1 被” 安排” 为标准输入和标准输出？请分析代码执行流程，给出答案。"></a>:label:Thinking 6.7 在哪步，0 和 1 被” 安排” 为标准输入和标准输出？请分析代码执行流程，给出答案。</h4><p><strong>答：</strong>user&#x2F;init.c中。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">opencons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"opencons: %e"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"first opencons used fd %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">user_panic</span><span class="token punctuation">(</span><span class="token string">"dup: %d"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-实验难点图示"><a href="#1-2-实验难点图示" class="headerlink" title="1.2 实验难点图示"></a>1.2 实验难点图示</h3><p>spawn函数的理解在本次实验中是一个难点，将其流程总结如下。</p><p><img src="https://note.youdao.com/yws/api/personal/file/4996E3B1BCC4468C82ED072C9DD6D926?method=download&shareKey=d1316170f5b3df9225231b895e723d3f"></p><h3 id="1-3-心得体会"><a href="#1-3-心得体会" class="headerlink" title="1.3 心得体会"></a>1.3 心得体会</h3><p>本次实验难度一般，难点在于pipe在多进程并发环境下可能出现的一些问题和spawn函数的设计，实验内容方面，真正测试shell才发现我们的系统还是有许多不完善之处，但是这样能让一个小系统跑起来，也是一个很大的收获，最终实现shell后也有很大的成就感。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab5实验笔记</title>
      <link href="/2022/06/20/2022-cao-zuo-xi-tong-lab5-shi-yan-bi-ji/"/>
      <url>/2022/06/20/2022-cao-zuo-xi-tong-lab5-shi-yan-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab5-实验笔记"><a href="#Lab5-实验笔记" class="headerlink" title="Lab5 实验笔记"></a>Lab5 实验笔记</h2><h4 id="两个系统调用函数用于读写设备（这两个函数成功的话返回0）"><a href="#两个系统调用函数用于读写设备（这两个函数成功的话返回0）" class="headerlink" title="两个系统调用函数用于读写设备（这两个函数成功的话返回0）"></a>两个系统调用函数用于读写设备（这两个函数成功的话返回0）</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;占位符 要写的数据的所处虚拟地址 写入的设备dev的地址（注意这里传入时不加A0000000） 长度int sys_write_dev(int sysno, u_int va, u_int dev, u_int len)&#123;        &#x2F;&#x2F; Your code here        if ((0x10000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x1000000)        || (0x13000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x13004200)        || (0x15000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x15000200)) &#123;        bcopy((char *)va, (char *)(dev + 0xA0000000), len);        return 0;    &#125;    return -E_INVAL;&#125;int sys_read_dev(int sysno, u_int va, u_int dev, u_int len)&#123;        &#x2F;&#x2F; Your code here        if ((0x10000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x10000000 + 0x20)        || (0x13000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x13000000 + 0x4200)        || (0x15000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x15000000 + 0x200)) &#123;        bcopy((char *)(dev + 0xA0000000), (char *)va, len);        return 0;    &#125;    return -E_INVAL;&#125;&#x2F;&#x2F;用户系统调用时调用下面这两个函数（与上面两个内核态函数一一对应）intsyscall_write_dev(u_int va, u_int dev, u_int len)&#123;return msyscall(SYS_write_dev, va, dev, len, 0, 0);&#125;intsyscall_read_dev(u_int va, u_int dev, u_int len)&#123;return msyscall(SYS_read_dev, va, dev, len, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520211751066.png" alt="image-20220520211751066"></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520211803831.png" alt="image-20220520211803831"></p><p><strong>注意这里所有的操作都是按照虚拟地址来的</strong></p><p>接着我们就可以仿照上述驱动程序写我们系统中的用户态程序，我们采用调用读写设备的系统调用可以同样实现上述功能。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">voidide_read(u_int diskno, u_int secno, void *dst, u_int nsecs)&#123;&#x2F;&#x2F; 0x200: the size of a sector: 512 bytes.int offset_begin &#x3D; secno * 0x200;int offset_end &#x3D; offset_begin + nsecs * 0x200;int offset &#x3D; 0;int tmp;while (offset_begin + offset &lt; offset_end) &#123;&#x2F;&#x2F; Your code here&#x2F;&#x2F; error occurred, then panic.tmp &#x3D; diskno;        &#x2F;&#x2F; IDE 的id 放进去 不成功的话系统调用返回的不是0 产生pannicif (syscall_write_dev((int)&amp;tmp, 0x13000010, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; 放入offsettmp &#x3D; offset_begin + offset;if (syscall_write_dev((int)&amp;tmp, 0x13000000, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; start read.放0进去读tmp &#x3D; 0;if (syscall_write_dev((int)&amp;tmp, 0x13000020, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; get result.取出返回值if (syscall_read_dev((int)&amp;tmp, 0x13000030, 4)) user_panic(&quot;error in ide_read()\n&quot;);        &#x2F;&#x2F;返回值0失败，1成功证明可以读if (tmp &#x3D;&#x3D; 0) user_panic(&quot;error in ide_read()&quot;);        &#x2F;&#x2F;1证明可以读，开始读if (syscall_read_dev((int)(dst + offset), 0x13004000, 512)) user_panic(&quot;error in ide_read()\n&quot;);        &#x2F;&#x2F;下一个sectoroffset +&#x3D; 0x200;&#125;&#125;&#x2F;&#x2F;write流程一样voidide_write(u_int diskno, u_int secno, void *src, u_int nsecs)&#123;&#x2F;&#x2F; Your code hereint offset_begin &#x3D; secno * 0x200;int offset_end &#x3D; offset_begin + nsecs * 0x200;int offset &#x3D; 0;&#x2F;&#x2F; DO NOT DELETE WRITEF !!!writef(&quot;diskno: %d\n&quot;, diskno);int tmp;while (offset_begin + offset &lt; offset_end) &#123;&#x2F;&#x2F; Your code here    &#x2F;&#x2F; copy data from source array to disk buffer.&#x2F;&#x2F; error occurred, then panic.if (syscall_write_dev((int)(src + offset), 0x13004000, 512)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; select id&#x2F;tmp &#x3D; diskno;if (syscall_write_dev((int)&amp;tmp, 0x13000010, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; offset.tmp &#x3D; offset_begin + offset;if (syscall_write_dev((int)&amp;tmp, 0x13000000, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; start to writetmp &#x3D; 1;if (syscall_write_dev((int)&amp;tmp, 0x13000020, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; get status.if (syscall_read_dev((int)&amp;tmp, 0x13000030, 4)) user_panic(&quot;error in ide_write()&quot;);if (tmp &#x3D;&#x3D; 0) user_panic(&quot;error in ide_write()&quot;);offset +&#x3D; 0x200;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意dev地址传入时不需要加A000000，直接传入规定好的设备地址即可，在系统调用里会加上A0000000</li></ul><h3 id="接下来编写文件系统"><a href="#接下来编写文件系统" class="headerlink" title="接下来编写文件系统"></a>接下来编写文件系统</h3><p>这里提到了磁盘块的概念，操作系统将多个相邻扇区合并为一个概念“磁盘块”进行操作（因为扇区实在太多无法一个一个操作，合并在一起以块为单位更好操作）</p><p>从图中可以看到，MOS 操作系统把磁盘最开始的一个磁盘块0 (4096 字节) 当作启动扇区和分区表使用。接下来的一个磁盘块1作为超级块 (Super Block)，用来描述文件系 统的基本信息，如 Magic Number、磁盘大小以及根目录的位置。</p><p>认识一下<strong>超级块的结构体</strong> —————————结构体</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520221159768.png" alt="image-20220520221159768"></p><p>在文件系统中，我们将<strong>使用位图 (Bitmap) 法</strong>来管理空闲的磁盘资源，用一个二进制位 bit 标识磁盘中的每个磁盘块的使用情况（实验中，<strong>1 表示空闲</strong>）。</p><p>在这里涉及到一些宏和</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;一些宏#define BY2BLKBY2PG &#x2F;&#x2F;一个块的大小正好是一页4096Byte#define BIT2BLK(BY2BLK*8) &#x2F;&#x2F;这里算的是BLK的bit，所以自然是*8#define BY2FILE     256 &#x2F;&#x2F;一个file结构体的大小 256Byte#define NBLOCK 1024  &#x2F;&#x2F;一个disk里面有1024块#define FILE2BLK  (BY2BLK&#x2F;sizeof(struct File)) &#x2F;&#x2F;一个块里面有多少个file结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>认识一下<strong>block结构体</strong>——————————–又是一个结构体</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct Block &#123;    uint8_t data[BY2BLK];  &#x2F;&#x2F;数据区512Byte    uint32_t type; &#x2F;&#x2F;类型包括下面的enum&#125; disk[NBLOCK];enum &#123;    BLOCK_FREE  &#x3D; 0,    BLOCK_BOOT  &#x3D; 1,    BLOCK_BMAP  &#x3D; 2,    BLOCK_SUPER &#x3D; 3,    BLOCK_DATA  &#x3D; 4,    BLOCK_FILE  &#x3D; 5,    BLOCK_INDEX &#x3D; 6,&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先初始化init_disk，下面解析这个初始化函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void init_disk() &#123;    int i, r, diff;    &#x2F;&#x2F; Step 1: Mark boot sector block.    disk[0].type &#x3D; BLOCK_BOOT;&#x2F;&#x2F;nbitblock是bitmap的BLK数目，我们首先得把这个算出来然后才能开始初始化        &#x2F;&#x2F;计算nbitblock，正常算的话直接NBLOCK&#x2F;BIT2BLK ,但是这里因为是整除会向下取整，那我们得额外加上一个BIT2BLK相当于手动加一个块向上取整，保证所有的块都有对应的bit     nbitblock &#x3D; (NBLOCK + BIT2BLK - 1) &#x2F; BIT2BLK;        nextbno &#x3D; 2 + nbitblock;    &#x2F;&#x2F; Step 2: Initialize bitmap blocks.初始化为空闲1（写0xff,一个字节全1）        &#x2F;&#x2F;首先type声明这是一个MAP，这里之前在这个文件里enum过    for(i &#x3D; 0; i &lt; nbitblock; ++i) &#123;        disk[2+i].type &#x3D; BLOCK_BMAP; &#x2F;&#x2F;加2因为bitmap从第二个块开始    &#125;    for(i &#x3D; 0; i &lt; nbitblock; ++i) &#123;         memset(disk[2+i].data, 0xff, BY2BLK);    &#125;        &#x2F;&#x2F;如果位图还有剩余，不能将最后一块位图块中靠后的一部分内容标记为空闲，因为这些位所对应的磁盘块并不存在，不可被使用。因此，将所有的位图块的每一位都置为 1 之后，还需要根据实际情况，将位图不存在的部分设为0。    if(NBLOCK !&#x3D; nbitblock * BIT2BLK) &#123;        diff &#x3D; NBLOCK % BIT2BLK &#x2F; 8;&#x2F;&#x2F;最后一部分留的没对齐的尾巴的字节数        memset(disk[2+(nbitblock-1)].data+diff, 0x00, BY2BLK - diff);&#x2F;&#x2F;BY2BLK - diff剩余的空白的全置位0    &#125;    &#x2F;&#x2F; Step 3: Initialize super block.    disk[1].type &#x3D; BLOCK_SUPER;    super.s_magic &#x3D; FS_MAGIC;    super.s_nblocks &#x3D; NBLOCK;    super.s_root.f_type &#x3D; FTYPE_DIR;    strcpy(super.s_root.f_name, &quot;&#x2F;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化玩位图之后便可以<strong>调用int block_is_free(u_int blockno)函数查看块是否空闲</strong></p><ul><li>1空闲，0不空闲</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; Overview:&#x2F;&#x2F;  Check to see if the block &#39;blockno&#39; is free via bitmap.&#x2F;&#x2F;&#x2F;&#x2F; Post-Condition:&#x2F;&#x2F;  Return 1 if the block is free, else 0.intblock_is_free(u_int blockno)&#123;    if (super &#x3D;&#x3D; 0 || blockno &gt;&#x3D; super-&gt;s_nblocks) &#123; &#x2F;&#x2F;异常情况或者超出范围        return 0;    &#125;    if (bitmap[blockno &#x2F; 32] &amp; (1 &lt;&lt; (blockno % 32))) &#123;  &#x2F;&#x2F;位运算        return 1;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用void free_block(u_int blockno)释放一个块（对应位置位1）</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">voidfree_block(u_int blockno)&#123;    &#x2F;&#x2F; Step 1: Check if the parameter &#96;blockno&#96; is valid (&#96;blockno&#96; can&#39;t be zero).    if (blockno &#x3D;&#x3D; 0 || blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;        user_panic(&quot;blockno is zero&quot;);    &#125;    &#x2F;&#x2F; Step 2: Update the flag bit in bitmap.    &#x2F;&#x2F; you can use bit operation to update flags, such as  a |&#x3D; (1 &lt;&lt; n) .    bitmap[blockno &#x2F; 32] |&#x3D; (1 &lt;&lt; (blockno % 32));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时思考为什么参数 blockno 的值不能为0？</p><p>0块是最开始的一个磁盘块 (4096 字节) 当作启动扇区和分区表使用，启动扇区的程序都丢失了还用什么磁盘？？？？？？</p><h3 id="初始化完成后接下来了解文件系统详细结构"><a href="#初始化完成后接下来了解文件系统详细结构" class="headerlink" title="初始化完成后接下来了解文件系统详细结构"></a>初始化完成后接下来了解文件系统详细结构</h3><p>先来看<strong>文件File结构体</strong> —————————————-又是一个结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token punctuation">&#123;</span>    u_char f_name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// filename 件名的最大长度 MAXNAMELEN 值为 128</span>    u_int f_size<span class="token punctuation">;</span>           <span class="token comment">// file size in bytes</span>    u_int f_type<span class="token punctuation">;</span>           <span class="token comment">// file type为文件类型，有普通文件 (FTYPE_REG) 和文件夹 (FTYPE_DIR) 两种。</span>    u_int f_direct<span class="token punctuation">[</span>NDIRECT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//f_direct[NDIRECT] 为文件的直接指针，每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。</span>    <span class="token comment">//每个磁盘块的大小为 4KB，也就是说，这十个直接指针能够表示最大 40KB 的文件，而当文件的大小大于 40KB 时，就需要用到间接指针。</span>    u_int f_indirect<span class="token punctuation">;</span> <span class="token comment">//f_indirect指向一个间接磁盘块，用来存储许多指针，这些指针指向文件内容的磁盘块。有点像二重指针？指针指向存储指针的磁盘块，这些指针才真正指向文件内容磁盘块。</span>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f_dir<span class="token punctuation">;</span>     <span class="token comment">// f_dir指向文件所属的文件目录</span>    u_char f_pad<span class="token punctuation">[</span>BY2FILE <span class="token operator">-</span> MAXNAMELEN <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> NDIRECT <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//f_pad则是为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/5957f2bb1dda8e8a3751b953392228b3/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/lab5-pic-3.png" alt="[lab5-file block]"></p><ul><li><p>上面是关于间接指针的理解，注意为了简化计算，我们不使用间接磁盘块的前十个指针。所以图中间接磁盘块里的指针是从10开始用的。</p></li><li><p>对于普通的文件，其指向的磁盘块存储着文件内容，而<strong>对于目录文件来说，其指向的磁盘块存储着该目录下各个文件对应的的文件控制块</strong>。当我们要查找某个文件时，首先从超级块中读取根目录的文件控制块，然后沿着目标路径，挨个查看当前目录所包含的文件是否与下一级目标文件同名，如此便能查找到最终的目标文件。</p></li></ul><p>接下来学习利用<strong>create_file</strong>创建一个文件</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;该函数传入一个目录文件的指针，在该目录下创建一个文件,并返回该创建好的文件的控制块的指针struct File *create_file(struct File *dirf) &#123;    struct File *dirblk;    int i, bno, found;    int nblk &#x3D; dirf-&gt;f_size &#x2F; BY2BLK; &#x2F;&#x2F;目录目前有多少个块，这些磁盘块存储着该目录下各个文件对应的的文件控制块    &#x2F;&#x2F; Your code here    &#x2F;&#x2F;接下来找目录里面可以放空闲的文件控制块的位置    &#x2F;&#x2F;分两种情况，第一种是目录的磁盘块里面还有位置可以放一个文件控制块    &#x2F;&#x2F;第二种是目录里面没有位置了，要使用bno &#x3D; make_link_block(dirf, nblk);分配一个新的BLK，在这个块里放文件控制块        &#x2F;&#x2F;这是第一种    for (i &#x3D; 0; i &lt; nblk; i++) &#123;        &#x2F;&#x2F;首先根据块的顺序号取得块号        if (i &lt; NDIRECT) &#123; &#x2F;&#x2F;如果这个块是直接的            bno &#x3D; dirf-&gt;f_direct[i];        &#125; else &#123; &#x2F;&#x2F;如果这个块是间接的            bno &#x3D; ((uint32_t *)(disk[dirf-&gt;f_indirect].data))[i];        &#125;        &#x2F;&#x2F;根据块号从disk里面取到目录块的内容，始终要记住目录快里面存储文件的控制块        dirblk &#x3D; (struct File *)(disk[bno].data);&#x2F;&#x2F;这里相当于把取出来的内容转化成数组了  相当于  Struct File dirblk[] &#x3D; .......，因为这里把取出来的内容转化成FIle*指针了        for (j &#x3D; 0; j &lt; FILE2BLK; j++) &#123; &#x2F;&#x2F;如果这些控制块里有没有用过的（判断标准是文件名为空），那么就找到了！返回它的地址            if (dirblk[j].f_name[0] &#x3D;&#x3D; &#39;\0&#39;) &#123;                 return &amp;dirblk[j];            &#125;        &#125;    &#125;&#x2F;&#x2F;找了半天没有找到，证明目录dirf里面所有块全都用完了，再分配一个空闲块里面存储文件控制块并返回这个文件控制块    &#x2F;&#x2F;分配一个新的到目录文件的控制块的nblk号位    bno &#x3D; make_link_block(dirf, nblk);    return (struct File *)disk[bno].data;&#125;&#x2F;&#x2F;调这个函数分配新的disk块，传一个目录文件控制块指针进来，我们要分一个新的disk块连接到dirf的nblk号位上int make_link_block(struct File *dirf, int nblk) &#123;    &#x2F;&#x2F;取一个新的type类型空闲块    int bno &#x3D; next_block(BLOCK_FILE);    &#x2F;&#x2F;链接到nblk号位    save_block_link(dirf, nblk, bno);    &#x2F;&#x2F;文件大小增加    dirf-&gt;f_size +&#x3D; BY2BLK;    &#x2F;&#x2F;返回新分配的的空闲块号    return bno;&#125;&#x2F;&#x2F;nextbno是个全局变量代表下一个空闲disk块，这个函数实际上就是在维护这个变量&#x2F;&#x2F;我们需要一个type类型的块，在这里取一个空闲块设置它的type，更新nextbno，返回空闲块号int next_block(int type) &#123;    disk[nextbno].type &#x3D; type;return nextbno++;&#125;void save_block_link(struct File *f, int nblk, int bno)&#123;    assert(nblk &lt; NINDIRECT); &#x2F;&#x2F; if not, file is too large !&#x2F;&#x2F;如果是直接块链接到直接块    if(nblk &lt; NDIRECT) &#123;        f-&gt;f_direct[nblk] &#x3D; bno;    &#125;    else &#123;&#x2F;&#x2F;不是的话连接到间接快        if(f-&gt;f_indirect &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果间接指针还没有分配给他分配一个            &#x2F;&#x2F; create new indirect block.            f-&gt;f_indirect &#x3D; next_block(BLOCK_INDEX);        &#125;        ((uint32_t *)(disk[f-&gt;f_indirect].data))[nblk] &#x3D; bno;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上内容都是fsformat.c里面的内容用于创建磁盘镜像真正使用的操作磁盘的函数在fs.c内</p><hr><p>下面是fs.c的内容</p><p>接下来学习磁盘块到内存映射的实现过程</p><p>首先是一些常用函数，怎么这么多啊？？？？？？？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;blockno转对应虚拟地址，其实就是加上基地址DISKMAPu_intdiskaddr(u_int blockno)&#123;    if (super &amp;&amp; blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;        user_panic(&quot;reading non-existent block %08x\n&quot;, blockno);    &#125;    return DISKMAP + (blockno * BY2BLK);&#125;&#x2F;&#x2F;这个函数检查块是否已经在内存里映射过了intmap_block(u_int blockno)&#123;    &#x2F;&#x2F; Step 1: Decide whether this block has already mapped to a page of physical memory.    &#x2F;&#x2F;如果已经映射过了就返回0    &#x2F;&#x2F;调用block_is_mapped(blockno)这个函数，如果映射过返回对应虚拟地址，没映射过返回0    if (block_is_mapped(blockno)) &#123;        return 0;    &#125;&#x2F;&#x2F;没有影射过那就系统调用 映射一下    return syscall_mem_alloc(0, diskaddr(blockno), PTE_V | PTE_R);&#x2F;&#x2F;第一个参数是envid，0的话代指当前进程&#125;&#x2F;&#x2F;该函数用于解除磁盘块和物理内存之间的映射关系，回收内存，注意要回收！就是接触映射的时候要把虚拟内存里面的内容回收到磁盘里。voidunmap_block(u_int blockno)&#123;    int r;    u_int addr;    &#x2F;&#x2F; 如果根本没有映射过就不用回收，直接返回    addr &#x3D; block_is_mapped(blockno);    if (addr &#x3D;&#x3D; 0) &#123;        return;    &#125;    &#x2F;&#x2F; 如果虚拟内存里填过东西要回收到磁盘里    if (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;        write_block(blockno); &#x2F;&#x2F;把va里面的东西回收进来    &#125;    r &#x3D; syscall_mem_unmap(0, addr);&#x2F;&#x2F;解除绑定    if (r &lt; 0) &#123;        user_panic(&quot;unmap_block failed&quot;);    &#125;    &#x2F;&#x2F; Step 4: validate result of this unmap operation.    user_assert(!block_is_mapped(blockno));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是一个调用更多的函数</p><ul><li><code>int dir_lookup(struct File *dir, char *name, struct File **file)</code>在目录文件中找到名叫name的文件，并在让*file指向他</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Try to find a file named &quot;name&quot; in dir.  If so, set *file to it.intdir_lookup(struct File *dir, char *name, struct File **file)&#123;int r;u_int i, j, nblock;void *blk;struct File *f;&#x2F;&#x2F; Step 1: Calculate nblock: how many blocks this dir have.nblock &#x3D; ROUND(dir-&gt;f_size, BY2BLK) &#x2F; BY2BLK;for (i &#x3D; 0; i &lt; nblock; i++) &#123;&#x2F;&#x2F; Step 2: Read the i&#39;th block of the dir.&#x2F;&#x2F; Hint: Use file_get_block.调用下面这个函数得到f的filebno个块对应的内存中的虚拟地址（这个函数附带的作用是保证把这个块读到内存映射里面，接下来我们就可以在内存中操作磁盘数据映射）r &#x3D; file_get_block(dir, i, &amp;blk);&#x2F;&#x2F;这个blk是对应的虚拟地址if (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 3: Find target file by file name in all files on this block.&#x2F;&#x2F; If we find the target file, set the result to *file and set f_dir field.        &#x2F;&#x2F;得到blk这个虚拟地址就可以开始指针操作了        &#x2F;&#x2F;FILE2BLK是一个宏，指一个块里面有多少file结构体for (j &#x3D; 0; j &lt; FILE2BLK; j++) &#123;f &#x3D; ((struct File *)blk) + j; &#x2F;&#x2F;把目录磁盘块里file结构体挨个取出来            &#x2F;&#x2F;注意这时我们已经开始在内存映射中操作了，现在是在内存中if (strcmp((char *)f-&gt;f_name, name) &#x3D;&#x3D; 0) &#123;f-&gt;f_dir &#x3D; dir;*file &#x3D; f;return 0;&#125;&#125;&#125;return -E_NOT_FOUND;&#125;&#x2F;&#x2F;这个函数用于得到f的第filebno个块的块号，并保证把这块读进内存里，blk返回该快对应的虚拟地址&#x2F;&#x2F; Overview:&#x2F;&#x2F;Set *blk to point at the filebno&#39;th block in file f.intfile_get_block(struct File *f, u_int filebno, void **blk)&#123;int r;u_int diskbno;u_int isnew;&#x2F;&#x2F; Step 1: find the disk block number is &#96;f&#96; using &#96;file_map_block&#96;.if ((r &#x3D; file_map_block(f, filebno, &amp;diskbno, 1)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: read the dataif ((r &#x3D; read_block(diskbno, blk, &amp;isnew)) &lt; 0) &#123;return r;&#125;return 0;&#125;&#x2F;&#x2F;将blockno读到对应的内存映射里，在blk里面返回其在内存中的虚拟地址，注意这里是虚拟地址！！！intread_block(u_int blockno, void **blk, u_int *isnew)&#123;u_int va;&#x2F;&#x2F;两个异常情况    &#x2F;&#x2F; 1 超出范围if (super &amp;&amp; blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;user_panic(&quot;reading non-existent block %08x\n&quot;, blockno);&#125;&#x2F;&#x2F; 2 空闲块怎么读？ you are crazy！if (bitmap &amp;&amp; block_is_free(blockno)) &#123;user_panic(&quot;reading free block %08x\n&quot;, blockno);&#125;&#x2F;&#x2F; 虚拟地址找出来va &#x3D; diskaddr(blockno);&#x2F;&#x2F; Step 4: read disk and set *isnew.&#x2F;&#x2F; Hint: if this block is already mapped, just set *isnew, else alloc memory and&#x2F;&#x2F; read data from IDE disk (use &#96;syscall_mem_alloc&#96; and &#96;ide_read&#96;).&#x2F;&#x2F; We have only one IDE disk, so the diskno of ide_read should be 0.    &#x2F;&#x2F;如果没有map过map一下if (block_is_mapped(blockno)) &#123;&#x2F;&#x2F;the block is in memoryif (isnew) &#123;*isnew &#x3D; 0;&#125;&#125; else &#123;&#x2F;&#x2F;the block is not in memoryif (isnew) &#123;*isnew &#x3D; 1;&#125;syscall_mem_alloc(0, va, PTE_V | PTE_R);ide_read(0, blockno * SECT2BLK, (void *)va, SECT2BLK);&#125;&#x2F;&#x2F; Step 5: if blk !&#x3D; NULL, set &#96;va&#96; to *blk.这里是虚拟地址！！if (blk) &#123;*blk &#x3D; (void *)va;&#125;return 0;&#125;&#x2F;&#x2F;这个函数先用file_block_walk找到了f第filebno个块对应的块号，然后做了一些简单额外操作，就是这个块号如果是0的话证明还没有分配，给他分配一下并记录到f的控制块内，*diskbno存储这个块号&#x2F;&#x2F; OVerview:&#x2F;&#x2F;Set *diskbno to the disk block number for the filebno&#39;th block in file f.&#x2F;&#x2F; If alloc is set and the block does not exist, allocate it.intfile_map_block(struct File *f, u_int filebno, u_int *diskbno, u_int alloc)&#123;int r;u_int *ptr;&#x2F;&#x2F; Step 1: find the pointer for the target block.if ((r &#x3D; file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: if the block not exists, and create is set, alloc one.if (*ptr &#x3D;&#x3D; 0) &#123;if (alloc &#x3D;&#x3D; 0) &#123;return -E_NOT_FOUND;&#125;if ((r &#x3D; alloc_block()) &lt; 0) &#123;return r;&#125;*ptr &#x3D; r;&#125;&#x2F;&#x2F; Step 3: set the pointer to the block in *diskbno and return 0.*diskbno &#x3D; *ptr;return 0;&#125;&#x2F;&#x2F;这个函数用于找到f的第filebno个块的块号，在**ppdiskno里存储这个块号，这个块号有可能是0，因为还没有分配，注意如果alloc还要有特殊操作this function will allocate an indirect block if necessary.&#x2F;&#x2F; Overview:&#x2F;&#x2F;Like pgdir_walk but for files. &#x2F;&#x2F;Find the disk block number slot for the &#39;filebno&#39;th block in file &#39;f&#39;. Then, set &#x2F;&#x2F;&#39;*ppdiskbno&#39; to point to that slot. The slot will be one of the f-&gt;f_direct[] entries,&#x2F;&#x2F; or an entry in the indirect block.&#x2F;&#x2F; When &#39;alloc&#39; is set, this function will allocate an indirect block if necessary.intfile_block_walk(struct File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)&#123;int r;u_int *ptr;void *blk;if (filebno &lt; NDIRECT) &#123;&#x2F;&#x2F; Step 1: if the target block is corresponded to a direct pointer, just return the&#x2F;&#x2F; disk block number.ptr &#x3D; &amp;f-&gt;f_direct[filebno];&#125; else if (filebno &lt; NINDIRECT) &#123;&#x2F;&#x2F; Step 2: if the target block is corresponded to the indirect block, but there&#39;s no&#x2F;&#x2F;indirect block and &#96;alloc&#96; is set, create the indirect block.if (f-&gt;f_indirect &#x3D;&#x3D; 0) &#123;if (alloc &#x3D;&#x3D; 0) &#123;return -E_NOT_FOUND;&#125;if ((r &#x3D; alloc_block()) &lt; 0) &#123;return r;&#125;f-&gt;f_indirect &#x3D; r;&#125;&#x2F;&#x2F; Step 3: read the new indirect block to memory. if ((r &#x3D; read_block(f-&gt;f_indirect, &amp;blk, 0)) &lt; 0) &#123;return r;&#125;ptr &#x3D; (u_int *)blk + filebno;&#125; else &#123;return -E_INVAL;&#125;&#x2F;&#x2F; Step 4: store the result into *ppdiskbno, and return 0.*ppdiskbno &#x3D; ptr;return 0;&#125;&#x2F;&#x2F;这个函数用于在位图中找一个空闲块返回其块号intalloc_block_num(void)&#123;int blockno;&#x2F;&#x2F; walk through this bitmap, find a free one and mark it as used, then sync&#x2F;&#x2F; this block to IDE disk (using &#96;write_block&#96;) from memory.for (blockno &#x3D; 3; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;if (bitmap[blockno &#x2F; 32] &amp; (1 &lt;&lt; (blockno % 32))) &#123;&#x2F;&#x2F;the block is freebitmap[blockno &#x2F; 32] &amp;&#x3D; ~(1 &lt;&lt; (blockno % 32));&#x2F;&#x2F;这里把空闲位取消掉            &#x2F;&#x2F;下面这句话纯纯有病，直接把2块写回disk不就行了，加个blockno &#x2F; BIT2BLK有个卵用？write_block(blockno &#x2F; BIT2BLK + 2); &#x2F;&#x2F; write 2块即bitmap块 to disk.return blockno;&#125;&#125;&#x2F;&#x2F; no free blocks.return -E_NO_DISK;&#125;&#x2F;&#x2F;分配一个块并把它map到虚拟空间里去intalloc_block(void)&#123;int r, bno;&#x2F;&#x2F; Step 1: find a free block.找到空闲块调用上面那个函数if ((r &#x3D; alloc_block_num()) &lt; 0) &#123; &#x2F;&#x2F; failed.return r;&#125;bno &#x3D; r;&#x2F;&#x2F; Step 2: map this block into memory. if ((r &#x3D; map_block(bno)) &lt; 0) &#123; &#x2F;&#x2F;map这个块free_block(bno);&#x2F;&#x2F;map不成功的话把它free掉，因为alloc_block_num()函数里把它的空闲位取消掉了return r;&#125;&#x2F;&#x2F; Step 3: return block number.return bno;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接下来将这些函数进一步封装为我们常用的open-write，close的等函数"><a href="#接下来将这些函数进一步封装为我们常用的open-write，close的等函数" class="headerlink" title="接下来将这些函数进一步封装为我们常用的open,write，close的等函数"></a>接下来将这些函数进一步封装为我们常用的open,write，close的等函数</h4><p>首先又来了三个结构体</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; Device struct:&#x2F;&#x2F; It is used to read and write data from corresponding device.&#x2F;&#x2F; We can use the five functions to handle data.&#x2F;&#x2F; There are three devices in this OS: file, console and pipe.struct Dev &#123;    int dev_id;    char *dev_name;    int (*dev_read)(struct Fd *, void *, u_int, u_int);    int (*dev_write)(struct Fd *, const void *, u_int, u_int);    int (*dev_close)(struct Fd *);    int (*dev_stat)(struct Fd *, struct Stat *);    int (*dev_seek)(struct Fd *, u_int);&#125;;&#x2F;&#x2F; file descriptorstruct Fd &#123;    u_int fd_dev_id;&#x2F;&#x2F;外设id    u_int fd_offset;&#x2F;&#x2F;读或写的当前位置    u_int fd_omode;&#x2F;&#x2F;打开方式&#125;;&#x2F;&#x2F; Statestruct Stat &#123;    char st_name[MAXNAMELEN];    u_int st_size;    u_int st_isdir;    struct Dev *st_dev;&#125;;&#x2F;&#x2F; file descriptor + filestruct Filefd &#123;    struct Fd f_fd;    u_int f_fileid;    struct File f_file;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是open函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intopen(const char *path, int mode)&#123;struct Fd *fd;struct Filefd *ffd;u_int size, fileid;int r;u_int va;u_int i;&#x2F;&#x2F; Step 1: Alloc a new Fd, return error code when fail to alloc.&#x2F;&#x2F; Hint: Please use fd_alloc.&#x2F;&#x2F;先来一个fd，用fd——allocr &#x3D; fd_alloc(&amp;fd); &#x2F;&#x2F; this is a whole 4KB spaceif (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: Get the file descriptor of the file to open.&#x2F;&#x2F; Hint: Read fsipc.c, and choose a function.    &#x2F;&#x2F;利用进程通信要求文件系统进程将文件的相关信息写入fd空间中r &#x3D; fsipc_open(path, mode, fd);if (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 3: Set the start address storing the file&#39;s content. Set size and fileid correctly.&#x2F;&#x2F; Hint: Use fd2data to get the start address.    &#x2F;&#x2F;有了fd，强转一下就是ffd，ffd有文件id，文件size信息，map的时候需要文件id信息。ffd &#x3D; (struct Filefd *)fd;va &#x3D; fd2data(fd);&#x2F;&#x2F;这个va就是文件放内容的地方，利用fd2data函数fileid &#x3D; ffd-&gt;f_fileid;size &#x3D; ffd-&gt;f_file.f_size;&#x2F;&#x2F; Step 4: Alloc memory, map the file content into memory.    &#x2F;&#x2F;map一下for (i &#x3D; 0; i &lt; size; i +&#x3D; BY2BLK) &#123;r &#x3D; fsipc_map(fileid, i, va + i);if (r &lt; 0) &#123;return r;&#125;&#125;&#x2F;&#x2F; Step 5: Return the number of file descriptor.return fd2num(fd); &#x2F;&#x2F;返回文件描述符的编号&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是write和read函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intwrite(int fdnum, const void *buf, u_int n)&#123;int r;struct Dev *dev;struct Fd *fd;&#x2F;&#x2F;利用lookup函数找到对应的fd和devif ((r &#x3D; fd_lookup(fdnum, &amp;fd)) &lt; 0||  (r &#x3D; dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F;不能写的话报错if ((fd-&gt;fd_omode &amp; O_ACCMODE) &#x3D;&#x3D; O_RDONLY) &#123;writef(&quot;[%08x] write %d -- bad mode\n&quot;, env-&gt;env_id, fdnum);return -E_INVAL;&#125;&#x2F;&#x2F;这个不用管if (debug) writef(&quot;write %d %p %d via dev %s\n&quot;,  fdnum, buf, n, dev-&gt;dev_name);&#x2F;&#x2F;利用dev内的函数指针把buf内容写入文件，注意这里要传入fd内的文件offsetr &#x3D; (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);    &#x2F;&#x2F;更新fd内的offsetif (r &gt; 0) &#123;fd-&gt;fd_offset +&#x3D; r;&#125;return r;&#125;&#x2F;&#x2F;跟write一模一样，调用的dev的函数不一样intread(int fdnum, void *buf, u_int n)&#123;int r;struct Dev *dev;struct Fd *fd;&#x2F;&#x2F; Similar to &#39;write&#39; function.&#x2F;&#x2F; Step 1: Get fd and dev.    &#x2F;&#x2F;跟write函数一样，先得把fd和dev读出来if ((r &#x3D; fd_lookup(fdnum, &amp;fd)) &lt; 0||  (r &#x3D; dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: Check open mode.    &#x2F;&#x2F;只能写的话就不能读if ((fd-&gt;fd_omode &amp; O_ACCMODE) &#x3D;&#x3D; O_WRONLY) &#123;writef(&quot;[%08x] read %d -- bad mode\n&quot;, env-&gt;env_id, fdnum);return -E_INVAL;&#125;if (debug) writef(&quot;read %d %p %d via dev %s\n&quot;,  fdnum, buf, n, dev-&gt;dev_name);&#x2F;&#x2F; Step 3: Read starting from seek position.r &#x3D; (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);&#x2F;&#x2F; Step 4: Update seek position and set &#39;\0&#39; at the end of buf.if (r &gt; 0) &#123;fd-&gt;fd_offset +&#x3D; r;&#125;((char *)buf)[r] &#x3D; &#39;\0&#39;;return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是我们的重点理解之处，那就是其实我们的文件系统实际上是通过进程通信实现的，我们使用fs.c(filesystem)中的一系列进程通信函数来告知文件系统进程如何操作文件实验中以remove操作展现了进程通信实现文件操作是如何实现的。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;进程调用这个封装好的接口删除文件，实际上就是执行一个系统调用intremove(const char *path)&#123;&#x2F;&#x2F; Your code here.&#x2F;&#x2F; Call fsipc_remove.return fsipc_remove(path);&#125;&#x2F;&#x2F;这就是那个系统调用告诉文件系统进程要删除文件intfsipc_remove(const char *path)&#123;struct Fsreq_remove *req; &#x2F;&#x2F;每一个操作都有一个专门的结构体声明    &#x2F;&#x2F; Step 1: Check the length of path, decide if the path is valid.if (strlen(path) &gt;&#x3D; MAXPATHLEN) &#123;return -E_BAD_PATH;&#125;&#x2F;&#x2F; Step 2: Transform fsipcbuf to struct Fsreq_remove*        &#x2F;&#x2F;有一个专门的fsipcbuf缓冲区用于存放req，使用时要将其强制转换对应类型的请求req &#x3D; (struct Fsreq_remove *)fsipcbuf;        &#x2F;&#x2F;放一些信息进去&#x2F;&#x2F; Step 3: Copy path to path in req.strcpy((char *)req-&gt;req_path, path);    &#x2F;&#x2F;掉fsipc传入参数，第一个参数是操作类型&#x2F;&#x2F; Step 4: Send request to fs server with IPC.return fsipc(FSREQ_REMOVE, req, 0, 0);&#125;&#x2F;&#x2F;文件系统进程接收到删除文件的req就执行这个函数，底层实际上是执行了一个file_remove(path);函数voidserve_remove(u_int envid, struct Fsreq_remove *rq)&#123;int r;char path[MAXPATHLEN];&#x2F;&#x2F; Step 1: Copy in the path, making sure it&#39;s terminated.&#x2F;&#x2F; Notice: add \0 to the tail of the pathstrcpy(path, (char *)rq-&gt;req_path);&#x2F;&#x2F; Step 2: Remove file from file system and response to user-level process.&#x2F;&#x2F; Call file_remove and ipc_send an approprite value to corresponding env.r &#x3D; file_remove(path);ipc_send(envid, r, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 C++课程大作业—Fake_FileSystem 代码分析报告</title>
      <link href="/2022/06/20/fake-filesystem-dai-ma-fen-xi-bao-gao/"/>
      <url>/2022/06/20/fake-filesystem-dai-ma-fen-xi-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="C-课程大作业——Fake-FileSystem-代码分析报告"><a href="#C-课程大作业——Fake-FileSystem-代码分析报告" class="headerlink" title="C++课程大作业——Fake_FileSystem 代码分析报告"></a>C++课程大作业——Fake_FileSystem 代码分析报告</h2><h2 id="label-前言"><a href="#label-前言" class="headerlink" title=":label: 前言"></a>:label: 前言</h2><p>文件系统的内容是本学习我的一门核心专业课操作系统中，重点学习的理论知识，我也在操作系统课下实验中利用C和Linux实现过一个简单的文件系统。在翻阅<code>Github</code>上面的源码时，我发现了这一有趣的项目Fake_FileSystem ，其利用<code>cpp</code>的架构实现了一个伪文件系统，逻辑清晰，涉及了许多cpp的oop知识例如封装，继承，多态，构造，解析，重载，虚函数，工厂模式等等知识，是一个不错的学习模板和范例，因此本次作业选用这个源码来作分析和学习。</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220620160922473.png" alt="image-20220620160922473"></p><p>可以看到虽然Fake_FileSystem 的star星数不多，这可能是因为其里面的内容<strong>涉及到许多操作系统有关的知识</strong>，比如数据块，Block0引导块，FAT文件分配表，FCB文件控制块，等等这些文件系统的底层知识可能为没有学习过操作系统的读者带来一定的难度。总而言之，幸运的是本学期我刚刚学过操作系统，所以勉强有了阅读这份代码的“资格”。</p><p><code>Fake_Sysytem</code>大体的逻辑就是用<code>Cpp+面向对象</code>的思想，实现了包括文件系统底层涉及到的Block0（文件系统引导块）、FAT（文件分配表）、File（文件）、Document（目录）、UserOpen（打开文件表）等一系列基本类，<strong>FileSystem这一核心文件系统类</strong>、CommandFactory这一工厂模式的命令行类（内部实现了多种文件系统操作命令），和最终与用户进行交互的Bash（终端）类。</p><ul><li>实现的主要命令如下</li></ul><p>可以看到由于是一个简单的伪文件系统，不能实现所有操作系统中文件系统的功能，但一些常见的文件操作功能可以很好地实现，比如目录操作：mkdir,rmdir,cd,ls;文件操作:create,open,close,write,rm等;</p><table><thead><tr><th>命令名</th><th>参数1</th><th>参数2</th></tr></thead><tbody><tr><td><code>mkdir</code></td><td>绝对路径</td><td></td></tr><tr><td><code>rmdir</code></td><td>绝对路径</td><td></td></tr><tr><td><code>cd</code></td><td>绝对路径</td><td></td></tr><tr><td><code>ls</code></td><td></td><td></td></tr><tr><td><code>create</code></td><td>绝对路径</td><td></td></tr><tr><td><code>open</code></td><td>绝对路径</td><td></td></tr><tr><td><code>write</code></td><td>-c -co -a</td><td>标识符（open返回）</td></tr><tr><td><code>close</code></td><td>标识符</td><td></td></tr><tr><td><code>rm</code></td><td>绝对路径</td><td></td></tr><tr><td><code>save</code></td><td></td><td></td></tr></tbody></table><p>👉源代码请您移步这里：<a href="https://github.com/laCorse/Lacorse_Fake_Filesystem">Fake_FileSystem</a></p><h2 id="label-1-1-整体架构"><a href="#label-1-1-整体架构" class="headerlink" title=":label: 1.1 整体架构"></a>:label: 1.1 整体架构</h2><p>首先先放一张整体架构的类图，接下来进行分析。</p><p><img src="https://note.youdao.com/yws/api/personal/file/8BF122BE36974C4C8A1839D745F7ABAD?method=download&shareKey=9f278f414fe0a6f80cca2155d39a20d2" alt="image-20220620180616138"></p><p>可以看到整个架构被明显的分为了三个部分，其实这便是伪文件系统的三个组成部分。</p><ul><li>左边是命令工厂，其中与Bash终端直接交互的是CommandFactory命令工厂，采用工厂模式，在类内部自己决定使用哪种工厂命令，这些工厂命令包括ls，exit，open，close等等，这些工厂命令<strong>继承</strong>一个共同的基类CommandBase实现多态，之后会在1.2中详细讲到。</li><li>右边是伪文件系统，这一部分基本都与操作系统的理论知识相关，包括记录打开文件的UserOpen（打开文件表），记录数据块分配情况的FAT（文件分配表），初始化磁盘的引导块Block0等。其中FileSystem是最终实现的核心类，这个类与Bash终端进行交互。</li><li>最下边是Bash类，<strong>main.cpp运行这个类中的Run函数</strong>，开始运行整个文件系统，Bash类“类如其名”，就是终端的意思。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/7B0EE40946274D2A92198871E496D3D1?method=download&shareKey=b3584f8b400d4ac0dc4bb7479a6338a0" alt="2"></p><p>最后，我们将整个文件系统运行逻辑简化如下，可以更加清晰的理解。</p><p><img src="https://note.youdao.com/yws/api/personal/file/47E8D7DF35AE4AD18E58FC42F45F0A88?method=download&shareKey=ed65bdafd5177f124644ca43d7155118" alt="image-20220620184310512"></p><h2 id="label-1-2-细节分析"><a href="#label-1-2-细节分析" class="headerlink" title=":label: 1.2 细节分析"></a>:label: 1.2 细节分析</h2><p>接下来我们将运用课上所学的各种知识来分析代码中的<strong>封装，多态，继承，构造，析构，拷贝构造，重载，重写等等知识点</strong>，主要结合代码片段来分析。</p><h3 id="1-2-1-封装性"><a href="#1-2-1-封装性" class="headerlink" title="1.2.1 封装性"></a>1.2.1 封装性</h3><p>封装性几乎在该项目中处处都能得到体现，因为本项目毕竟是一个面向对象逻辑的项目，肯定处处都透露着封装性这一面向对象的基本思想。我就以整体架构中的<strong>伪文件系统</strong>这一部分来阐述封装性在代码中的体现。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;Filesystem核心类节选&#x2F;** * @class 核心文件系统  *&#x2F;class Filesystem &#123;private:    &#x2F;&#x2F;!是否已经初始化    bool initialized_;    &#x2F;&#x2F;!文件块的起始地址,分配SIZE(1024000字节)大小的空间给该指针(存储也利用该指针)。    char *ptrToContent;    &#x2F;&#x2F;!分别指向各个块地址，第一块为引导块，2~3块为FAT1,4~5为FAT2，剩余995块为数据区。    char *blocks[BLOCKNUM];    &#x2F;&#x2F;!打开的文件列表    Useropen *openFiles[MAXOPENFILE];    int fd &#x3D; 0;    &#x2F;&#x2F;!引导块,托管blocks[0]    BLOCK0 *pblock0;    &#x2F;&#x2F;!FAT1&#x2F;2    Fat *pfat1;    Fat *pfat2;    &#x2F;&#x2F;!root dir    Document *proot;    Document *plastdir;    &#x2F;&#x2F;!保存当前目录的信息    currentData currentData;public:    Document() &#123;&#125;;    Document(char *block)    &#123;        pos &#x3D; block;        constexpr int size &#x3D; BLOCKSIZE&#x2F;sizeof(Fcb);        for(int i&#x3D;0;i&lt;size;i++)        &#123;            char *tmp &#x3D; pos+i*sizeof(Fcb);            Fcb * tmpFcb &#x3D; (Fcb *)tmp;            &#x2F;&#x2F;memcpy(&amp;tmpFcb,tmp,sizeof(Fcb));            if (tmpFcb-&gt;free &#x3D;&#x3D; 1)            &#123;                fcbList.push_back(*tmpFcb);            &#125;        &#125;    &#125;;&#125;;&#x2F;&#x2F;..............................................................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是Filesystem核心类代码的节选，可以看到内部有private的私有成员，和一部分public的方法，这些成员的私有化便很好的体现了封装性，我认为其作用有以下2点。</p><ul><li><strong>隐藏实现细节，提供公共的访问方式</strong>：<strong>使用面向对象封装性可以很好的实现文件系统的“隐藏细节”这一思想</strong>。在实际的文件系统中，它对程序员隐藏实现细节，程序员在日常工作时感受不到他的存在，但文件系统默默的在幕后为我们“当牛做马”，此外程序员在使用文件系统时可以执行一些文件系统提供的、封装好的系统调用接口来间接实现操作系统的功能。而在这里我们实现的的“伪文件系统”Filesystem便利用封装性模拟了这一点，我们将一些功能封装到Filesystem中，而不需要知道类中的这个方法的逻辑原理，文件系统Filesystem只需要给User一个对外的接口，User只需要能够调用这个方法就可以实现文件系统的操作，同时User也无法对FileSystem内部的成员进行直接更改。</li><li><strong>提高安全性</strong>：文件系统本身就是一个安全性很高的系统，我们程序员一般不能对操作系统内核进行随意的修改，否则我们的电脑系统就“乱了套”。<strong>封装性也很好的提供了安全性</strong>，我们不能对Filesystem类内部的成员变量进行随意的修改，只能通过调用Filesystem内的public方法，而这些方法由于是Filesystem自己提供的，所以保证文件系统是安全的。</li></ul><h3 id="1-2-2-继承性和多态性"><a href="#1-2-2-继承性和多态性" class="headerlink" title="1.2.2 继承性和多态性"></a>1.2.2 继承性和多态性</h3><p>继承性和多态性主要在命令工厂这一部分得到实现。接下来节选了命令工厂中的命令基类，和继承他的几个命令类。这里命令子类可以继承符类的参数parameter属性，和fakeFs文件系统的智能指针。</p><p>同时命令子类中，也重写了Execute()方法，以实现对应的命令执行方法，多态性使命令子类可以表现出不同的Execute()行为，这里我们注意到<strong>使用了虚函数进行了方法重写</strong>，这里的原因我们之后在1.2.5中会讲到。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;基类class CommandBase&#123;protected:    vector&lt;string&gt; parameter;    shared_ptr&lt;Filesystem&gt; fakeFs;public:    CommandBase(vector&lt;string&gt; cmdPara,shared_ptr&lt;Filesystem&gt; fs):parameter(cmdPara),fakeFs(fs)    &#123;&#125;    virtual void Execute()&#x3D;0;  &#x2F;&#x2F;这里用了虚函数！！！！！！！！！！！！！！！！！！    virtual ~CommandBase()&#123;&#125;;    &#x2F;**     * @brief 在指定目录下创建文件     * @param filename 名字     * @param attribute 指定文件类型是文件还是目录     * @return     *&#x2F;    int touch(string &amp; filename, int attribute);    &#x2F;**     * @brief 打开一个文件并读入到当前打开文件中,并分配一个openfilelist的下标作为描述符     *&#x2F;    int open(string &amp; filename);&#125;;&#x2F;&#x2F;命令子类继承基类CommandBase&#x2F;&#x2F;mkdir命令class Mkdir :public CommandBase&#123;public:    Mkdir(vector&lt;string&gt; cmdPara,shared_ptr&lt;Filesystem&gt; fs):CommandBase(cmdPara, fs)    &#123;&#125;    virtual void Execute();&#125;;&#x2F;&#x2F;cd 命令class Cd :public CommandBase&#123;public:    Cd(vector&lt;string&gt; cmdPara,shared_ptr&lt;Filesystem&gt; fs):CommandBase(cmdPara, fs)    &#123;&#125;    virtual void Execute();&#125;;&#x2F;&#x2F;.............................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-运算符重载"><a href="#1-2-3-运算符重载" class="headerlink" title="1.2.3 运算符重载"></a>1.2.3 运算符重载</h3><p>运算符重载也在很多地方得到了体现，这里节选FAT类里的一处。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;FAT文件分配表代码节选class Fat&#123;        typedef unsigned short Filelist;public:    Filelist filelist[BLOCKNUM];    char * postion;    &#x2F;**     * @brief 重载了下[]，便于直接访问     * @param id     * @return     *&#x2F;    unsigned short&amp; operator[](int id)    &#123;        return filelist[id];    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们访问FAT文件分配表其实是访问其内部的<code>filelist</code>这一数组成员。如果不进行运算符重载，我们还需要编写对应的方法进行访问，比较麻烦。进行运算符重载之后可以直接<code>FAT[i]</code>进行访问，十分方便。</p><h3 id="1-2-4-虚函数实现重写"><a href="#1-2-4-虚函数实现重写" class="headerlink" title="1.2.4 虚函数实现重写"></a>1.2.4 虚函数实现重写</h3><p>指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。这点在命令基类CommandBase和他的许多命令子类中的Execute()虚函数中得到很好地体现。</p><p>为什么要用虚函数进行实现呢？首先因为Bash调用命令工厂解析命令后，返回的是指向命令子类的父类指针（CommandBase*）。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class CommandFactory&#123;public:    unique_ptr&lt;CommandBase&gt; SmartCreateCmd(string command,vector&lt;string&gt; parameter,shared_ptr&lt;Filesystem&gt; fs)    &#123;        if (command &#x3D;&#x3D; &quot;mkdir&quot;)            return unique_ptr&lt;CommandBase&gt;(new Mkdir(parameter,fs)); &#x2F;&#x2F;返回的是指向命令子类的父类CommandBase指针        else if(command &#x3D;&#x3D; &quot;rmdir&quot;)            return unique_ptr&lt;CommandBase&gt;(new Rmdir(parameter,fs));        else if(command &#x3D;&#x3D; &quot;cd&quot;)            return unique_ptr&lt;CommandBase&gt;(new Cd(parameter,fs));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而我们在执行命令时<code>cmd -&gt; Execute()</code>采用的是指针来调用函数，这时必须要求我们在命令类中将Execute()函数定义为虚函数来实现多态，这样才能保证<code>cmd -&gt; Execute()</code>执行的是子类重写好的Execute函数，而不是父类中的。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void LacorseBash::Run()&#123;    alwaysTrue &#x3D; true;    while (alwaysTrue)    &#123;        Show();        Read();        &#x2F;&#x2F;执行        cmd -&gt; Execute(); &#x2F;&#x2F;cmd是解析好的父类CommandBase指针，但他指向对应的命令子类,这时必须要求我们在命令类中将Execute（）函数定义为虚函数,否则执行的是父类的Execute（）    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-5-拷贝构造"><a href="#1-2-5-拷贝构造" class="headerlink" title="1.2.5 拷贝构造"></a>1.2.5 拷贝构造</h3><p>拷贝构造在Document文件目录类中有很好的体现。在我们对目录文件进行拷贝构造时，由于功能实现要求，我们希望只将需要拷贝的Document类中的Free的FCB块进行拷贝。这需要我们重写拷贝构造函数如下。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Document &#123;&#x2F;&#x2F;节选vector&lt;Fcb&gt; fcbList;char *pos;    Document(Document &amp; doc)    &#123;        doc.save();        pos &#x3D; doc.pos;        constexpr int size &#x3D; BLOCKSIZE&#x2F;sizeof(Fcb);        for(int i&#x3D;0;i&lt;size;i++)        &#123;            char *tmp &#x3D; pos+i*sizeof(Fcb);            Fcb * tmpFcb &#x3D; (Fcb *)tmp;            if (tmpFcb-&gt;free &#x3D;&#x3D; 1)            &#123;                fcbList.push_back(*tmpFcb);&#x2F;&#x2F;只拷贝Free的FCB文件控制块，其他的跳过！            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-6-析构函数"><a href="#1-2-6-析构函数" class="headerlink" title="1.2.6 析构函数"></a>1.2.6 析构函数</h3><p>析构函数很多类中都有写到。这里主要以文件系统类Filesystem的析构函数为例进行介绍。这里重写析构函数的原因有两个：</p><ul><li>Filesystem内部有许多成员变量也分配了内存，这些内存在Filesystem被销毁后不会自动释放，所以非常有必要再添加一个析构函数，专门用来释放已经分配的内存。</li><li>同时我们实现的伪文件系统额外实现了一个功能，就是<strong>将系统运行结束后文件系统Filesystem中的内容记录到文件中</strong>，作为最终的输出记录结果，这也要求我们在析构Filesystem前实现这一功能。</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">~Filesystem()&#123; &#x2F;&#x2F;析构函数    SaveFileSys();&#x2F;&#x2F;系统运行结束后文件系统Filesystem中的内容记录到文件中    &#x2F;&#x2F;释放成员内存    delete pblock0;    delete pfat1;    delete pfat2;    delete proot;    delete []ptrToContent;&#125;void Filesystem::SaveFileSys()&#123;    ofstream outFile(&quot;.&#x2F;lacorse_Fs_bak1.dat&quot;, ios::out | ios::binary);    outFile.write(ptrToContent, SIZE);    outFile.close();    cout &lt;&lt; &quot;[Save]Save File System succeed!&quot; &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-7-工厂模式"><a href="#1-2-7-工厂模式" class="headerlink" title="1.2.7 工厂模式"></a>1.2.7 工厂模式</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class CommandFactory&#123;public:    unique_ptr&lt;CommandBase&gt; SmartCreateCmd(string command,vector&lt;string&gt; parameter,shared_ptr&lt;Filesystem&gt; fs)    &#123;        if (command &#x3D;&#x3D; &quot;mkdir&quot;)            return unique_ptr&lt;CommandBase&gt;(new Mkdir(parameter,fs));        else if(command &#x3D;&#x3D; &quot;rmdir&quot;)            return unique_ptr&lt;CommandBase&gt;(new Rmdir(parameter,fs));        else if(command &#x3D;&#x3D; &quot;cd&quot;)            return unique_ptr&lt;CommandBase&gt;(new Cd(parameter,fs));        else if(command &#x3D;&#x3D; &quot;ls&quot;)            return unique_ptr&lt;CommandBase&gt;(new Ls(parameter,fs));        else if(command &#x3D;&#x3D; &quot;create&quot;)            return unique_ptr&lt;CommandBase&gt;(new Create(parameter,fs));        else if(command &#x3D;&#x3D; &quot;rm&quot;)            return unique_ptr&lt;CommandBase&gt;(new Rm(parameter,fs));        else if(command &#x3D;&#x3D; &quot;open&quot;)            return unique_ptr&lt;CommandBase&gt;(new Open(parameter,fs));        else if(command &#x3D;&#x3D; &quot;close&quot;)            return unique_ptr&lt;CommandBase&gt;(new Close(parameter,fs));        else if(command &#x3D;&#x3D; &quot;write&quot;)            return unique_ptr&lt;CommandBase&gt;(new Write(parameter,fs));        else if(command &#x3D;&#x3D; &quot;save&quot;)            return unique_ptr&lt;CommandBase&gt;(new Exit(parameter,fs));        else            return unique_ptr&lt;CommandBase&gt;(new Empty(parameter,fs));    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工厂模式在命令工厂里也得到了很好的体现。<strong>工厂方法模式一种创建对象的模式,应用在超类和多个子类之间的情况，这种模式将创建对象的责任转移到工厂类</strong>。这里我们的工厂类就是CommandFactory，Bash中端调用CommandFactory类解析命令，并<strong>把创建对应命令子类（Mkdir，Rmdir，Cd等）的任务交给了工厂类</strong>。可以看到我们在CommandFactory类中利用if-else语句逻辑解析对应命令，并创建对应的命令子类。</p><p>这是工厂模式的体现，好处是通过工厂模式，我们把对象创建的具体逻辑给隐藏起来了，交给工厂统一管理，这样不仅减少了代码量，以后如果想改代码的话，只需要改一处即可，也方便我们日常的维护。</p><h2 id="label-1-3-总结"><a href="#label-1-3-总结" class="headerlink" title=":label: 1.3 总结"></a>:label: 1.3 总结</h2><p>最后对这一学期的课程和本次作业做一个总结。对于本次作业而言，在阅读代码的过程中我复习了许多课上的知识，封装继承多态，拷贝构造函数，重写重载，析构构造等等知识点，也体会到了工厂模式带来的解耦，利于维护等优点。总而言之，这个Fake_FileSystem项目利用了许多cpp面向对象的基本思想，自底向上很好的实现了文件系统的一些功能，不仅模拟了文件系统底层的实现，还封装了上层对应的命令接口，二者通过Bash终端进行交互，架构和实现都很完美，是一份不错的学习范例，我学到了很多，也同时复习了课上的许多知识，这再次印证了理论与实践相互结合、相辅相成的魅力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford_CS231n</title>
      <link href="/2022/05/23/stanford-cs231n/"/>
      <url>/2022/05/23/stanford-cs231n/</url>
      
        <content type="html"><![CDATA[<h3 id="KNN-K-nearest-Neighbor-K近邻算法"><a href="#KNN-K-nearest-Neighbor-K近邻算法" class="headerlink" title="KNN(K-nearest-Neighbor) K近邻算法"></a>KNN(K-nearest-Neighbor) K近邻算法</h3><p>K近邻（K-Nearest Neighbor, KNN）是一种最经典和最简单的<em>有监督学习</em>方法之一。K-近邻算法是最简单的分类器，<em>没有显式的学习过程或训练过程</em>，是<em>懒惰学习</em>（Lazy Learning）。当对数据的分布只有很少或者没有任何先验知识时，K 近邻算法是一个不错的选择。</p><ul><li><p>核心就是类似一种投票机制，测试样本附近最近的k个样本中，哪个类型的点多就归为哪一类</p></li><li><p>K近邻的难点在于衡量距离？比如两段文本，如何衡量其距离？</p></li></ul><h4 id="1-如何衡量两个对象距离？"><a href="#1-如何衡量两个对象距离？" class="headerlink" title="1. 如何衡量两个对象距离？"></a>1. 如何衡量两个对象距离？</h4><ul><li>L1：Manhattan曼哈顿距离，二维图像来看是一个正方体，正方形所有点距离远点曼哈顿相同。（视频中提到如果你的特征向量有一些具体的含义，那么maybe L1 is a better choice）.Besides, 坐标轴变换对Manhattan Distance 有影响 </li><li>L2: Euclidean欧氏距离，如果特征向量没有更多的含义普遍采用L2，转动坐标系对L2没有影响</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220523210259085.png" alt="image-20220523210259085"></p><ul><li>注：Hyperparameters 无法从数据中学习到的参数，k的选取，距离度量的选取</li></ul><h4 id="2-训练方法"><a href="#2-训练方法" class="headerlink" title="2. 训练方法"></a>2. 训练方法</h4><p><code>train + validation + test</code></p><p>choose best hyperparameters on val ,and evaluate it on test,train is just used as labels </p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220523214107087.png" alt="image-20220523214107087"></p><p>数据较少的时候更好的训练方法is交叉验证法，继续划分train，train中的每一个部分挨个当作val</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220523214203066.png" alt="image-20220523214203066"></p><p>总结</p><ul><li>KNN不适用于图像分类领域<ul><li>KNN导致维度灾难，要实现准确分类，需要的训练数据指数级增长</li><li>反正就是不适合图像！看着就不适合！</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北航OSLab5实验笔记</title>
      <link href="/2022/05/23/bei-hang-oslab5-shi-yan-bi-ji/"/>
      <url>/2022/05/23/bei-hang-oslab5-shi-yan-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab5-实验笔记"><a href="#Lab5-实验笔记" class="headerlink" title="Lab5 实验笔记"></a>Lab5 实验笔记</h2><h4 id="两个系统调用函数用于读写设备（这两个函数成功的话返回0）"><a href="#两个系统调用函数用于读写设备（这两个函数成功的话返回0）" class="headerlink" title="两个系统调用函数用于读写设备（这两个函数成功的话返回0）"></a>两个系统调用函数用于读写设备（这两个函数成功的话返回0）</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;占位符 要写的数据的所处虚拟地址 写入的设备dev的地址（注意这里传入时不加A0000000） 长度int sys_write_dev(int sysno, u_int va, u_int dev, u_int len)&#123;        &#x2F;&#x2F; Your code here        if ((0x10000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x1000000)        || (0x13000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x13004200)        || (0x15000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x15000200)) &#123;        bcopy((char *)va, (char *)(dev + 0xA0000000), len);        return 0;    &#125;    return -E_INVAL;&#125;int sys_read_dev(int sysno, u_int va, u_int dev, u_int len)&#123;        &#x2F;&#x2F; Your code here        if ((0x10000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x10000000 + 0x20)        || (0x13000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x13000000 + 0x4200)        || (0x15000000 &lt;&#x3D; dev &amp;&amp; dev + len &lt;&#x3D; 0x15000000 + 0x200)) &#123;        bcopy((char *)(dev + 0xA0000000), (char *)va, len);        return 0;    &#125;    return -E_INVAL;&#125;&#x2F;&#x2F;用户系统调用时调用下面这两个函数（与上面两个内核态函数一一对应）intsyscall_write_dev(u_int va, u_int dev, u_int len)&#123;return msyscall(SYS_write_dev, va, dev, len, 0, 0);&#125;intsyscall_read_dev(u_int va, u_int dev, u_int len)&#123;return msyscall(SYS_read_dev, va, dev, len, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520211751066.png" alt="image-20220520211751066"></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520211803831.png" alt="image-20220520211803831"></p><p><strong>注意这里所有的操作都是按照虚拟地址来的</strong></p><p>接着我们就可以仿照上述驱动程序写我们系统中的用户态程序，我们采用调用读写设备的系统调用可以同样实现上述功能。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">voidide_read(u_int diskno, u_int secno, void *dst, u_int nsecs)&#123;&#x2F;&#x2F; 0x200: the size of a sector: 512 bytes.int offset_begin &#x3D; secno * 0x200;int offset_end &#x3D; offset_begin + nsecs * 0x200;int offset &#x3D; 0;int tmp;while (offset_begin + offset &lt; offset_end) &#123;&#x2F;&#x2F; Your code here&#x2F;&#x2F; error occurred, then panic.tmp &#x3D; diskno;        &#x2F;&#x2F; IDE 的id 放进去 不成功的话系统调用返回的不是0 产生pannicif (syscall_write_dev((int)&amp;tmp, 0x13000010, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; 放入offsettmp &#x3D; offset_begin + offset;if (syscall_write_dev((int)&amp;tmp, 0x13000000, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; start read.放0进去读tmp &#x3D; 0;if (syscall_write_dev((int)&amp;tmp, 0x13000020, 4)) user_panic(&quot;error in ide_read()\n&quot;);&#x2F;&#x2F; get result.取出返回值if (syscall_read_dev((int)&amp;tmp, 0x13000030, 4)) user_panic(&quot;error in ide_read()\n&quot;);        &#x2F;&#x2F;返回值0失败，1成功证明可以读if (tmp &#x3D;&#x3D; 0) user_panic(&quot;error in ide_read()&quot;);        &#x2F;&#x2F;1证明可以读，开始读if (syscall_read_dev((int)(dst + offset), 0x13004000, 512)) user_panic(&quot;error in ide_read()\n&quot;);        &#x2F;&#x2F;下一个sectoroffset +&#x3D; 0x200;&#125;&#125;&#x2F;&#x2F;write流程一样voidide_write(u_int diskno, u_int secno, void *src, u_int nsecs)&#123;&#x2F;&#x2F; Your code hereint offset_begin &#x3D; secno * 0x200;int offset_end &#x3D; offset_begin + nsecs * 0x200;int offset &#x3D; 0;&#x2F;&#x2F; DO NOT DELETE WRITEF !!!writef(&quot;diskno: %d\n&quot;, diskno);int tmp;while (offset_begin + offset &lt; offset_end) &#123;&#x2F;&#x2F; Your code here    &#x2F;&#x2F; copy data from source array to disk buffer.&#x2F;&#x2F; error occurred, then panic.if (syscall_write_dev((int)(src + offset), 0x13004000, 512)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; select id&#x2F;tmp &#x3D; diskno;if (syscall_write_dev((int)&amp;tmp, 0x13000010, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; offset.tmp &#x3D; offset_begin + offset;if (syscall_write_dev((int)&amp;tmp, 0x13000000, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; start to writetmp &#x3D; 1;if (syscall_write_dev((int)&amp;tmp, 0x13000020, 4)) user_panic(&quot;error in ide_write()&quot;);&#x2F;&#x2F; get status.if (syscall_read_dev((int)&amp;tmp, 0x13000030, 4)) user_panic(&quot;error in ide_write()&quot;);if (tmp &#x3D;&#x3D; 0) user_panic(&quot;error in ide_write()&quot;);offset +&#x3D; 0x200;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意dev地址传入时不需要加A000000，直接传入规定好的设备地址即可，在系统调用里会加上A0000000</li></ul><h3 id="接下来编写文件系统"><a href="#接下来编写文件系统" class="headerlink" title="接下来编写文件系统"></a>接下来编写文件系统</h3><p>这里提到了磁盘块的概念，操作系统将多个相邻扇区合并为一个概念“磁盘块”进行操作（因为扇区实在太多无法一个一个操作，合并在一起以块为单位更好操作）</p><p>从图中可以看到，MOS 操作系统把磁盘最开始的一个磁盘块0 (4096 字节) 当作启动扇区和分区表使用。接下来的一个磁盘块1作为超级块 (Super Block)，用来描述文件系 统的基本信息，如 Magic Number、磁盘大小以及根目录的位置。</p><p>认识一下<strong>超级块的结构体</strong> —————————结构体</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220520221159768.png" alt="image-20220520221159768"></p><p>在文件系统中，我们将<strong>使用位图 (Bitmap) 法</strong>来管理空闲的磁盘资源，用一个二进制位 bit 标识磁盘中的每个磁盘块的使用情况（实验中，<strong>1 表示空闲</strong>）。</p><p>在这里涉及到一些宏和</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">&#x2F;&#x2F;一些宏#define BY2BLKBY2PG &#x2F;&#x2F;一个块的大小正好是一页4096Byte#define BIT2BLK(BY2BLK*8) &#x2F;&#x2F;这里算的是BLK的bit，所以自然是*8#define BY2FILE     256 &#x2F;&#x2F;一个file结构体的大小 256Byte#define NBLOCK 1024  &#x2F;&#x2F;一个disk里面有1024块#define FILE2BLK  (BY2BLK&#x2F;sizeof(struct File)) &#x2F;&#x2F;一个块里面有多少个file结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>认识一下<strong>block结构体</strong>——————————–又是一个结构体</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct Block &#123;    uint8_t data[BY2BLK];  &#x2F;&#x2F;数据区512Byte    uint32_t type; &#x2F;&#x2F;类型包括下面的enum&#125; disk[NBLOCK];enum &#123;    BLOCK_FREE  &#x3D; 0,    BLOCK_BOOT  &#x3D; 1,    BLOCK_BMAP  &#x3D; 2,    BLOCK_SUPER &#x3D; 3,    BLOCK_DATA  &#x3D; 4,    BLOCK_FILE  &#x3D; 5,    BLOCK_INDEX &#x3D; 6,&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先初始化init_disk，下面解析这个初始化函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void init_disk() &#123;    int i, r, diff;    &#x2F;&#x2F; Step 1: Mark boot sector block.    disk[0].type &#x3D; BLOCK_BOOT;&#x2F;&#x2F;nbitblock是bitmap的BLK数目，我们首先得把这个算出来然后才能开始初始化        &#x2F;&#x2F;计算nbitblock，正常算的话直接NBLOCK&#x2F;BIT2BLK ,但是这里因为是整除会向下取整，那我们得额外加上一个BIT2BLK相当于手动加一个块向上取整，保证所有的块都有对应的bit     nbitblock &#x3D; (NBLOCK + BIT2BLK - 1) &#x2F; BIT2BLK;        nextbno &#x3D; 2 + nbitblock;    &#x2F;&#x2F; Step 2: Initialize bitmap blocks.初始化为空闲1（写0xff,一个字节全1）        &#x2F;&#x2F;首先type声明这是一个MAP，这里之前在这个文件里enum过    for(i &#x3D; 0; i &lt; nbitblock; ++i) &#123;        disk[2+i].type &#x3D; BLOCK_BMAP; &#x2F;&#x2F;加2因为bitmap从第二个块开始    &#125;    for(i &#x3D; 0; i &lt; nbitblock; ++i) &#123;         memset(disk[2+i].data, 0xff, BY2BLK);    &#125;        &#x2F;&#x2F;如果位图还有剩余，不能将最后一块位图块中靠后的一部分内容标记为空闲，因为这些位所对应的磁盘块并不存在，不可被使用。因此，将所有的位图块的每一位都置为 1 之后，还需要根据实际情况，将位图不存在的部分设为0。    if(NBLOCK !&#x3D; nbitblock * BIT2BLK) &#123;        diff &#x3D; NBLOCK % BIT2BLK &#x2F; 8;&#x2F;&#x2F;最后一部分留的没对齐的尾巴的字节数        memset(disk[2+(nbitblock-1)].data+diff, 0x00, BY2BLK - diff);&#x2F;&#x2F;BY2BLK - diff剩余的空白的全置位0    &#125;    &#x2F;&#x2F; Step 3: Initialize super block.    disk[1].type &#x3D; BLOCK_SUPER;    super.s_magic &#x3D; FS_MAGIC;    super.s_nblocks &#x3D; NBLOCK;    super.s_root.f_type &#x3D; FTYPE_DIR;    strcpy(super.s_root.f_name, &quot;&#x2F;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化玩位图之后便可以<strong>调用int block_is_free(u_int blockno)函数查看块是否空闲</strong></p><ul><li>1空闲，0不空闲</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; Overview:&#x2F;&#x2F;  Check to see if the block &#39;blockno&#39; is free via bitmap.&#x2F;&#x2F;&#x2F;&#x2F; Post-Condition:&#x2F;&#x2F;  Return 1 if the block is free, else 0.intblock_is_free(u_int blockno)&#123;    if (super &#x3D;&#x3D; 0 || blockno &gt;&#x3D; super-&gt;s_nblocks) &#123; &#x2F;&#x2F;异常情况或者超出范围        return 0;    &#125;    if (bitmap[blockno &#x2F; 32] &amp; (1 &lt;&lt; (blockno % 32))) &#123;  &#x2F;&#x2F;位运算        return 1;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用void free_block(u_int blockno)释放一个块（对应位置位1）</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">voidfree_block(u_int blockno)&#123;    &#x2F;&#x2F; Step 1: Check if the parameter &#96;blockno&#96; is valid (&#96;blockno&#96; can&#39;t be zero).    if (blockno &#x3D;&#x3D; 0 || blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;        user_panic(&quot;blockno is zero&quot;);    &#125;    &#x2F;&#x2F; Step 2: Update the flag bit in bitmap.    &#x2F;&#x2F; you can use bit operation to update flags, such as  a |&#x3D; (1 &lt;&lt; n) .    bitmap[blockno &#x2F; 32] |&#x3D; (1 &lt;&lt; (blockno % 32));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时思考为什么参数 blockno 的值不能为0？</p><p>0块是最开始的一个磁盘块 (4096 字节) 当作启动扇区和分区表使用，启动扇区的程序都丢失了还用什么磁盘？？？？？？</p><h3 id="初始化完成后接下来了解文件系统详细结构"><a href="#初始化完成后接下来了解文件系统详细结构" class="headerlink" title="初始化完成后接下来了解文件系统详细结构"></a>初始化完成后接下来了解文件系统详细结构</h3><p>先来看<strong>文件File结构体</strong> —————————————-又是一个结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token punctuation">&#123;</span>    u_char f_name<span class="token punctuation">[</span>MAXNAMELEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// filename 件名的最大长度 MAXNAMELEN 值为 128</span>    u_int f_size<span class="token punctuation">;</span>           <span class="token comment">// file size in bytes</span>    u_int f_type<span class="token punctuation">;</span>           <span class="token comment">// file type为文件类型，有普通文件 (FTYPE_REG) 和文件夹 (FTYPE_DIR) 两种。</span>    u_int f_direct<span class="token punctuation">[</span>NDIRECT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//f_direct[NDIRECT] 为文件的直接指针，每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。</span>    <span class="token comment">//每个磁盘块的大小为 4KB，也就是说，这十个直接指针能够表示最大 40KB 的文件，而当文件的大小大于 40KB 时，就需要用到间接指针。</span>    u_int f_indirect<span class="token punctuation">;</span> <span class="token comment">//f_indirect指向一个间接磁盘块，用来存储许多指针，这些指针指向文件内容的磁盘块。有点像二重指针？指针指向存储指针的磁盘块，这些指针才真正指向文件内容磁盘块。</span>    <span class="token keyword">struct</span> <span class="token class-name">File</span> <span class="token operator">*</span>f_dir<span class="token punctuation">;</span>     <span class="token comment">// f_dir指向文件所属的文件目录</span>    u_char f_pad<span class="token punctuation">[</span>BY2FILE <span class="token operator">-</span> MAXNAMELEN <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> NDIRECT <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//f_pad则是为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://os.buaa.edu.cn/assets/courseware/v1/5957f2bb1dda8e8a3751b953392228b3/asset-v1:BUAA+B3I062270+2022_SPRING+type@asset+block/lab5-pic-3.png" alt="[lab5-file block]"></p><ul><li><p>上面是关于间接指针的理解，注意为了简化计算，我们不使用间接磁盘块的前十个指针。所以图中间接磁盘块里的指针是从10开始用的。</p></li><li><p>对于普通的文件，其指向的磁盘块存储着文件内容，而<strong>对于目录文件来说，其指向的磁盘块存储着该目录下各个文件对应的的文件控制块</strong>。当我们要查找某个文件时，首先从超级块中读取根目录的文件控制块，然后沿着目标路径，挨个查看当前目录所包含的文件是否与下一级目标文件同名，如此便能查找到最终的目标文件。</p></li></ul><p>接下来学习利用<strong>create_file</strong>创建一个文件</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;该函数传入一个目录文件的指针，在该目录下创建一个文件,并返回该创建好的文件的控制块的指针struct File *create_file(struct File *dirf) &#123;    struct File *dirblk;    int i, bno, found;    int nblk &#x3D; dirf-&gt;f_size &#x2F; BY2BLK; &#x2F;&#x2F;目录目前有多少个块，这些磁盘块存储着该目录下各个文件对应的的文件控制块    &#x2F;&#x2F; Your code here    &#x2F;&#x2F;接下来找目录里面可以放空闲的文件控制块的位置    &#x2F;&#x2F;分两种情况，第一种是目录的磁盘块里面还有位置可以放一个文件控制块    &#x2F;&#x2F;第二种是目录里面没有位置了，要使用bno &#x3D; make_link_block(dirf, nblk);分配一个新的BLK，在这个块里放文件控制块        &#x2F;&#x2F;这是第一种    for (i &#x3D; 0; i &lt; nblk; i++) &#123;        &#x2F;&#x2F;首先根据块的顺序号取得块号        if (i &lt; NDIRECT) &#123; &#x2F;&#x2F;如果这个块是直接的            bno &#x3D; dirf-&gt;f_direct[i];        &#125; else &#123; &#x2F;&#x2F;如果这个块是间接的            bno &#x3D; ((uint32_t *)(disk[dirf-&gt;f_indirect].data))[i];        &#125;        &#x2F;&#x2F;根据块号从disk里面取到目录块的内容，始终要记住目录快里面存储文件的控制块        dirblk &#x3D; (struct File *)(disk[bno].data);&#x2F;&#x2F;这里相当于把取出来的内容转化成数组了  相当于  Struct File dirblk[] &#x3D; .......，因为这里把取出来的内容转化成FIle*指针了        for (j &#x3D; 0; j &lt; FILE2BLK; j++) &#123; &#x2F;&#x2F;如果这些控制块里有没有用过的（判断标准是文件名为空），那么就找到了！返回它的地址            if (dirblk[j].f_name[0] &#x3D;&#x3D; &#39;\0&#39;) &#123;                 return &amp;dirblk[j];            &#125;        &#125;    &#125;&#x2F;&#x2F;找了半天没有找到，证明目录dirf里面所有块全都用完了，再分配一个空闲块里面存储文件控制块并返回这个文件控制块    &#x2F;&#x2F;分配一个新的到目录文件的控制块的nblk号位    bno &#x3D; make_link_block(dirf, nblk);    return (struct File *)disk[bno].data;&#125;&#x2F;&#x2F;调这个函数分配新的disk块，传一个目录文件控制块指针进来，我们要分一个新的disk块连接到dirf的nblk号位上int make_link_block(struct File *dirf, int nblk) &#123;    &#x2F;&#x2F;取一个新的type类型空闲块    int bno &#x3D; next_block(BLOCK_FILE);    &#x2F;&#x2F;链接到nblk号位    save_block_link(dirf, nblk, bno);    &#x2F;&#x2F;文件大小增加    dirf-&gt;f_size +&#x3D; BY2BLK;    &#x2F;&#x2F;返回新分配的的空闲块号    return bno;&#125;&#x2F;&#x2F;nextbno是个全局变量代表下一个空闲disk块，这个函数实际上就是在维护这个变量&#x2F;&#x2F;我们需要一个type类型的块，在这里取一个空闲块设置它的type，更新nextbno，返回空闲块号int next_block(int type) &#123;    disk[nextbno].type &#x3D; type;return nextbno++;&#125;void save_block_link(struct File *f, int nblk, int bno)&#123;    assert(nblk &lt; NINDIRECT); &#x2F;&#x2F; if not, file is too large !&#x2F;&#x2F;如果是直接块链接到直接块    if(nblk &lt; NDIRECT) &#123;        f-&gt;f_direct[nblk] &#x3D; bno;    &#125;    else &#123;&#x2F;&#x2F;不是的话连接到间接快        if(f-&gt;f_indirect &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果间接指针还没有分配给他分配一个            &#x2F;&#x2F; create new indirect block.            f-&gt;f_indirect &#x3D; next_block(BLOCK_INDEX);        &#125;        ((uint32_t *)(disk[f-&gt;f_indirect].data))[nblk] &#x3D; bno;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上内容都是fsformat.c里面的内容用于创建磁盘镜像真正使用的操作磁盘的函数在fs.c内</p><hr><p>下面是fs.c的内容</p><p>接下来学习磁盘块到内存映射的实现过程</p><p>首先是一些常用函数，怎么这么多啊？？？？？？？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;blockno转对应虚拟地址，其实就是加上基地址DISKMAPu_intdiskaddr(u_int blockno)&#123;    if (super &amp;&amp; blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;        user_panic(&quot;reading non-existent block %08x\n&quot;, blockno);    &#125;    return DISKMAP + (blockno * BY2BLK);&#125;&#x2F;&#x2F;这个函数检查块是否已经在内存里映射过了intmap_block(u_int blockno)&#123;    &#x2F;&#x2F; Step 1: Decide whether this block has already mapped to a page of physical memory.    &#x2F;&#x2F;如果已经映射过了就返回0    &#x2F;&#x2F;调用block_is_mapped(blockno)这个函数，如果映射过返回对应虚拟地址，没映射过返回0    if (block_is_mapped(blockno)) &#123;        return 0;    &#125;&#x2F;&#x2F;没有影射过那就系统调用 映射一下    return syscall_mem_alloc(0, diskaddr(blockno), PTE_V | PTE_R);&#x2F;&#x2F;第一个参数是envid，0的话代指当前进程&#125;&#x2F;&#x2F;该函数用于解除磁盘块和物理内存之间的映射关系，回收内存，注意要回收！就是接触映射的时候要把虚拟内存里面的内容回收到磁盘里。voidunmap_block(u_int blockno)&#123;    int r;    u_int addr;    &#x2F;&#x2F; 如果根本没有映射过就不用回收，直接返回    addr &#x3D; block_is_mapped(blockno);    if (addr &#x3D;&#x3D; 0) &#123;        return;    &#125;    &#x2F;&#x2F; 如果虚拟内存里填过东西要回收到磁盘里    if (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;        write_block(blockno); &#x2F;&#x2F;把va里面的东西回收进来    &#125;    r &#x3D; syscall_mem_unmap(0, addr);&#x2F;&#x2F;解除绑定    if (r &lt; 0) &#123;        user_panic(&quot;unmap_block failed&quot;);    &#125;    &#x2F;&#x2F; Step 4: validate result of this unmap operation.    user_assert(!block_is_mapped(blockno));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是一个调用更多的函数</p><ul><li><code>int dir_lookup(struct File *dir, char *name, struct File **file)</code>在目录文件中找到名叫name的文件，并在让*file指向他</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Try to find a file named &quot;name&quot; in dir.  If so, set *file to it.intdir_lookup(struct File *dir, char *name, struct File **file)&#123;int r;u_int i, j, nblock;void *blk;struct File *f;&#x2F;&#x2F; Step 1: Calculate nblock: how many blocks this dir have.nblock &#x3D; ROUND(dir-&gt;f_size, BY2BLK) &#x2F; BY2BLK;for (i &#x3D; 0; i &lt; nblock; i++) &#123;&#x2F;&#x2F; Step 2: Read the i&#39;th block of the dir.&#x2F;&#x2F; Hint: Use file_get_block.调用下面这个函数得到f的filebno个块对应的内存中的虚拟地址（这个函数附带的作用是保证把这个块读到内存映射里面，接下来我们就可以在内存中操作磁盘数据映射）r &#x3D; file_get_block(dir, i, &amp;blk);&#x2F;&#x2F;这个blk是对应的虚拟地址if (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 3: Find target file by file name in all files on this block.&#x2F;&#x2F; If we find the target file, set the result to *file and set f_dir field.        &#x2F;&#x2F;得到blk这个虚拟地址就可以开始指针操作了        &#x2F;&#x2F;FILE2BLK是一个宏，指一个块里面有多少file结构体for (j &#x3D; 0; j &lt; FILE2BLK; j++) &#123;f &#x3D; ((struct File *)blk) + j; &#x2F;&#x2F;把目录磁盘块里file结构体挨个取出来            &#x2F;&#x2F;注意这时我们已经开始在内存映射中操作了，现在是在内存中if (strcmp((char *)f-&gt;f_name, name) &#x3D;&#x3D; 0) &#123;f-&gt;f_dir &#x3D; dir;*file &#x3D; f;return 0;&#125;&#125;&#125;return -E_NOT_FOUND;&#125;&#x2F;&#x2F;这个函数用于得到f的第filebno个块的块号，并保证把这块读进内存里，blk返回该快对应的虚拟地址&#x2F;&#x2F; Overview:&#x2F;&#x2F;Set *blk to point at the filebno&#39;th block in file f.intfile_get_block(struct File *f, u_int filebno, void **blk)&#123;int r;u_int diskbno;u_int isnew;&#x2F;&#x2F; Step 1: find the disk block number is &#96;f&#96; using &#96;file_map_block&#96;.if ((r &#x3D; file_map_block(f, filebno, &amp;diskbno, 1)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: read the dataif ((r &#x3D; read_block(diskbno, blk, &amp;isnew)) &lt; 0) &#123;return r;&#125;return 0;&#125;&#x2F;&#x2F;将blockno读到对应的内存映射里，在blk里面返回其在内存中的虚拟地址，注意这里是虚拟地址！！！intread_block(u_int blockno, void **blk, u_int *isnew)&#123;u_int va;&#x2F;&#x2F;两个异常情况    &#x2F;&#x2F; 1 超出范围if (super &amp;&amp; blockno &gt;&#x3D; super-&gt;s_nblocks) &#123;user_panic(&quot;reading non-existent block %08x\n&quot;, blockno);&#125;&#x2F;&#x2F; 2 空闲块怎么读？ you are crazy！if (bitmap &amp;&amp; block_is_free(blockno)) &#123;user_panic(&quot;reading free block %08x\n&quot;, blockno);&#125;&#x2F;&#x2F; 虚拟地址找出来va &#x3D; diskaddr(blockno);&#x2F;&#x2F; Step 4: read disk and set *isnew.&#x2F;&#x2F; Hint: if this block is already mapped, just set *isnew, else alloc memory and&#x2F;&#x2F; read data from IDE disk (use &#96;syscall_mem_alloc&#96; and &#96;ide_read&#96;).&#x2F;&#x2F; We have only one IDE disk, so the diskno of ide_read should be 0.    &#x2F;&#x2F;如果没有map过map一下if (block_is_mapped(blockno)) &#123;&#x2F;&#x2F;the block is in memoryif (isnew) &#123;*isnew &#x3D; 0;&#125;&#125; else &#123;&#x2F;&#x2F;the block is not in memoryif (isnew) &#123;*isnew &#x3D; 1;&#125;syscall_mem_alloc(0, va, PTE_V | PTE_R);ide_read(0, blockno * SECT2BLK, (void *)va, SECT2BLK);&#125;&#x2F;&#x2F; Step 5: if blk !&#x3D; NULL, set &#96;va&#96; to *blk.这里是虚拟地址！！if (blk) &#123;*blk &#x3D; (void *)va;&#125;return 0;&#125;&#x2F;&#x2F;这个函数先用file_block_walk找到了f第filebno个块对应的块号，然后做了一些简单额外操作，就是这个块号如果是0的话证明还没有分配，给他分配一下并记录到f的控制块内，*diskbno存储这个块号&#x2F;&#x2F; OVerview:&#x2F;&#x2F;Set *diskbno to the disk block number for the filebno&#39;th block in file f.&#x2F;&#x2F; If alloc is set and the block does not exist, allocate it.intfile_map_block(struct File *f, u_int filebno, u_int *diskbno, u_int alloc)&#123;int r;u_int *ptr;&#x2F;&#x2F; Step 1: find the pointer for the target block.if ((r &#x3D; file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: if the block not exists, and create is set, alloc one.if (*ptr &#x3D;&#x3D; 0) &#123;if (alloc &#x3D;&#x3D; 0) &#123;return -E_NOT_FOUND;&#125;if ((r &#x3D; alloc_block()) &lt; 0) &#123;return r;&#125;*ptr &#x3D; r;&#125;&#x2F;&#x2F; Step 3: set the pointer to the block in *diskbno and return 0.*diskbno &#x3D; *ptr;return 0;&#125;&#x2F;&#x2F;这个函数用于找到f的第filebno个块的块号，在**ppdiskno里存储这个块号，这个块号有可能是0，因为还没有分配，注意如果alloc还要有特殊操作this function will allocate an indirect block if necessary.&#x2F;&#x2F; Overview:&#x2F;&#x2F;Like pgdir_walk but for files. &#x2F;&#x2F;Find the disk block number slot for the &#39;filebno&#39;th block in file &#39;f&#39;. Then, set &#x2F;&#x2F;&#39;*ppdiskbno&#39; to point to that slot. The slot will be one of the f-&gt;f_direct[] entries,&#x2F;&#x2F; or an entry in the indirect block.&#x2F;&#x2F; When &#39;alloc&#39; is set, this function will allocate an indirect block if necessary.intfile_block_walk(struct File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)&#123;int r;u_int *ptr;void *blk;if (filebno &lt; NDIRECT) &#123;&#x2F;&#x2F; Step 1: if the target block is corresponded to a direct pointer, just return the&#x2F;&#x2F; disk block number.ptr &#x3D; &amp;f-&gt;f_direct[filebno];&#125; else if (filebno &lt; NINDIRECT) &#123;&#x2F;&#x2F; Step 2: if the target block is corresponded to the indirect block, but there&#39;s no&#x2F;&#x2F;indirect block and &#96;alloc&#96; is set, create the indirect block.if (f-&gt;f_indirect &#x3D;&#x3D; 0) &#123;if (alloc &#x3D;&#x3D; 0) &#123;return -E_NOT_FOUND;&#125;if ((r &#x3D; alloc_block()) &lt; 0) &#123;return r;&#125;f-&gt;f_indirect &#x3D; r;&#125;&#x2F;&#x2F; Step 3: read the new indirect block to memory. if ((r &#x3D; read_block(f-&gt;f_indirect, &amp;blk, 0)) &lt; 0) &#123;return r;&#125;ptr &#x3D; (u_int *)blk + filebno;&#125; else &#123;return -E_INVAL;&#125;&#x2F;&#x2F; Step 4: store the result into *ppdiskbno, and return 0.*ppdiskbno &#x3D; ptr;return 0;&#125;&#x2F;&#x2F;这个函数用于在位图中找一个空闲块返回其块号intalloc_block_num(void)&#123;int blockno;&#x2F;&#x2F; walk through this bitmap, find a free one and mark it as used, then sync&#x2F;&#x2F; this block to IDE disk (using &#96;write_block&#96;) from memory.for (blockno &#x3D; 3; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;if (bitmap[blockno &#x2F; 32] &amp; (1 &lt;&lt; (blockno % 32))) &#123;&#x2F;&#x2F;the block is freebitmap[blockno &#x2F; 32] &amp;&#x3D; ~(1 &lt;&lt; (blockno % 32));&#x2F;&#x2F;这里把空闲位取消掉            &#x2F;&#x2F;下面这句话纯纯有病，直接把2块写回disk不就行了，加个blockno &#x2F; BIT2BLK有个卵用？write_block(blockno &#x2F; BIT2BLK + 2); &#x2F;&#x2F; write 2块即bitmap块 to disk.return blockno;&#125;&#125;&#x2F;&#x2F; no free blocks.return -E_NO_DISK;&#125;&#x2F;&#x2F;分配一个块并把它map到虚拟空间里去intalloc_block(void)&#123;int r, bno;&#x2F;&#x2F; Step 1: find a free block.找到空闲块调用上面那个函数if ((r &#x3D; alloc_block_num()) &lt; 0) &#123; &#x2F;&#x2F; failed.return r;&#125;bno &#x3D; r;&#x2F;&#x2F; Step 2: map this block into memory. if ((r &#x3D; map_block(bno)) &lt; 0) &#123; &#x2F;&#x2F;map这个块free_block(bno);&#x2F;&#x2F;map不成功的话把它free掉，因为alloc_block_num()函数里把它的空闲位取消掉了return r;&#125;&#x2F;&#x2F; Step 3: return block number.return bno;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接下来将这些函数进一步封装为我们常用的open-write，close的等函数"><a href="#接下来将这些函数进一步封装为我们常用的open-write，close的等函数" class="headerlink" title="接下来将这些函数进一步封装为我们常用的open,write，close的等函数"></a>接下来将这些函数进一步封装为我们常用的open,write，close的等函数</h4><p>首先又来了三个结构体</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; Device struct:&#x2F;&#x2F; It is used to read and write data from corresponding device.&#x2F;&#x2F; We can use the five functions to handle data.&#x2F;&#x2F; There are three devices in this OS: file, console and pipe.struct Dev &#123;    int dev_id;    char *dev_name;    int (*dev_read)(struct Fd *, void *, u_int, u_int);    int (*dev_write)(struct Fd *, const void *, u_int, u_int);    int (*dev_close)(struct Fd *);    int (*dev_stat)(struct Fd *, struct Stat *);    int (*dev_seek)(struct Fd *, u_int);&#125;;&#x2F;&#x2F; file descriptorstruct Fd &#123;    u_int fd_dev_id;&#x2F;&#x2F;外设id    u_int fd_offset;&#x2F;&#x2F;读或写的当前位置    u_int fd_omode;&#x2F;&#x2F;打开方式&#125;;&#x2F;&#x2F; Statestruct Stat &#123;    char st_name[MAXNAMELEN];    u_int st_size;    u_int st_isdir;    struct Dev *st_dev;&#125;;&#x2F;&#x2F; file descriptor + filestruct Filefd &#123;    struct Fd f_fd;    u_int f_fileid;    struct File f_file;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是open函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intopen(const char *path, int mode)&#123;struct Fd *fd;struct Filefd *ffd;u_int size, fileid;int r;u_int va;u_int i;&#x2F;&#x2F; Step 1: Alloc a new Fd, return error code when fail to alloc.&#x2F;&#x2F; Hint: Please use fd_alloc.&#x2F;&#x2F;先来一个fd，用fd——allocr &#x3D; fd_alloc(&amp;fd); &#x2F;&#x2F; this is a whole 4KB spaceif (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: Get the file descriptor of the file to open.&#x2F;&#x2F; Hint: Read fsipc.c, and choose a function.    &#x2F;&#x2F;利用进程通信要求文件系统进程将文件的相关信息写入fd空间中r &#x3D; fsipc_open(path, mode, fd);if (r &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 3: Set the start address storing the file&#39;s content. Set size and fileid correctly.&#x2F;&#x2F; Hint: Use fd2data to get the start address.    &#x2F;&#x2F;有了fd，强转一下就是ffd，ffd有文件id，文件size信息，map的时候需要文件id信息。ffd &#x3D; (struct Filefd *)fd;va &#x3D; fd2data(fd);&#x2F;&#x2F;这个va就是文件放内容的地方，利用fd2data函数fileid &#x3D; ffd-&gt;f_fileid;size &#x3D; ffd-&gt;f_file.f_size;&#x2F;&#x2F; Step 4: Alloc memory, map the file content into memory.    &#x2F;&#x2F;map一下for (i &#x3D; 0; i &lt; size; i +&#x3D; BY2BLK) &#123;r &#x3D; fsipc_map(fileid, i, va + i);if (r &lt; 0) &#123;return r;&#125;&#125;&#x2F;&#x2F; Step 5: Return the number of file descriptor.return fd2num(fd); &#x2F;&#x2F;返回文件描述符的编号&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是write和read函数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intwrite(int fdnum, const void *buf, u_int n)&#123;int r;struct Dev *dev;struct Fd *fd;&#x2F;&#x2F;利用lookup函数找到对应的fd和devif ((r &#x3D; fd_lookup(fdnum, &amp;fd)) &lt; 0||  (r &#x3D; dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F;不能写的话报错if ((fd-&gt;fd_omode &amp; O_ACCMODE) &#x3D;&#x3D; O_RDONLY) &#123;writef(&quot;[%08x] write %d -- bad mode\n&quot;, env-&gt;env_id, fdnum);return -E_INVAL;&#125;&#x2F;&#x2F;这个不用管if (debug) writef(&quot;write %d %p %d via dev %s\n&quot;,  fdnum, buf, n, dev-&gt;dev_name);&#x2F;&#x2F;利用dev内的函数指针把buf内容写入文件，注意这里要传入fd内的文件offsetr &#x3D; (*dev-&gt;dev_write)(fd, buf, n, fd-&gt;fd_offset);    &#x2F;&#x2F;更新fd内的offsetif (r &gt; 0) &#123;fd-&gt;fd_offset +&#x3D; r;&#125;return r;&#125;&#x2F;&#x2F;跟write一模一样，调用的dev的函数不一样intread(int fdnum, void *buf, u_int n)&#123;int r;struct Dev *dev;struct Fd *fd;&#x2F;&#x2F; Similar to &#39;write&#39; function.&#x2F;&#x2F; Step 1: Get fd and dev.    &#x2F;&#x2F;跟write函数一样，先得把fd和dev读出来if ((r &#x3D; fd_lookup(fdnum, &amp;fd)) &lt; 0||  (r &#x3D; dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; 0) &#123;return r;&#125;&#x2F;&#x2F; Step 2: Check open mode.    &#x2F;&#x2F;只能写的话就不能读if ((fd-&gt;fd_omode &amp; O_ACCMODE) &#x3D;&#x3D; O_WRONLY) &#123;writef(&quot;[%08x] read %d -- bad mode\n&quot;, env-&gt;env_id, fdnum);return -E_INVAL;&#125;if (debug) writef(&quot;read %d %p %d via dev %s\n&quot;,  fdnum, buf, n, dev-&gt;dev_name);&#x2F;&#x2F; Step 3: Read starting from seek position.r &#x3D; (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset);&#x2F;&#x2F; Step 4: Update seek position and set &#39;\0&#39; at the end of buf.if (r &gt; 0) &#123;fd-&gt;fd_offset +&#x3D; r;&#125;((char *)buf)[r] &#x3D; &#39;\0&#39;;return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来是我们的重点理解之处，那就是其实我们的文件系统实际上是通过进程通信实现的，我们使用fs.c(filesystem)中的一系列进程通信函数来告知文件系统进程如何操作文件实验中以remove操作展现了进程通信实现文件操作是如何实现的。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;进程调用这个封装好的接口删除文件，实际上就是执行一个系统调用intremove(const char *path)&#123;&#x2F;&#x2F; Your code here.&#x2F;&#x2F; Call fsipc_remove.return fsipc_remove(path);&#125;&#x2F;&#x2F;这就是那个系统调用告诉文件系统进程要删除文件intfsipc_remove(const char *path)&#123;struct Fsreq_remove *req; &#x2F;&#x2F;每一个操作都有一个专门的结构体声明    &#x2F;&#x2F; Step 1: Check the length of path, decide if the path is valid.if (strlen(path) &gt;&#x3D; MAXPATHLEN) &#123;return -E_BAD_PATH;&#125;&#x2F;&#x2F; Step 2: Transform fsipcbuf to struct Fsreq_remove*        &#x2F;&#x2F;有一个专门的fsipcbuf缓冲区用于存放req，使用时要将其强制转换对应类型的请求req &#x3D; (struct Fsreq_remove *)fsipcbuf;        &#x2F;&#x2F;放一些信息进去&#x2F;&#x2F; Step 3: Copy path to path in req.strcpy((char *)req-&gt;req_path, path);    &#x2F;&#x2F;掉fsipc传入参数，第一个参数是操作类型&#x2F;&#x2F; Step 4: Send request to fs server with IPC.return fsipc(FSREQ_REMOVE, req, 0, 0);&#125;&#x2F;&#x2F;文件系统进程接收到删除文件的req就执行这个函数，底层实际上是执行了一个file_remove(path);函数voidserve_remove(u_int envid, struct Fsreq_remove *rq)&#123;int r;char path[MAXPATHLEN];&#x2F;&#x2F; Step 1: Copy in the path, making sure it&#39;s terminated.&#x2F;&#x2F; Notice: add \0 to the tail of the pathstrcpy(path, (char *)rq-&gt;req_path);&#x2F;&#x2F; Step 2: Remove file from file system and response to user-level process.&#x2F;&#x2F; Call file_remove and ipc_send an approprite value to corresponding env.r &#x3D; file_remove(path);ipc_send(envid, r, 0, 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepLearning：CS231n课程学习实录</title>
      <link href="/2022/05/16/deeplearning-cs231n-ke-cheng-xue-xi-shi-lu/"/>
      <url>/2022/05/16/deeplearning-cs231n-ke-cheng-xue-xi-shi-lu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程.md</title>
      <link href="/2022/05/16/cao-zuo-xi-tong-jin-cheng/"/>
      <url>/2022/05/16/cao-zuo-xi-tong-jin-cheng/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022北航UNIX复习资料</title>
      <link href="/2022/05/13/2022-bei-hang-unix-fu-xi-zi-liao/"/>
      <url>/2022/05/13/2022-bei-hang-unix-fu-xi-zi-liao/</url>
      
        <content type="html"><![CDATA[<p>一：</p><p>**1.**UNIX是一类操作系统。狭义理解，UNIX是一个分时操作系统的核心，控制和分配计算机资源（软硬件），协调各应用进程的运行。广义理解，UNIX除了其核心外，还包括一些基本的工具，如编辑器、编译器、文件操作工具、文字处理工具等。更广义地理解，UNIX还包括用户自己开发的各种工具软件。</p><p>**2.**1973年，B语言（一种解释语言）高手 Dennis Ritchie发明C语言，并用C语言重写UNIX系统，产生了第一个UNIX的正式版本—-SYSTEM V。</p><p>**3.**Linux的由来1987年，荷兰阿姆斯特丹Vrije大学Andrew S. Tanenbaum教授（MIT学士，Berkeley博士）为课堂教学编写了Minix系统。1991年，年仅21岁的芬兰赫尔辛基大学的学生Linus Torvalds参考Minix开发了PC版的UNIX，命名为Linux。</p><p><strong>4</strong>.Linux的特点 ①与UNIX兼容，遵从POSIX标准②自由，开源③性能高，安全性强</p><p><strong>5</strong>.什么是操作系统 用户与计算机硬件之间的界面，它是控制、管理计算机系统内各种硬件和软件资源，有效地组织多道程序运行的系统软件(或程序集合)。</p><p>二：</p><p>**1.**基本操作—-登录login: you | password: | $ | $ who | $ who am I &#x2F;&#x2F;or whoami</p><p>$ write <em>username</em> | $ man <em>command</em> | $w<tab><tab>  or wr<tab> | $ logout 或exit</p><p>（|表示分隔，指令中没有|）</p><p><strong>2.</strong> 行编辑器ed | $ ed | a | now type in… | what do you want to type? | . | w tmp | q | $</p><p>a - 从当前行开始添加  i - 在文件的最后一行之前插入新内容 </p><p>o - 把文件输入的最后一行（不论是原来存在的或者插入的）替换成新内容</p><p>. - 退出编辑文件模式进入命令行模式（注意：此时并没有退出 ed 编辑器） </p><p>w - 保存文件    q - 真正退出 ed 编辑器</p><p>①显示命令 p</p><p>p  显示当前行      5  将当前行改为第5行并显示当前行</p><p>m，np 显示m到n行</p><p>.代表当前行，$代表最后一行</p><p>可使用相对行，如 .,.+3p  $-5,$p</p><p>②插入、删除、撤销</p><p>na 从n行后添加</p><p>ni 从n行前插入。i、a都以行首.来结束</p><p>m,nd 删除m至n行</p><p>u 撤销所做的编辑</p><p>③替换</p><p>s&#x2F;old&#x2F;new&#x2F; 把当前行中第一个old替换为new</p><p>s&#x2F;old&#x2F;new&#x2F;g 把当前行中每一个old都替换为new</p><p>1,$ s&#x2F;old&#x2F;new&#x2F;g 把文件中所有的old都替换为new</p><p>④速记符&amp;</p><p>1，$s&#x2F;big&#x2F;very &amp;&#x2F;g 把文件中的big都替换为very big</p><p>s&#x2F;and&#x2F;&amp;&#x2F; 把and改为&amp;</p><p>⑤查找&#x2F;^$&#x2F; 空行</p><p>&#x2F;.&#x2F;  非空行</p><p>&#x2F;^&#x2F;  任意行</p><p>&#x2F;thing&#x2F; 包含字符串thing的行</p><p>&#x2F;^thing&#x2F; 以thing开始的行</p><p>&#x2F;thing$&#x2F;  以thing结尾的行</p><p>&#x2F;^thing$&#x2F; 内容为thing的行</p><p>&#x2F;thing.$&#x2F; 以thing加任意符号结尾的行</p><p>&#x2F;thing.$&#x2F; 以thing.结尾的行</p><p>&#x2F;/thing/&#x2F; 包含&#x2F;thing&#x2F;的行</p><p>&#x2F;[tT]hing&#x2F; 包含thing或Thing的行</p><p>&#x2F;thing[0-9]&#x2F;</p><p>&#x2F;thing[^0-9]&#x2F;</p><p>&#x2F;thing[0-9][^0-9]&#x2F;</p><p>&#x2F;thing1.*thing2&#x2F;</p><p>&#x2F;^thing1.*thing2$&#x2F;</p><p>全局命令g&#x2F;…&#x2F;p 显示所有包含…的行</p><p>g&#x2F;…&#x2F;d 删除所有包含…的行</p><p>g&#x2F;…&#x2F;s&#x2F;&#x2F;rep1&#x2F; 对于包含…的行，将其中第一个替换成rep1</p><p>g&#x2F;…&#x2F;s&#x2F;&#x2F;rep1&#x2F;g 把所有的…替换成rep1</p><p>g&#x2F;…&#x2F;s&#x2F;pat&#x2F;rep1&#x2F; 对于包含…的行，将其中第一个pat替换成rep1</p><p>v&#x2F;^$&#x2F;p 打印所有非空行</p><p>⑥移动、复制</p><p>命令格式：m,nmd m到n行移到d行之后。</p><p>m,ntd  m到n行拷贝到d行之后</p><p>举例说明一下。 [titan@localhost titan]$ <strong>ed</strong>    &#x2F;&#x2F; 激活 <strong>ed</strong> 命令<br> a   &#x2F;&#x2F; 告诉 <strong>ed</strong> 我要编辑新文件<br> My name is Titan.  &#x2F;&#x2F; 输入第一行内容<br> And I love Perl very much.   &#x2F;&#x2F; 输入第二行内容<br> .   &#x2F;&#x2F;返回 <strong>ed</strong> 的命令行状态<br> i   &#x2F;&#x2F;告诉 <strong>ed</strong> 我要在最后一行之前插入内容<br> I am 24.   &#x2F;&#x2F; 将“I am 24.”插入“My name is Titan.”和“And I love Perl very much.”之间<br> .   &#x2F;&#x2F; 返回 <strong>ed</strong> 的命令行状态<br> c   &#x2F;&#x2F; 告诉 <strong>ed</strong> 我要替换最后一行输入内容<br> I am 24 years old.  &#x2F;&#x2F; 将“I am 24.”替换成“I am 24 years old.”（注意：这里替换的是最后输的内容）<br> .   &#x2F;&#x2F; 返回 <strong>ed</strong> 的命令行状态<br> w readme.text   &#x2F;&#x2F; 将文件命名为“readme.text”并保存（注意：如果是编辑已经存在的文件，只需要敲入 w 即可）<br> q   &#x2F;&#x2F; 完全退出 <strong>ed</strong> 编辑器<br> 这是文件的内容是： [titan@localhost titan]$ cat readme.text &lt;-<br> My name is Titan.<br> I am 24 years old.<br> And I love Perl vrey much.<br> [titan@localhost titan]$ </p><p>\3. 文件列表ls    $ ls        $ ls –l &#x2F;&#x2F;详细信息列表</p><p>$ ls –t &#x2F;&#x2F;按修改时间排序        $ ls –lt &#x2F;&#x2F;命令选项可以组合</p><p><strong>4.</strong> 显示文件cat  &#x2F;&#x2F;针对文本文件    </p><p><strong>5.</strong> 移动及重命名： mv file1 file2  &#x2F;&#x2F;文件&#x2F;目录重命名、</p><p>mv -i abc &#x2F;home&#x2F;cdy把当前目录下的abc 移动到&#x2F;home目录下面，并重命名为cdy；-i表示相同名字文件覆盖时询问，若-f则表示覆盖时不询问</p><p>复制： cp file1 file2  &#x2F;&#x2F;将文件file1复制成文件file2</p><p>cp &#x2F;tmp&#x2F;file1  &#x2F;&#x2F;将目录 &#x2F;tmp 下的文档 file1复制到现行目录下，档名仍为 file1</p><p>删除：rm [文件名]</p><p><strong>6.</strong> wc命令:计数,一或多个文档里的字符、单词、行数 1、字符计数中包含了换行符(\n) </p><p> 2、默认输出三个选项(c，l，w),可单独指定 c 字符 l 行 w 单词 </p><p>#wc test1</p><p>7 23 108 test1  &#x2F;&#x2F;7行 23个单词 108个字符(包括”\n”)</p><p>#wc -l test1</p><p>7 test1  &#x2F;&#x2F;-c和-w同理</p><p><strong>7.</strong> $ grep ‘test’ d*<br> 显示所有以d开头的文件中包含 test的行。<br> $ grep ‘test’ aa bb cc<br> 显示在aa，bb，cc文件中匹配test的行。<br> $ grep ‘[a-z]{5}’ aa<br> 显示aa中所有包含每个字符串至少有5个连续小写字符的字符串的行。<br> $ grep ‘w(es)t.<em>\1′ aa<br> 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.</em>)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.*\1′就可以了。</p><p><strong>8.</strong> sort 将文件每一行单词或数字按从a-z顺序输出。-u选项：去除重复词 -r选项：倒序输出 -n选项：按数值排序（这样10才会排在2的后面）</p><p><strong>9.</strong> cmp比较指令cmp prog.o.bak prog.o  &#x2F;&#x2F;输入</p><p>   prog.o.bak  prog.o  differ: char 4, line 1 &#x2F;&#x2F;表示第一行第四个字符不同</p><p>-l cmp -l prog.o.bak prog.o   5 101 141 &#x2F;&#x2F;表示第五个字节在 prog.o.bak 中是八进制 101，在 prog.o 中是 141</p><p>cmp -s prog.c.bak prog.c &#x2F;&#x2F;文件相同，给出值 0，不同，给出值 1，发生错误，给出值 2。</p><p>**10.**diff : diff &#x2F;usr&#x2F;xu mine &#x2F;&#x2F;把目录&#x2F;usr&#x2F;xu 中名为mine的文件与当前目录中的mine文件进行比较。</p><p><strong>11.</strong> <strong>文件目录</strong> $ pwd 显示当前路径（目录） $ cd 改变当前工作目录，或返回个人主目录</p><p><strong>.</strong> 和..目录    $ mkdir 创建子目录   $ rmdir 删除子目录</p><p><strong>12.</strong> <strong>基本操作</strong><strong>—-shell</strong></p><p>①文件名缩写（模式）$ ls <em>.c    $ ls a</em>[1-9].c     $ ls ?.c</p><p>②转义字符\   echo <em>,  echo *,  ls ‘</em>’</p><p>③I&#x2F;O重定向 $ ls &gt; tmp    $ ls -l &gt;tmp     $ ls &gt;&gt;tmp    $ wc &lt;tmp</p><p>标准输入文件，标准输出文件，标准错误输出文件</p><p>④管道   $ who | wc -l  计算所有用户登录的终端数</p><p>$ who | grep pts | wc -l 计算用户所使用的仿真终端数量. &#x2F;&#x2F;管道线上的程序是同时运行的，它们之间存在通信。</p><p>⑤进程 $ who; whoami  多个命令同时运行  $ <em>命令</em>&amp; 后台运行  </p><p>$ ps 显示当前运行的进程       $ kill 终止某个进程</p><p>$ nohup command 注销后仍将运行     $ at hh:mm 定时运行某些命令</p><p>⑥设置shell内部变量值  $ PS1&#x3D;C:\&gt;      $ PS1&#x3D;’<code>whoami</code>:<code>pwd</code> &gt;’</p><p>$ echo $HOME      $ echo $PATH      $ PATH&#x3D;$PATH:$HOME&#x2F;bin</p><p>$ d&#x3D;&#x2F;home&#x2F;lls&#x2F;c        $ cd $d</p><p><strong>三：文件系统</strong></p><p><strong>1.</strong> 文件类型      ① 目录文件：包含其它文件的文件。  ② 常规文件：文本文件、二进制文件（程序、数据库等）。    ③设备文件：键盘、显示器、打印机、硬盘等。</p><p>查看文件类型$ls -l ; 分析文件结构$od -x </p><p><strong>2.</strong> 绝对路径：从根目录出发到某个文件的搜索路径。如：&#x2F;home&#x2F;user1&#x2F;myc&#x2F;p1.c</p><p>相对路径：从当前目录出发到某个文件的搜索路径。如：myc&#x2F;p1.c,  .&#x2F;bin&#x2F;prog1, ..&#x2F;user2&#x2F;file1</p><p><strong>3.</strong> 文件权限</p><p>$ ls –l a.out</p><p> -rwxr-xr-x 1 user1 users 9319 2010-02-09 23:56 a.out</p><p>rwx：读、写、运行</p><p>9个权限位，每3个为一组，分别代表文件所有者、同组用户和其他用户的权限。</p><p>更改文件权限chmod     $ chmod 777 a.out   $ chmod –w a.out</p><p>目录文件权限x： 是否可以存取目录中的文件。 r： 是否可以对目录进行文件列表。可以存取已知的文件。 w：是否可以增加、删除目录中的文件。</p><p><strong>4</strong>. 文件的组成：文件名、i节点、文件内容。i节点中记录文件权限、所有者、修改日期、长度、存放位置等等。<img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" alt="img"></p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><p>$ ln file1 file2 &#x2F;&#x2F;给file1所对应的i节点增加一个文件名file2</p><p>$ rm file2 &#x2F;&#x2F;删除文件名file2。对应的i节点和文件内容依然存在。</p><p>$ rm file1 &#x2F;&#x2F;删除文件名file1。由于没有文件名指向该i节点，系统删除该i节点及其对应的文件内容</p><p><strong>5.</strong> 设备文件</p><p>UNIX的精华思想之一就是在文件系统中处理外部设备，按普通文件来处理外设。</p><p>$ ls -l &#x2F;dev          $ echo hello! &gt; &#x2F;dev&#x2F;pts&#x2F;0</p><p>$ cat c&#x2F;sig.c &gt;&#x2F;dev&#x2F;pts&#x2F;1       $ cp tmp &#x2F;dev&#x2F;pts&#x2F;0</p><p><strong>四：流编辑器sed</strong></p><p><strong>1.</strong>$ sed ‘s&#x2F;UNIX&#x2F;Linux&#x2F;g’ file  将file中的UNIX替换成Linux显示在屏幕上，但不改变file本身。</p><p>$ who | sed ‘s&#x2F; .*&#x2F;&#x2F;‘ 显示当前登录用户，只显示用户名。</p><p>$ who am i |sed ‘s&#x2F; .*&#x2F;&#x2F;‘ 获取我的登录名. </p><p>$ sed ‘10q’ file   显示file文件的前10行</p><p>$ sed ‘&#x2F;pattern&#x2F;d’ file   不显示包含pattern的行。</p><p>$ sed -n ‘&#x2F;pattern&#x2F;p’ file 仅显示包含pattern的行。sed默认显示每一行，-n选项关闭自动显示功能。 sed -n ‘&#x2F;pattern&#x2F;p’ file具有过滤功能，与grep pattern file功能相同。</p><p>$ ls -l | sed -n ‘&#x2F;^d&#x2F;p’ 长格式列出当前目录下的子目录</p><p>$ ls -l | sed -n ‘&#x2F;^d&#x2F;p’|sed ‘s&#x2F;.* &#x2F;&#x2F;‘ 列出当前目录下的子目录</p><p>sed的局限性 由于sed处理的是输入流，一旦读入一行，前面的行就过去了，无法再次取回，因此sed不具备行运算的能力。例如 $ sed ‘$-1d’ 是非法的</p><p><strong>2.</strong> <strong>过滤器</strong>grep，fgrep，egrep</p><p>$ grep pattern file  pattern: ed pattern</p><p>$ grep ‘^void’ sig.c 显示sig.c文件中以void开头的行</p><p>$ ls -l | grep ‘^d’  列出当前目录下的子目录</p><p>$ ls -l | grep ‘^d’ | sed ‘s&#x2F;.* &#x2F;&#x2F;‘ 列出当前子目录名</p><p>fgrep功能较弱，但处理大文件的能力强，egrep使用扩展正则表达式，功能强大。</p><p><strong>3.</strong> sort—-排序</p><p>$ ls | sort</p><p><strong>4.</strong> tail、head</p><p>$ tail file 显示file的最后10行</p><p>$ tail -5 file 显示file的最后5行 </p><p>$ head file 显示file的前10行</p><p>$ head -5 file 显示file的前5行</p><p><strong>五：模式匹配与处理语言awk</strong></p><p>一般使用形式：</p><p>$ awk ‘program’ filename</p><p>$ commd | awk ‘program ‘</p><p>program的形式</p><p>pattern1 {action1} pattern2{action2}……</p><p>pattern: ed的正则表达式，逻辑表达式</p><p>action：如print、printf等</p><p>缺省</p><p>$ awk ‘&#x2F;pattern&#x2F;‘ file 显示匹配模式的每一行，功能同grep</p><p>$ awk ‘{print}’ 显示每一行，功能同cat</p><p>记录、字段</p><p>每一行为一条记录，NR为记录数</p><p>每一个非空的字符串为一个字段，使用$1、$2、…标记，$0为整行，NF为字段数</p><p>$ awk ‘{print NR, $0}’ file 显示file，并在行首加上行号</p><p>$ ls –l | awk ‘ &#x2F;^d&#x2F;{print}’ 长格式列出当前目录下的子目录</p><p>$ ls –l | awk ‘ &#x2F;^d&#x2F;{print $8}’ 列出当前目录下的子目录</p><p>打印（显示）</p><p>$ ls –l | awk ‘{print NR, “: “ $1, $8}’</p><p>$ awk ‘{printf(“%d: %s\n”, NR, $0)} ‘ sig.c</p><p>pattern</p><p>字段运算、模式表达式、逻辑表达式</p><p>$ ls –l | awk ‘$5~&#x2F;…..*&#x2F;‘ 列出长度超过999字节的文件</p><p>$ ls –l | awk ‘$5 !~ &#x2F;…..*&#x2F;‘ 列出长度小于等于999字节的文件</p><p>$ ls –l | awk ‘$5&#x3D;&#x3D;”4096”‘ 列出长度为4096字节的文件</p><p>$ ls –l | awk ‘length($5)&gt;3’ 列出长度超过999字节的文件</p><p>$ ls –l | awk ‘!(length($5)&gt;3) ‘ 列出长度小于等于999字节的文件</p><p>特殊pattern</p><p>awk ‘BEGIN{初始化动作}’</p><p>awk ‘END{结束动作}’</p><p>变量和运算</p><p>举例：打印某个文件的行数、单词数和字符数</p><p>$ awk ‘{</p><p>nw +&#x3D; NF</p><p>nc +&#x3D;length($0)+1</p><p>}</p><p>END{</p><p>print NR, nw,nc</p><p>}’ sig.c   &#x2F;&#x2F;这段程序的功能与wc命令的功能完全一样。</p><p>流程控制</p><p>寻找文件中相同的相邻单词</p><p>$ awk ‘NF&gt;0{</p><p>  if ($1&#x3D;&#x3D;lastword)</p><p>   printf(“double %s, line %d:\n%s\n”, $1,NR,$0)</p><p>  for (i&#x3D;2; i&lt;&#x3D;NF; i++)</p><p>​    if ($i&#x3D;&#x3D;$(i-1))</p><p>​     printf(“double %s, line %d:\n%s\n”, $i,NR,$0)</p><p>  lastword&#x3D;$NF</p><p>} ‘ tmp</p><p>流程控制（二）</p><p>while语句</p><p>while (condition){</p><p>  statement1</p><p>  statement2</p><p>  …</p><p>  }</p><p>break:跳出循环</p><p>continue:下一个循环</p><p>next:下一条记录，回到awk程序开始</p><p>exit:跳转至END模式或结束</p><p>内部变量（部分）</p><p>FILENAME 当前输入文件名</p><p>RS  输入记录的分割符（默认为换行符）</p><p>FS  输入字段的分隔符（默认为空格、制表符）</p><p>NF  当前记录的字段数</p><p>NR  当前记录数</p><p>OFS  输出字段的分隔符（默认为空格）</p><p>ORS 输出记录的分隔符（默认为换行）</p><p>内部函数（部分）</p><p>cos(expr) 求余弦</p><p>exp(expr) 求自然指数</p><p>index(s1,s2)  是否字符串s2位于s1中</p><p>int(expr)     取整</p><p>length(s)  求字符串长度</p><p>log(expr)  求自然对数</p><p>sin(expr)  求正玄</p><p>split(s, a, c) 按分隔符c将s放入a[1],a[2],…中</p><p>substr(s,m,n) 求s的子串，从第m个字符开始，共n个字符。</p><p>数组</p><p>$ awk ‘{line[NR] &#x3D; $0}</p><p>​     END{</p><p>​        # do what you want</p><p>​        for (i&#x3D;1; i&lt;&#x3D;NR; i++) print line[i]</p><p>​        } ‘</p><p>流处理程序的约定，当给定文件名时，数据从文件中读取，否则从标准输入读取。这样便于管道和重定向的使用。</p><p>***awk******用于格式化报文或者从文件中抽取数据包***<strong>．</strong><br> 　1.$awk ‘{print $0}’ gefforey.txt | tee gefforey.doc<br> 该命令将在屏幕输出gefforey.txt文件内容并将其内容复制到gefforey.doc文件中．<br> 　2.$awk -F: ‘{print $1}’ gefforey.log<br> 该命令以:为单位读取gefforey.log文件中第一列内容．<br> 　３.$awk ‘BEGIN {print “Name  Belt\n————“} {print $1”\t”$3}’ gefforey.txt<br> 该命令将在屏幕首先输出”Name  Belt”，第二行输出”————“，并在输出文件内容的时候，每列之间间隔一个TAB位．可以在print语句之后加上END {print “end of output”}，那么将会在文件内容输出结束的时候打印”end of output”．<br>    4.$awk ‘$2 ~ &#x2F;^baidu$&#x2F; {print $0}’ gefforey.txt<br> 该命令显示gefforey.txt文件中以空格分隔的第二列字符串是”baidu”的所有行．<br> 　5.$awk ‘{if($2 ~ &#x2F;^baidu$&#x2F;) print $0}’ gefforey.txt<br> 该命令判断如果某行第二列字符串为”baidu”,则打印出该行．<br>    6.$awk ‘{if($2 &lt; $3) print $0}’ gefforey.txt<br> 该命令显示判断如果某行第二列值小于第三列值，则打印该行．awk的条件操作符有：<br> &lt; 小于，&gt; &#x3D; 大于等于，&lt; &#x3D; 小于等于，~ 匹配正则表达式，&#x3D; &#x3D; 等于，!~ 不匹配正则表达式，!&#x3D; 不等于<br> 　7.$awk ‘{if($2 &#x3D;&#x3D;”google1” &amp;&amp; $3&#x3D;&#x3D;”google2”) print $0}’ gefforey.txt<br> 该命令判断如果某行第二列值为”google1”并且第三列值为”google2”，则打印出该行．awk的逻辑表达式有：&amp;&amp; AND，|| O R，! 非．<br> 　8.$awk ‘{print NF,NR,$0} END{print FILENAME}’ gefforey.txt<br> 该命令会输出浏览记录的域个数和已读的记录数，并在输出结尾打印文件名．</p><p><strong>六：vi编辑器</strong></p><p>由BSD UNIX的作者Bill Joy编写</p><p>分两种工作模式：命令模式、编辑模式。a、i、o、O命令进入编辑模式，ESC退出编辑模式。</p><p>在命令模式下，可使用所有的ed命令。</p><p>退出：按住esc+shift+； 然后输入wq</p><p><strong>七：图形界面系统管理</strong></p><p>**1.**X server</p><p>处理输出</p><p>接受X client的输出请求，驱动硬件显示</p><p>处理输入</p><p>接受键盘、鼠标的输入，当作“事件”传送给适当的客户程序。</p><p>窗口管理器</p><p>一个特殊的X客户程序，具有改变窗口大小、位置、堆放层次等功能。</p><p>桌面系统</p><p>另一个特殊的X客户程序，依赖窗口管理器，控制桌面、菜单的位置、风格、效果等。</p><p>\2. X 协议 ： X 系统采用客户-服务器模型，带来如下优点</p><p>X server屏蔽了硬件特性，使得X client和X server之间的X协议是一个完全抽象的协议，具有很强的可移植性</p><p>将X协议构建在网络协议之上，X server和X client可以运行在不同的机器上，这带来了很大的灵活性。</p><p>**3.**提示</p><p>当用户使用X协议登录远程计算机时，本地运行的是X server，远程计算机运行的应用程序是X client。</p><p><strong>4.</strong> X 开发接口</p><p>X Library</p><p>最底层的程序界面，主要功能是存取X protocol的服务</p><p>常见的有：Xlib、Motif、Qt</p><p>X Toolkit</p><p>X Library基础上的拓展，提供大量函数或组件。</p><p>种类很多，有Motif、OpenLook、Gimp、X foums、X Toolkit（Xt）等</p><p><strong>5.</strong> 激活超级用户（root）（非必须）</p><p>为了安全，Ubuntu Linux默认禁用root用户。使用sudo命令可以提升权限，只是有些麻烦。</p><p>$ sudo vi &#x2F;etc&#x2F;gdm&#x2F;gdm.conf    将其中一行“AllowRoot&#x3D;false”改为“AllowRoot&#x3D;true”  &#x2F;&#x2F;也可以通过主菜单“系统”-&gt;“系统管理”-&gt;“登录窗口”进入“登录窗口首选项”，在“安全”选项页中选中“允许本地系统管理员登录”。</p><p>$ sudo passwd root 更改root用户口令  重启系统</p><p><strong>6.</strong> 网络配置</p><p>IP地址、子网掩码、默认网关</p><p># vi &#x2F;etc&#x2F;network&#x2F;interfaces</p><p>auto eth0</p><p>iface eth0 inet static  # or dhcp</p><p>address xxx.xxx.xxx.xxx</p><p>netmask xxx.xxx.xxx.xxx</p><p>gateway xxx.xxx.xxx.xxx</p><p>域名服务器DNS</p><p># vi &#x2F;etc&#x2F;resolv.conf</p><p># Generated by NetworkManager</p><p>nameserver xxx.xxx.xxx.xxx  &#x2F;&#x2F;add it</p><p>nameserver xxx.xxx.xxx.xxx</p><p>……</p><p># &#x2F;etc&#x2F;init.d&#x2F;networking restart  重启网络，配置生效。可使用ifconfig、route等命令查看配置结果。</p><p><strong>7.</strong> 创建WebServer</p><p># apt-get install apache2</p><p><a href="http://xxx.xxx.xxx.xxx/">http://xxx.xxx.xxx.xxx</a>(Ubuntu Host IP Address)</p><p>共享文件（网络邻居）</p><p># apt-get install samba</p><p>建一个共享文件夹，设权限为777，在文件管理器中使用鼠标右键共享之。</p><p><strong>8.</strong> 用户帐号管理     命令 useradd、adduser、userdel、usermod、passwd</p><p>使用图形界面   增、删、改、查。     修改用户密码、权限。</p><p>组管理    命令 groupadd、addgroup、groupdel、groupmod、gpasswd</p><p>使用图形界面    增、删、改、查。    修改组权限、成员。</p><p><strong>9.</strong> 系统数据文件 &#x2F;etc&#x2F;passwd        &#x2F;etc&#x2F;shadow</p><p>&#x2F;etc&#x2F;group &#x2F;&#x2F;都是文本文件，不要随意修改。</p><p><strong>10.</strong> 磁盘管理概述</p><p>磁盘包括软盘、光盘、硬盘。设备文件分别为：&#x2F;dev&#x2F;fd[01]、&#x2F;dev&#x2F;hd[abcd]（IDE硬盘）、&#x2F;dev&#x2F;sd[abcd]（SCSI硬盘）、&#x2F;dev&#x2F;cdrom</p><p>硬盘必须分区和格式化才可使用。硬盘分区后，每个分区对应的设备名为“硬盘设备名”[1256]，例如&#x2F;dev&#x2F;sda1代表第一块SCSI硬盘的第一个分区。</p><p>硬盘分区：一块硬盘最多可分4个分区，需要分更多的区时，可分一个扩展分区，然后将扩展分区再分为若干逻辑分区。</p><p>管理硬盘分区的命令为fdisk。例如 </p><p># fdisk &#x2F;dev&#x2F;sdb &#x2F;&#x2F;对第二快SCSI硬盘进行分区管理</p><p>格式化分区（创建文件系统）</p><p># mkfs 分区名  &#x2F;&#x2F;分区名：如&#x2F;dev&#x2F;sdb1</p><p># mkfs -t msdos 分区名  &#x2F;&#x2F;指定文件格式，默认文件格式为ext2</p><p>使用文件系统</p><p># mount 分区名 路径 &#x2F;&#x2F;将某硬盘分区挂载到某个目录下，通常该目录为空目录</p><p>卸载文件系统    # umount 分区名或路径 &#x2F;&#x2F;将某硬盘分区和挂载点脱钩</p><p>查看分区挂载情况    # df</p><p><strong>11.</strong> 查看进程</p><p>$ ps &#x2F;&#x2F;查看当前终端启动的进程    $ ps -t 终端名 &#x2F;&#x2F;显示某个终端启动的进程</p><p>$ ps -u 用户名 &#x2F;&#x2F;显示某个用户启动的进程</p><p>$ ps -e      &#x2F;&#x2F;显示所有进程   $ ps -f       &#x2F;&#x2F;显示进程完整信息</p><p>$ ps –ef |grep ‘pattern’ &#x2F;&#x2F;显示你想看到的进程</p><p>结束进程：kill命令语法 kill [-signal] pid  &#x2F;&#x2F;kill命令用来给一个进程发信号，但常用的功能是结束某个进程（发一个可以结束某个进程的信号）。</p><p>kill -l &#x2F;&#x2F;列出可用的信号选项</p><p>例$ .&#x2F;sig</p><p>$ kill -2 pid</p><p>$ kill -14 pid</p><p>$ kill -9 pid     </p><p><strong>八： shell编程</strong></p><p>**1.**将一些有用的命令组合变成实用工具</p><p>ls -l | sed -n ‘&#x2F;^d&#x2F;p’  &#x2F;&#x2F;显示当前目录下的子目录</p><p>$ vi lsdir</p><p>$ sh lsdir</p><p>$ chmod +x lsdir</p><p>$ PATH&#x3D;$HOME&#x2F;bin:$PATH</p><p><strong>2.</strong> 快速编写一些实用的软件</p><p>$ vi mycat</p><p>awk ‘{print NR,“: ”,$0}’ $1  &#x2F;&#x2F;$1 为shell命令的第1个参数</p><p>$ chmod +x mycat</p><p>$ mycat file1</p><p><strong>3.</strong> 位置参数</p><p>测试位置参数</p><p>$ vi test</p><p>echo $0 $1 $2 $3 $4</p><p>$ sh test a1 a2 a3</p><p>   test a1 a2 a3</p><p>位置参数重置</p><p>$ vi test</p><p>echo $0 $1 $2 $3 $4</p><p>set b1 b2</p><p>echo $0 $1 $2 $3 $4</p><p>$ sh test a1 a2 a3</p><p> test a1 a2 a3</p><p> test b1 b2</p><p>\1) set命令可以重置位置参数；2）参数$0是命令名，不可重置；3）set命令重置除$0外所有参数</p><p>位置参数的移动</p><p>$ cat test</p><p>echo $0 $1 $2 $3 $4 $5 $6 $7 $8</p><p>shift</p><p>echo $0 $1 $2 $3 $4 $5 $6 $7 $8</p><p>shift 2</p><p>echo $0 $1 $2 $3 $4 $5 $6 $7 $8</p><p>shift命令可以左移位置参数，但不可移动参数$0</p><p><strong>4.</strong> shell命令行结构</p><p>单个命令$ who      $ date  多个命令$ who; date       $ who; date |wc</p><p>$ (who; date )|wc       $ (who; date)|tee save |wc</p><p>后台命令$ (sleep 5; date)&amp;       $ (sleep 5; date)&amp; who</p><p>命令行特殊符号 &gt; &lt; &gt;&gt; &lt;&lt; ; &amp;      转义 $ echo &gt;</p><p>**5.**命令行模式</p><p>$ echo *      转义 $ echo *</p><p>单引号 $ echo ‘*’ &#x2F;&#x2F;取消所有特殊字符的含义</p><p>双引号 $ echo “*” &#x2F;&#x2F;除$`&#96;外，取消其它特殊字符的含义</p><p><strong>6</strong>. shell元字符集</p><p>&gt;  prog&gt;file标准输出重定向</p><p>&gt;&gt; prog&gt;&gt;file标准输出重定向（添加）</p><p>&lt;  prog&lt;file标准输入重定向</p><p>&lt;&lt;str 即时文件读入，直到str结束</p><p>|   p1|p2  p1的标准输出连接到p2的标准输入</p><p>*   匹配文件名中任意字符串</p><p>?   匹配文件名中任意单个字符</p><p>[ccc] 匹配文件名中单个ccc中的字符。ccc可以指定范围，如0-9，a-z等</p><p>; 命令结束符。p1;p2，先执行p1，再执行p2</p><p>&amp; 后台命令结束符。不等命令结束，立即接受新的命令</p><pre class="line-numbers language-none"><code class="language-none">…&#96;  执行命令…，用执行后的标准输出代替…  例如$ echo &#96;date<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(…)  在子shell里运行括号里的命令</p><p>$1, $2, …  位置参数</p><p>$var  引用变量var的值</p><p>${var} 同上，在可能引起歧义时，使用{}将变量名括起来。</p><p>\  转义，取消字符的特殊含义</p><p>‘…’ 单引号，字符串，对…中的特殊字符不作解释</p><p>“…” 双引号，字符串，对…中的特殊字符仅解释$`&#96;</p><p>#  注释。从#开始至行尾为注释</p><p>var&#x3D;value 对变量var赋值</p><p>P1 &amp;&amp; p2  运行p1，若成功，运行p2</p><p>P1 || p2   运行p1，若不成功，运行p2</p><p><strong>7.</strong> 引号（单引号、双引号、反引号）</p><p>$ echo don’t do that</p><p>$ echo “don’t do that”</p><p>$ echo “don’t do that, $0”</p><p>$ echo “don’t do that, $0, <code>date</code>“</p><p>$ echo “don’t do that, $0, `date`“</p><p>$ echo ‘don’t do that, $0, <code>date</code>‘</p><p><strong>8.</strong> 重定向</p><p>每个程序启动时自动打开三个文件：标准输入、标准输出和标准错误输出文件，文件描述符分别为0、1、2.</p><p>&gt;和&gt;&gt;将标准输出定向为一个文件，如$who &gt;ttt</p><p>&lt;将标准输出定向为一个文件，如$cat&lt;ttt</p><p>如何重定向标准错误输出？</p><p>$ gcc sig.c &gt;ttt  &#x2F;&#x2F;cat ttt?</p><p>$ gcc sig.c 2&gt;ttt &#x2F;&#x2F;cat ttt?</p><p>$ gcc sig.c &gt;ttt 2&gt;&amp;1 &#x2F;&#x2F;cat ttt?</p><p><strong>9.</strong> &lt;&lt;的用途</p><p>&lt;&lt;定义及时文件的结束符，用于在shell程序中创建文件。</p><p>如下shell程序创建一个文件</p><p>$ cat mkafile</p><p>cat &gt;$1 &lt;&lt;end</p><p>hello world!</p><p>end</p><p>$ sh mkafile ttt</p><p>$ cat ttt</p><p>hello world!</p><p><strong>10</strong>. shell程序的结构</p><p>①if命令</p><p>结构</p><p>if list   #list:命令序列</p><p>then</p><p>  list</p><p>[elif list then list]</p><p>[else list]</p><p>fi</p><p>例1，if list中最后一个命令的返回值</p><p>if gcc &#x2F;home&#x2F;lls&#x2F;c&#x2F;sig.c</p><p>#who</p><p>then</p><p>  echo program is ok!</p><p>else</p><p>  echo bad program</p><p>fi</p><p>例2，判断参数个数cargus</p><p>if test $# -eq 5  &#x2F;&#x2F;$#为shell内部变量，代表参数个数</p><p>then</p><p>  echo there are 5 argus</p><p>elif test $# -gt 5</p><p>then</p><p>  echo more than 5 argus</p><p>else</p><p>  echo less than 5 argus</p><p>fi</p><p>②test命令</p><p>常用于if、while、until命令中的条件判断</p><p>功能：判断文件类型或表达式是否为真</p><p>test –option file模式</p><p>test -e file  &#x2F;&#x2F;文件存在</p><p>test –b file  &#x2F;&#x2F;文件存在且为块设备文件</p><p>test –c file  &#x2F;&#x2F;文件存在且为字符设备文件</p><p>test –d file  &#x2F;&#x2F;文件存在且为目录文件</p><p>test –f file  &#x2F;&#x2F;文件存在且为普通文件</p><p>test expression模式</p><p>test e1  &#x2F;&#x2F;e1为真</p><p>test ! e1  &#x2F;&#x2F;e1为假</p><p>test e1 –a e2  &#x2F;&#x2F;e1,e2都为真</p><p>test e1 –o e2  &#x2F;&#x2F;e1或e2为真</p><p>test f1 –nt f2  &#x2F;&#x2F;文件f1比文件f2新</p><p>test f1 –ot f2  &#x2F;&#x2F;文件f1比文件f2旧</p><p>test –option string模式</p><p>test –n str &#x2F;&#x2F;字符串str非空</p><p>test –z str &#x2F;&#x2F;字符串str为空</p><p>③case命令</p><p>尽量使用case来代替if</p><p>结构</p><p>case word in</p><p>pattern1) list1;;</p><p>pattern2) list2;;</p><p>…</p><p>esac</p><p>例 cargus</p><p>case $# in</p><ol start="5"><li></li></ol><p>  echo there are 5 argus;;</p><p>[0-4])</p><p>  echo less than 5 argus;;</p><p>*)</p><p>  echo more than 5 argus</p><p>esac</p><p>例 显示某c文件的前6行</p><p>case $# in</p><ol start="0"><li></li></ol><p>  echo usage: ccat file</p><p>  exit 1;;</p><p>esac</p><p>case $1 in</p><p>*.c)</p><p>  echo c file: $1</p><p>  head -6 $1;;</p><p>*)</p><p>  echo the file must be c file</p><p>esac</p><p>④for命令</p><p>结构一</p><p>for variable in 某个集合  &#x2F;&#x2F;集合中元素的个数决定循环的次数</p><p>do</p><p>   list</p><p>done</p><p>例 显示所有命令行参数</p><p>for i in $*</p><p>do</p><p> echo $i</p><p>done</p><p>echo there are $# argus</p><p>结构二   &#x2F;&#x2F;仅bash</p><p>for ((e1;e2;e3))</p><p>do</p><p>  list</p><p>done</p><p>如：</p><p>for ((i&#x3D;0; i&lt;maxnum; i++))</p><p>do</p><p>  ……</p><p>done</p><p>例 倒序显示命令行参数</p><p>j&#x3D;0</p><p>for i in $*</p><p>do</p><p> a[j]&#x3D;$i</p><p> let j&#x3D;$j+1</p><p>done</p><p>for ((i&#x3D;$#-1; i&gt;&#x3D;0; i–))</p><p>do</p><p> echo ${a[i]}</p><p>done</p><p>⑤shell内部变量</p><p>$# 命令行参数个数</p><p>$*  命令行参数集合</p><p>$@ 命令行参数集合 &#x2F;&#x2F;与$*有细微差别</p><p>$?  最后一条命令的返回值</p><p>$$ 当前shell的进程号</p><p>$!  最后一个后台命令的进程号</p><p>$HOME $PATH $PS1 $PS2</p><p>⑥while、until命令</p><p>while命令结构</p><p>while</p><p>  list</p><p>do</p><p>  list</p><p>done</p><p>until命令结构</p><p>until</p><p>  list</p><p>do</p><p>  list</p><p>done</p><p>⑦其它命令</p><p>break 跳出循环</p><p>continue 下一个循环</p><p>exit n 终止shell程序，n为返回值</p><p>trap 设置中断处理命令。例如：</p><p>trap ‘rm –f tmpfile; exit 1’ 1 2 15</p><p>shell编程的优点：充分利用现有资源，快捷</p><p>shell程序的缺点：功能有限，代码不易读，可移植性差</p><p>shell本身是一个普通用户的接口，能提供如此编程环境已经不易。</p><p><strong>变量赋值和引用</strong></p><p>Shell编程中，使用变量无需事先声明，同时变量名的命名须遵循如下规则：</p><p>\1.  首个字符必须为字母（a-z，A-Z） 或者_</p><p>\2.  中间不能有空格，可以使用下划线（_）</p><p>\3.  不能使用其他标点符号</p><p>需要给变量赋值时，可以这么写：</p><p>变量名&#x3D;值 </p><p>要取用一个变量的值，只需在变量名前面加一个$ ( 注意: 给变量赋值的时候，不能在”&#x3D;”两边留空格 )</p><p>#!&#x2F;bin&#x2F;bash</p><p># 对变量赋值：</p><p>a&#x3D;”hello world” #等号两边均不能有空格存在</p><p># 打印变量a的值：</p><p>echo “A is:” $a</p><p>挑个自己喜欢的编辑器，输入上述内容，并保存为文件first，然后执行 chmod +x first 使其可执行，最后输入 .&#x2F;first 执行该脚本。其输出结果如下： </p><p>A is: hello world</p><p>有时候变量名可能会和其它文字混淆，比如：</p><p>num&#x3D;2</p><p>echo “this is the $numnd”</p><p>上述脚本并不会输出”this is the 2nd”而是”this is the “；这是由于shell会去搜索变量numnd的值，而实际上这个变量此时并没有值。这时，我们可以用花括号来告诉shell要打印的是num变量：</p><p>num&#x3D;2</p><p>echo “this is the ${num}nd”</p><p>其输出结果为：this is the 2nd</p><p> 注意花括号的位置：</p><p>num&#x3D;2</p><p>echo “this is the {$num}nd”</p><p>其输出结果为：this is the {2}nd</p><p> 需要注意shell的默认赋值是字符串赋值。比如：</p><p>var&#x3D;1</p><p>var&#x3D;$var+1</p><p>echo $var</p><p>打印出来的不是2而是1＋1。为了达到我们想要的效果有以下几种表达方式：</p><p>let “var+&#x3D;1”</p><p>var&#x3D;”$[$var+1]”</p><p>((var++))</p><p>var&#x3D;$(($var+1))</p><p>var&#x3D;”$(expr “$var” + 1)” #不建议使用</p><p>var&#x3D;”<code>expr &quot;$var&quot; + 1</code>“ #强烈不建议使用，注意加号两边的空格，否则还是按照字符串的方式赋值,<code>为Esc下方的</code>，而不是单引号’。</p><p>注意：前2种方式在bash下有效，在sh下会出错。</p><p>let表示数学运算，expr用于整数值运算，每一项用空格隔开，$[]将中括号内的表达式作为数学运算先计算结果再输出。</p><p>Shell脚本中有许多变量是系统自动设定的，我们将在用到这些变量时再作说明。除了只在脚本内有效的普通shell变量外，还有环境变量，即那些由export关键字处理过的变量。本文不讨论环境变量，因为它们一般只在登录脚本中用到。</p><p><strong>Shell****里的流程控制</strong></p><p><strong>if</strong> <strong>语</strong> <strong>句</strong></p><p>“if”表达式如果条件为真，则执行then后的部分:</p><p>if ….; then</p><p> ….</p><p>elif ….; then</p><p> ….</p><p>else</p><p> ….</p><p>fi</p><p>大多数情况下，可以使用测试命令来对条件进行测试，比如可以比较字符串、判断文件是否存在及是否可读等等……通常用” [ ] “来表示条件测试，注意这里的空格很重要，要确保方括号前后的空格。</p><p><strong>[ -f “somefile” ]</strong> <strong>：判断是否是一个文件</strong></p><p><strong>[ -x “&#x2F;bin&#x2F;ls” ]</strong> <strong>：判断</strong><strong>&#x2F;bin&#x2F;ls****是否存在并有可执行权限</strong></p><p><strong>[ -n “$var” ]</strong> <strong>：判断</strong><strong>$var****变量是否有值</strong></p><p><strong>[ “$a” &#x3D; “$b” ]</strong> <strong>：判断</strong><strong>$a**<strong>和</strong></strong>$b**<strong>是否相等</strong></p><p>执行man test可以查看所有测试表达式可以比较和判断的类型。下面是一个简单的if语句：</p><p>#!&#x2F;bin&#x2F;bash</p><p>if [ ${SHELL} &#x3D; “&#x2F;bin&#x2F;bash” ]; then</p><p>  echo “your login shell is the bash (bourne again shell)”</p><p>else</p><p>  echo “your login shell is not bash but ${SHELL}”</p><p>fi</p><p>变量$SHELL包含有登录shell的名称，我们拿它和&#x2F;bin&#x2F;bash进行比较以判断当前使用的shell是否为bash。</p><p><strong>&amp;&amp;</strong> <strong>和</strong> <strong>||</strong> <strong>操作符</strong></p><p>熟悉C语言的朋友可能会喜欢下面的表达式：</p><p>[ -f “&#x2F;etc&#x2F;shadow” ] &amp;&amp; echo “This computer uses shadow passwords”</p><p>这里的 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句，你也可以把它看作逻辑运算里的与操作。上述脚本表示如果&#x2F;etc&#x2F;shadow文件存在，则打印“This computer uses shadow passwords”。同样shell编程中还可以用或操作(||)，例如：</p><p>#!&#x2F;bin&#x2F;bash</p><p>mailfolder&#x3D;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;james</p><p>[ -r “$mailfolder” ] || { echo “Can not read $mailfolder” ; exit 1; }</p><p>echo “$mailfolder has mail from:”</p><p>grep “^From “ $mailfolder</p><p>该脚本首先判断mailfolder是否可读，如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。需要注意的是，这里我们必须使用如下两个命令：</p><p>-打印错误信息</p><p>-退出程序</p><p>我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用；普通函数稍后再作说明。即使不用与和或操作符，我们也可以用if表达式完成任何事情，但是使用与或操作符会更便利很多 。</p><p><strong>case</strong> <strong>语句</strong></p><p>case表达式可以用来匹配一个给定的字符串，而不是数字（可别和C语言里的switch…case混淆）。</p><p>case … in</p><p>  …) do something here </p><p>  ;;</p><p>esac</p><p>file命令可以辨别出一个给定文件的文件类型，如：file lf.gz，其输出结果为：</p><p>lf.gz: gzip compressed data, deflated, original filename,</p><p>last modified: Mon Aug 27 23:09:18 2001, os: Unix</p><p>我们利用这点写了一个名为smartzip的脚本，该脚本可以自动解压bzip2, gzip和zip 类型的压缩文件：</p><p> #!&#x2F;bin&#x2F;bash</p><p> ftype&#x3D;”$(file “$1”)”</p><p> case “$ftype” in</p><p> “$1: Zip archive”*)</p><p>  unzip “$1” ;;</p><p> “$1: gzip compressed”*)</p><p>  gunzip “$1” ;;</p><p> “$1: bzip2 compressed”*)</p><p>  bunzip2 “$1” ;;</p><p> *) echo “File $1 can not be uncompressed with smartzip”;;</p><p> esac</p><p>你可能注意到上面使用了一个特殊变量$1，该变量包含有传递给该脚本的第一个参数值。也就是说，当我们运行：</p><p>smartzip articles.zip</p><p>$1 就是字符串 articles.zip。</p><p><strong>select</strong> <strong>语句</strong></p><p>select表达式是bash的一种扩展应用，擅长于交互式场合。用户可以从一组不同的值中进行选择：</p><p>select var in … ; do</p><p>　break;</p><p>done</p><p>…. now $var can be used ….</p><p>下面是一个简单的示例：</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo “What is your favourite OS?”</p><p>select var in “Linux” “Gnu Hurd” “Free BSD” “Other”; do</p><p> break;</p><p>done</p><p>echo “You have selected $var”</p><p>该脚本的运行结果如下：</p><p>What is your favourite OS?</p><p>\1) Linux</p><p>\2) Gnu Hurd</p><p>\3) Free BSD</p><p>\4) Other</p><p>#? 1</p><p>You have selected Linux</p><p><strong>while&#x2F;for</strong> <strong>循环</strong></p><p>在shell中，可以使用如下循环：</p><p>while …; do</p><p>  ….</p><p>done</p><p>只要测试表达式条件为真，则while循环将一直运行。关键字”break”用来跳出循环，而关键字”continue”则可以跳过一个循环的余下部分，直接跳到下一次循环中。</p><p>for循环会查看一个字符串列表（字符串用空格分隔），并将其赋给一个变量：</p><p>for var in ….; do</p><p>  ….</p><p>done</p><p>下面的示例会把A B C分别打印到屏幕上：</p><p>#!&#x2F;bin&#x2F;bash</p><p>for var in A B C ; do</p><p>  echo “var is $var”</p><p>done</p><p>下面是一个实用的脚本showrpm，其功能是打印一些RPM包的统计信息：</p><p>#!&#x2F;bin&#x2F;bash</p><p># list a content summary of a number of RPM packages</p><p># USAGE: showrpm rpmfile1 rpmfile2 …</p><p># EXAMPLE: showrpm &#x2F;cdrom&#x2F;RedHat&#x2F;RPMS&#x2F;*.rpm</p><p>for rpmpackage in “$@”; do</p><p>  if [ -r “$rpmpackage” ];then</p><p>   echo “&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; $rpmpackage &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”</p><p>   rpm -qi -p $rpmpackage</p><p>  else</p><p>   echo “ERROR: cannot read file $rpmpackage”</p><p>  fi</p><p>done</p><p>这里出现了第二个特殊变量$@，该变量包含有输入的所有命令行参数值。如果你运行showrpm openssh.rpm w3m.rpm webgrep.rpm，那么 “$@”(有引号) 就包含有 3 个字符串，即openssh.rpm, w3m.rpm和 webgrep.rpm。$*的意思是差不多的。但是只有一个字串。如果不加引号，带空格的参数会被截断。</p><p><strong>Shell****里的一些特殊符号</strong></p><p><strong>引号</strong></p><p>在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓的扩展是指程序会把通配符（比如*）替换成适当的文件名，把变量替换成变量值。我们可以使用引号来防止这种扩展，先来看一个例子，假设在当前目录下有两个jpg文件：mail.jpg和tux.jpg。</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo *.jpg</p><p>运行结果为：</p><p>mail.jpg tux.jpg</p><p>引号（单引号和双引号）可以防止通配符*的扩展：</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo “*.jpg”</p><p>echo ‘*.jpg’</p><p>其运行结果为：</p><p>*.jpg</p><p>*.jpg</p><p>其中单引号更严格一些，它可以防止任何变量扩展；而双引号可以防止通配符扩展但允许变量扩展：</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo $SHELL</p><p>echo “$SHELL”</p><p>echo ‘$SHELL’</p><p>运行结果为：</p><p>&#x2F;bin&#x2F;bash</p><p>&#x2F;bin&#x2F;bash</p><p>$SHELL</p><p>此外还有一种防止这种扩展的方法，即使用转义字符——反斜杆:\：</p><p>echo *.jpg</p><p>echo $SHELL</p><p>输出结果为：</p><p>*.jpg</p><p>$SHELL</p><p><strong>九：c语言开发环境</strong></p><p><strong>1</strong>. 实例分析</p><p>&#x2F;* traditional first c program *&#x2F;</p><p>#include &lt;stdio.h&gt;</p><p>int main(argc, argv)</p><p>  int argc; char *argv[];</p><p>{</p><p>  printf(“hello world!\n”);</p><p>  return 0;</p><p>}</p><p>注释&#x2F;* traditional first c program <em>&#x2F;，&#x2F;</em>  *&#x2F; 之间为注释，用于阅读，编译器忽略这些内容。</p><p>预编译指令</p><p>#include &lt;stdio.h&gt; 告诉编译程序，在编译之前在“常见位置”寻找stdio.h，将其内容包含到程序中。</p><p>#为预编译指令，告诉编译程序其后的内容在编译之前需要处理。</p><p>include表示包含某个文件</p><p>&lt;&gt;表示“常见位置”，通常为&#x2F;usr&#x2F;include. 如果文件在其它位置，应使用””号。如#include “myhead.h”。</p><p>stdio.h为标准输入&#x2F;输出头文件，其中包含了main函数所使用的printf函数</p><p>主函数</p><p>int main(argc, argv)</p><p>任何c程序必须有一个main函数，程序从main函数开始执行。</p><p>主函数参数</p><p>  int argc; char *argv[];</p><p>主函数参数是命令行的参数，argc是参数的数量，argv是各个参数所组成的数组。</p><p>良好的习惯：对于输入数据，如果给出了输入文件，则从该文件读入数据，否则从标准输入读入数据；对于输出数据，如果给出了输出文件，则输出至该文件，否则输出至标准输出文件。—-这样便于使用管道来连接命令。</p><p>主函数返回值</p><p>  return 0</p><p>主函数最好声明为int类型。如果程序正常结束，主程序的返回值最好为0，否则返回-1或其它值。这样有利于shell编程。</p><p>使用echo命令可以查看最后一条命令的返回值。</p><p>$ .&#x2F;a.out</p><p>$ echo $?</p><p><strong>2.</strong> <strong>c****编译过程：</strong>第一步，预处理。处理预处理指令，如#inlude、#define等，输出预处理后的源文件。第二步，编译。词法和语法分析，如果有错误，则给出提示终止编译；如果没有错误，则将源程序翻译成汇编代码（或其它中间代码）。汇编代码是以助记符来代替机器代码的一种代码。第三步，汇编。将汇编代码转换成机器代码，输出目标文件。第四步，连接。连接各目标文件，生成可执行程序。</p><p><strong>3.</strong> <strong>（UNIX<strong><strong>系统中默认的c</strong></strong>编译器为cc<strong><strong>。在Ubuntu</strong></strong>中，cc<strong><strong>等同于gcc</strong></strong>）</strong></p><p>$ cc hello.c  &#x2F;&#x2F;生成可执行程序 .&#x2F;a.out</p><p>$ cc -o hello hello.c &#x2F;&#x2F;生成可执行程序 hello</p><p>$ cc p1.c p2.c &#x2F;&#x2F;源程序由两个文件组成。编译p1.c和p2.c，生成.&#x2F;a.out</p><p>$ cc -c p1.c &#x2F;&#x2F;编译p1.c，生成目标文件p1.o，不连接。</p><p>$ cc -g hello.c &#x2F;&#x2F;编译hello.c，在目标文件中加入调试信息。</p><p><strong>4.</strong> <strong>程序调试工具gdb</strong></p><p>主要功能包括：1）启动程序，可以按照自定义的要求运行程序。2）可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）3）当程序被停住时，可以检查此时你的程序中所发生的事。 4）动态的改变你程序的执行环境。</p><p>采用命令行界面。</p><p>命令简介：(gdb)  &#x2F;&#x2F;gdb 命令提升符</p><p>(gdb) help  &#x2F;&#x2F;显示gdb命令分类</p><p>(gdb) help breakpoints &#x2F;&#x2F;显示断点设置的相关命令</p><p>(gdb) h b  &#x2F;&#x2F;同上。只要不引起歧义，gdb命令可以简写。</p><p>(gdb) he bre &#x2F;&#x2F;同上。</p><p><strong>5.</strong> make：使用默认文件名时，只需执行命令make即可完成编译；使用其它文件名时，需要执行make -f filename来完成编译。</p><p>\6. 编译规则</p><p>一个例子p: p1.o p2.o</p><p>gcc -o p p1.o p2.o</p><p>p1.o: p1.c</p><p>gcc -c p1.c</p><p>p2.o: p2.c</p><p>gcc -c p2.c       上例中包含3条规则，每条规则包含一个文件依赖关系和一条命令。p:p1.o p2.o表示文件p依赖文件p1.o和p2.o，如果这两个文件中的任何一个比文件p新（更改时间更晚），则执行规则中的命令gcc -o p p1.o p2.o</p><p>例1 自动规则</p><p>p: p1.o p2.o</p><p>gcc -o p p1.o p2.o</p><p>$ touch p1.c</p><p>$ make</p><p>对于p1.o和p2.o，make自动生成如下规则 p1.o:p1.c; gcc –c –o p1.o p1.c 和p2.o:p2.c; gcc –c –o p2.o p2.c</p><p>例2</p><p>p: p1.o p2.o</p><p>gcc -o p p1.o p2.o</p><p>p1.o:p1.c</p><p>echo donothing</p><p>$ touch p1.c p2.c</p><p>$ make</p><p>$ make</p><p>由于p1.o的生成规则存在，make采用该规则，不再为这个依赖文件生成规则</p><p>例3</p><p>p: p1.o p2.o</p><p>gcc -o p p1.o p2.o</p><p>sig.o:sig.c</p><p>gcc -c sig.c</p><p>$ touch sig.c</p><p>$ make</p><p>sig.o不是终极目标的依赖文件，其生成规则不采用。</p><p>例4</p><p>p: p1.o p2.o x</p><p>gcc -o p p1.o p2.o</p><p>$ make</p><p>没有创建x的规则，也无法自动创建，错误！</p><p>规则的一般形式</p><p>目标文件：依赖文件1 依赖文件2 …</p><p><tab>命令1  [#注释]</p><p><tab>命令2  [#注释]</p><p>……</p><p>#一条规则可以执行多条命令，每条命令的行首必须是制表符（tab），make文件中可以有注释</p><p><strong>7.</strong> 使用变量</p><p>make文件中可以使用变量，这样更为简洁，避免出错。例如：</p><p># sample 1</p><p>objs &#x3D; main.o kbd.o command.o display.o \</p><p> insert.o search.o files.lo untils.o</p><p>edit:$(objs)</p><p>cc -o edit $(objs)</p><p>#用\将较长的行分解为多行。\取消换行符的作用，其后面不能有空格等字符，否则会出错（很隐蔽的错误）。</p><p>#如果不定义变量，所有.o文件会写两次，繁琐，且容易出错</p><p><strong>8.</strong> 使用隐含规则</p><p>只有依赖关系而没有命令的规则为隐含规则。如</p><p>p1.o : p1.c a.h  # or p1.o : a.h</p><p>p2.o : p2.c b.h  # or p2.o : b.h</p><p>p3.o : p3.c     # or p3.o:  or <null> </p><p>对于隐含规则，make会自动运行相应的命令来生成目标文件。如 gcc -c -o p1.o p1.c</p><p>对于p1.o:p1.c这种自动的依赖关系，可以省略不写。</p><p>只有自动依赖关系的隐含规则可以不写。</p><p>**9.**伪目标规则</p><p>伪目标规则完成某些编译以外的任务，例如：</p><p>clear:</p><p>rm *.o</p><p>dosth:</p><p>echo what you want?</p><p>执行伪目标规则中的命令</p><p>$ make clear</p><p>$ make dosth</p><p>$ make clear dosth</p><p>如果伪目标文件存在，将不会执行预期的操作，因此，最好在make文件中声明伪目标规则</p><p>.PHONY: clear dosth</p><p><strong>10.</strong> 标准c函数</p><p>系统调用：操作系统需要向运行程序提供各种服务，如打开文件、读写文件、分配内存、获取当前时间、执行新的程序等。访问这些服务的接口叫做“系统调用（sysem call）”，或叫做“应用程序接口（API）”、“服务原语”等。</p><p>UNIX每个系统调用都在c库中设置一个具有同样名字的函数。这些函数按照系统要求的技术调用相应的内核服务。例如将若干c参数送入通用寄存器，然后执行某个软中断进入内核的机器指令。从应用的角度，系统调用可视为c函数。</p><p>库函数</p><p>库函数是在系统调用基础上所实现的公共函数。</p><p>一个库函数可能会调用一个或多个系统调用，也可能不使用任何系统调用。例如，printf函数是库函数，它调用write系统调用；strcpy复制一个字符串，不使用系统调用。</p><p>二者的关系</p><p>系统调用是操作系统内核提供的，而库函数是具体编程语言提供的。库函数构建在系统调用基础之上。从编程的角度，编程者可编写其它函数来替换库函数，但无法替换系统调用。系统调用通常提供某种功能的一个最小接口，而库函数通常提供比较复杂的功能。例如，系统调用write提供基本的文件写操作，而printf则提供格式化的写操作。</p><p>约定：在不需要严格区分的前提下，“标准c函数”、“库函数”指所有c语言标准头文件中定义的函数，其中包括库函数和系统调用。</p><p><strong>十：系统调用</strong></p><p>\1. 基本文件I&#x2F;O函数：open、creat、read、write、lseek、close</p><p>术语：不带缓冲的I&#x2F;O（指每一个read、write都调用内核中的一个系统调用），低级例程。</p><p>文件描述符：一个非负的整数，一个结构数组的下标，进程打开的文件表项的下标。</p><p>open、creat函数会返回一个文件描述符</p><p>close：</p><p>#include &lt;unistd.h&gt;</p><p>int close(int filedes)</p><p>返回值：若成功，返回0，出错返回-1</p><p>filedes，文件描述符</p><p>进程终止时，内核自动关闭其打开的所有文件</p><p>lseek</p><p>移动文件“读写指针”（或称“文件偏移量”）。读写操作会自动移动文件读写指针。</p><p>#include &lt;unistd.h&gt;</p><p>off_t lseek(int filedes, off_t offset, int whence)</p><p>off_t 与系统有关，通常是长整型</p><p>filedes 文件描述符</p><p>whence 移动偏移量的方式。0：绝对方式；1：相对方式；2：相对文件尾部</p><p>offset 移动的距离，非绝对方式移动时，可以为负。</p><p>返回值：新的文件偏移量。</p><p>read</p><p>从已打开的文件中读取数据，自动移动文件读写指针。</p><p>#include &lt;unistd.h&gt;</p><p>ssize_t read(int filedes, void *buff, size_t nbytes)</p><p>ssize_t 通常是整型，size_t通常是无符号整型。</p><p>filedes 文件描述符</p><p>buff 存放数据的缓冲区</p><p>nbytes 需要读取的字节数</p><p>返回值：实际读取的字节数。正常读取时，返回值等于nbytes;遇到文件结束时，小于nbytes；出错返回-1</p><p>write</p><p>将数据写入已打开的文件，自动移动文件读写指针。</p><p>#include &lt;unistd.h&gt;</p><p>ssize_t write(int filedes, void *buff, size_t nbytes)</p><p>ssize_t 通常是整型，size_t通常是无符号整型。</p><p>filedes 文件描述符</p><p>buff 存放数据的缓冲区</p><p>nbytes 需要写入的字节数</p><p>返回值：实际写入的字节数。正常写入时，返回值等于nbytes;磁盘空间满时，小于nbytes（这种情况也可以认为是出错）；出错返回-1</p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="img"></p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" alt="img"></p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png" alt="img"></p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png" alt="img"></p><p><strong>2.</strong> <strong>dup2</strong></p><p>#include &lt;unistd.h&gt;</p><p>int dup2(int filedes1, int filedes2)</p><p>将文件描述符filedes1的表项复制给filedes2的表项。如果filedes2已经打开，则先将其关闭。</p><p>返回值：正常返回filedes2，出错返回-1</p><p>**3.**原子操作 例1 多个进程添写同一个日志文件</p><p>有问题的代码：</p><p>lseek(fd, 0L, 2)</p><p>write(fd, buf, nbytes)</p><p>正确的做法：</p><p>open时，使用O_APPEND选项</p><p>write时，不需要调用lseek，直接写。</p><p>例2 多个进程创建可能重名的临时文件</p><p>有问题的代码：</p><p>if （open（tmpfile, O_WRONLY)&lt;0)</p><p>   creat(tmpfile, mode)</p><p>正确的做法：</p><p>open(tmpfile, O_CREAT|O_WRONLY|O_TRUNC, mode)</p><p>最好的做法是保证没有重名的临时文件。</p><p><strong>3.</strong> 文件属性和目录</p><p>文件属性</p><p>属性结构</p><p>struct stat {</p><p> mode _t   st_mode;  &#x2F;&#x2F;文件类型和权限</p><p> ino_t     st_ino;   &#x2F;&#x2F;i节点号</p><p> dev_t     st_dev;   &#x2F;&#x2F;文件系统设备号（磁盘和分区）</p><p> dev_t     st_rdev;  &#x2F;&#x2F;设备文件的设备号</p><p> nlink_t    st_nlink;  &#x2F;&#x2F;链接数</p><p> uid_t     st_uid;   &#x2F;&#x2F;文件所有者的用户ID</p><p>gid_t     st_gid;   &#x2F;&#x2F;文件所有者的组ID</p><p> off_t     st_size;   &#x2F;&#x2F;文件长度（字节数），普通文件</p><p> time_t    st_atime;  &#x2F;&#x2F;最后一次访问的时间</p><p> time_t    st_mtime; &#x2F;&#x2F;最后一次修改文件内容的时间</p><p> time_t    st_ctime;  &#x2F;&#x2F;最后一次修改文件属性的时间</p><p> }</p><p>函数</p><p>#include &lt;sys&#x2F;stat.h&gt;</p><p>int stat(const char *pathname, struct stat *buf)</p><p>int fstat(int filedes, struct stat *buf)</p><p>文件类型</p><p>类型：普通文件、目录文件、字符设备文件、块设备文件、 FIFO、符号链接、套接字</p><p>判断文件类型</p><p>S_ISREG(mode_t mode)  &#x2F;&#x2F;是否普通文件</p><p>S_ISDIR(mode_t mode)  &#x2F;&#x2F;是否目录文件</p><p>S_ISCHR(mode_t mode)  &#x2F;&#x2F;是否字符设备文件</p><p>S_ISBLK(mode_t mode)  &#x2F;&#x2F;是否块设备文件</p><p>S_ISFIFO(mode_t mode) &#x2F;&#x2F;是否管道文件</p><p>S_ISLNK(mode_t mode)  &#x2F;&#x2F;是否符号链接</p><p>S_SOCK(mode_t mode)  &#x2F;&#x2F;是否套接字</p><p>文件的权限</p><p>9个普通权限位</p><p>S_IRUSER, S_IWUSER, S_IXUSER &#x2F;&#x2F;用户权限位</p><p>S_IRGRP,  S_IWGRP,  S_IXGRP  &#x2F;&#x2F;用户组权限位</p><p>S_IROTH,  S_IWOTH, S_IXOTH  &#x2F;&#x2F;其他用户权限位</p><p>3个特殊权限位（针对可执行文件）</p><p>S_ISUID 执行时设置有效用户ID，如passwd命令文件</p><p>S_ISGID 执行时设置有效用户组ID</p><p>S_SVTX  第一次执行时，保存正文，即常驻内存。</p><p>函数</p><p>int chmod(const char *pathname, mode_t mode)</p><p>int fchmod(int filedes, mode_t mode)</p><p>创建新文件</p><p>新文件的用户ID、组ID等于创建进程的有效用户ID和组ID</p><p>新文件的权限由指定权限和屏蔽字共同决定。</p><p>指定权限，open和creat函数中给出的权限。</p><p>屏蔽字（umask值），被umask屏蔽的权限位即使在open或creat中指定了也会被屏蔽掉。</p><p>#include &lt;sys&#x2F;stat.h&gt;</p><p>mode_t umask(mode_t mode)</p><p>umask函数设置当前屏蔽字，返回以前的屏蔽字。</p><p>普通文件操作函数</p><p># include &lt;unistd.h&gt;</p><p>int link(const char *existingpath, const char *newpath) 创建一个新的目录项newpath，指向一个现有的文件existingpath。</p><p>int unlink(const char *pathname) 删除一个目录项，对应文件的链接数减1。</p><p>#include &lt;stdio.h&gt;</p><p>int remove(const char *pathname) 删除一个文件或目录的链接。</p><p>int rename(const char *oldname, const char *newname) 文件或目录更名</p><p>目录文件操作函数</p><p># include &lt;sys&#x2F;stat.h&gt;</p><p>int mkdir(const char *pathname, mode_t mode) 创建一个目录</p><p># include &lt;unistd.h&gt;</p><p>int rmdir(const char *pathname) 删除一个空目录。</p><p>目录文件读函数 &#x2F;&#x2F;只有内核才可以写</p><p>#include &lt;dirent.h&gt;</p><p>DIR *opendir(const char *pathname)</p><p>struct dirent *readdir(DIR *dp)</p><p>int closedir(DIR *dp)</p><p>void seekdir(DIR *dp, long loc)</p><p>位置函数</p><p>改变进程的当前工作目录 &#x2F;&#x2F;cd命令</p><p># include &lt;unistd.h&gt;</p><p>int chdir(const char *pathname)</p><p>int fchdir(int filedes)</p><p>获取当前工作目录 &#x2F;&#x2F;pwd命令</p><p>#include &lt;unistd.h&gt;</p><p>char *getcwd(char *buff, size_t size)</p><p><strong>4.</strong> 进程控制</p><p>进程ID(进程号)</p><p>#include &lt;unistd.h&gt;</p><p>pid_t getpid(void)  获取调用者的进程ID</p><p>pid_t getppid(void) 获取调用者的父进程ID。</p><p>创建进程（fork）</p><p>#include &lt;unistd.h&gt;</p><p>pid_t fork(void)</p><p>功能：创建一个新的进程，新进程是旧进程的副本。旧进程叫父进程，新进程叫子进程。</p><p>返回值：fork函数调用一次，返回两次。在父进程中返回子进程的ID，在子进程中返回0，出错返回-1</p><p>if ((pid&#x3D;fork()) &#x3D;0) {</p><p>  …… &#x2F;&#x2F;子进程代码}</p><p>else if (pid&gt;0){</p><p>  …… &#x2F;&#x2F;父进程代码}</p><p>else{</p><p>  …… &#x2F;&#x2F;fork 出错 }</p><p>执行程序（exec）</p><p>父进程fork一个子进程后，子进程往往需要调用一个exec函数来运行一个新程序。</p><p>exec函数用一个新程序替换调用进程原有的代码、数据、堆栈等，新程序从头开始执行。exec不产生新的进程，所有调用前后的进程号不发生变化。</p><p>exec函数</p><p>#include &lt;unistd.h&gt;</p><p>int execl(const char *pathname, const char *arg0,…,(char *)0)</p><p>int execv(const char *pathname, char *const argv[])</p><p>int execle(const char *pathname, const char *arg0,…,(char *)0, char *const envp[])</p><p>int execve(const char *pathname, char *const argv[], char *const envp[])</p><p>int execlp(const char *filename, const char *arg0,…,(char *)0)</p><p>int execvp(cons char *filename, char *const argv[])</p><p>说明：</p><p>\1) execl和execlp比较直观，类似命令行输入，推荐使用。</p><p>2）execve是系统调用，其他是库函数。</p><p>3）返回值：正常不返回，出错返回-1</p><p>文件共享</p><p>fork之后，所有父进程打开的文件描述符都被复制到子进程中。父子进程相同的文件描述符指向相同的内核文件表，具有相同的文件偏移量。如果父子进程同时操作相同的文件，则需要同步机制，否则会产生混乱。</p><p>一般情况下，应该尽量回避父子进程同时操作相同文件的情况。1）父进程等待子进程结束后再运行；2）父子进程运行不同的程序段，使用不同的文件。</p><p>创建进程的目的</p><p>1）并行。网络服务中，父进程等待请求，创建子进程来响应请求。</p><p>2）运行新程序。例如shell，不断地在fork和exec</p><p>进程结束</p><p>正常结束</p><p>main函数执行完</p><p>main函数中执行return</p><p>任意位置执行exit、_exit、_Exit</p><p>非正常结束</p><p>收到某个信号而结束</p><p>无论进程如何结束，都会执行内核中的一段代码：关闭所有打开文件，释放占用的内存。</p><p>进程结束时，内核会保存其终止状态，直到该进程的父进程取走其状态。</p><p>父进程结束，其子进程成为孤儿进程，由进程1（init进程）领养。</p><p>子进程先于父进程结束，如果父进程未取走其状态，则该进程仍然占有一定的内核资源，成为“僵死进程”。</p><p>由于僵死进程占用资源，因此当一个长期运行的服务类程序调用fork后，应处理僵死进程。</p><p>wait函数</p><p>#include &lt;sys&#x2F;wait.h&gt;</p><p>pid_t  wait(int *statloc)</p><p>pid_t  waitpid(pid_t pid, int *statloc, int options)</p><p>waitid、wait3、wait4等</p><p><strong>5.</strong> 进程间通信</p><p>进程间通信包括：半双工管道、半双工命名管道（FIFO）、全双工管道、全双工命名管道、消息队列、信号量、共享存储、套接字、STREAMS，Linux支持以上全部，其他UNIX一般只支持一部分。</p><p>套接字可支持不同主机的进程间通信（网络通信），其他为主机内通信。主机内通信常用半双工管道，网络通信常用套接字。</p><p>半双工管道：所有UNIX系统都提供的一种通信方式。</p><p>特点：1）半双工的工作方式。通信方向是双向的，但只能选择其中一种。2）只能在具有公共祖先的进程之间使用。通常是父子进程之间。</p><p>函数</p><p>#include &lt;unistd.h&gt;</p><p>int pipe(int filedes[2])</p><p>创建一个管道，若成功返回0，不成功返回-1；</p><p>由参数filesdes返回两个文件描述符: filedes[0]、filesdes[1]， filedes[0]为读而打开， filedes[1]为写而打开。</p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png" alt="img"></p><p>创建管道之后的情形如上图所示。将数据写入fd[1]，从fd[0]中读出。</p><p>管道在单个进程中没有意义，通常在pipe函数之后，立刻会调用fork，产生一个子进程，情形如下图所示：</p><p><img src="file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png" alt="img"></p><p>代码示例（父进程写，子进程读）：</p><p>int fd[2]; char line[MAXLINE];</p><p>pipe(fd);</p><p>if (pid&#x3D;fork() &gt;0){  &#x2F;&#x2F;父进程</p><p>  close(fd[0]);</p><p>  write(fd[1],”hello world!\n”, 12); }</p><p>else if (pid&#x3D;&#x3D;0)｛  &#x2F;&#x2F;子进程</p><p>  close(fd[1]);</p><p>  read(fd[0], line, MAXLINE); }</p><p>利用管道连接父子进程的标准输出和输入：</p><p>if (pid&#x3D;fork() &gt;0){  &#x2F;&#x2F;父进程</p><p>  close(fd[0]);</p><p>  dup2(fd[1],1); }</p><p>else if (pid&#x3D;0)｛  &#x2F;&#x2F;子进程</p><p>  close(fd[1]);</p><p>  dup2（fd[0],0);</p><p>  execlp(……) }</p><p>……    &#x2F;&#x2F;父进程代码</p><p>命名管道FIFO：命名管道是一种文件</p><p>$ mkfifo f1</p><p>$ ls -l f1</p><p>$ cat &lt;f1</p><p>$ ls -l&gt;f1</p><p>函数</p><p>#include &lt;sys&#x2F;stat.h&gt;</p><p>int mkfifo(const char *pathname, mode_t mode)</p><p><strong>6.</strong> 信号</p><p>信号是一种异步事件，通常是非正常情况，如：人为终止进程、除数为0、非法内存访问等。所谓“异步”，指信号的出现是随机的。</p><p>信号的产生：人为按下中断键 Ctrl_C ；用户使用kill命令；进程调用kill函数；程序运行错误，除数为0、非法内存访问</p><p>软件产生的信号：闹钟超时、写一个读端已关闭的管道、网络传来带外数据。—-这些基本是可以预见的信号。</p><p>信号的处理</p><p>系统默认处理或忽略</p><p>捕捉信号 通知内核在某种信号发生时调用一个用户函数。</p><p>signal函数</p><p>#inclucde &lt;signal.h&gt;</p><p>void (*singnal(int signo, void (*func)(int)))(int)</p><p>解释</p><p>void (*func)(int) 一个函数指针，所指向的函数需要一个整型参数，无返回值。</p><p>singnal(int signo, void (*func)(int)), signal函数有两个参数，一个整型，一个函数指针。</p><p>void (*signal(…))(int) signal的返回值也是一个函数指针，所指向的函数需要一个整型参数，无返回值。</p><p>signal函数的使用</p><p>void my_sig(int);</p><p>int main(){</p><p> signal(SIGINT, my_sig);</p><p> …}</p><p>void my_sig(int signo){</p><p>…}</p><p>alarm函数</p><p>#include &lt;unistd.h&gt;</p><p>unsigned int alarm(unsigned int seconds)</p><p>按秒设置下一次闹钟的时间。</p><p>返回值，如果以前设置过闹钟，再次设置时返回上一次设置时间的余数；否则返回0。</p><p>alarm函数设置的时间到达时，产生SIGALRM信号。该信号的默认动作是终止程序。</p><p>信号捕捉实例(sig.c)</p><p> signal(SIGINT, my_sig);</p><p> signal(SIGALRM, my_sig);</p><p>void my_sig(int signo){</p><p> if (signo&#x3D;&#x3D;SIGINT){</p><p>   …</p><p>   }</p><p>   else if(signo&#x3D;&#x3D;SIGALRM){</p><p>   …</p><p>   }</p><p>}</p><p>进程控制中的信号处理</p><p>fork时，子进程继承父进程的信号处理。</p><p>exec时，恢复系统默认设置。</p><p>重入问题</p><p>printf不可重入，大多数标准IO库函数不可重入。</p><p>信号处理程序应尽可能简单，尽可能不用库函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 北航UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现FCFS，SJF调度算法</title>
      <link href="/2022/05/11/c-yu-yan-shi-xian-fcfs-sjf-diao-du-suan-fa/"/>
      <url>/2022/05/11/c-yu-yan-shi-xian-fcfs-sjf-diao-du-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>本次内容也是北京航空航天大学OS操作系统第五次课上作业。</p><p><img src="https://note.youdao.com/yws/api/personal/file/69479141906C4090894C0F203F28D306?method=download&shareKey=79efbec86dd0a81e338db7172b17bb6b"></p><p>我所使用的变量顾名知义，不做过多的阐述。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int job_submitted_time[] &#x3D; &#123;0, 1, 2, 3, 12, 12, 12, 12, 200, 200&#125;;int job_required_time[] &#x3D; &#123;4, 3, 2, 1, 6, 5, 4, 3, 1, 1&#125;;int fcfs_result[10];int sjf_result[10];void FCFS (    int number_of_jobs,    const int job_submitted_time [],    const int job_required_time [],    int job_sched_start []) &#123;    int currenttime &#x3D; job_submitted_time[0];    job_sched_start[0] &#x3D; job_submitted_time[0];    currenttime +&#x3D; job_required_time[0];    for(int i&#x3D;1;i&lt;number_of_jobs;i++) &#123;        if(currenttime &gt;&#x3D; job_submitted_time[i]) &#123;            job_sched_start[i] &#x3D; currenttime;        &#125; else &#123;            job_sched_start[i] &#x3D; job_submitted_time[i];            currenttime &#x3D; job_submitted_time[i];        &#125;        currenttime +&#x3D; job_required_time[i];    &#125;&#125;void SJF (    int number_of_jobs,    const int job_submitted_time [],    const int job_required_time [],    int job_sched_start []) &#123;    char record[2005];    memset(record,0,sizeof(record));    int currenttime &#x3D; job_submitted_time[0];    int k &#x3D; number_of_jobs;    int last &#x3D; 0;    &#x2F;&#x2F;int flag &#x3D; 0;    while(k--)&#123;        int mintime &#x3D; (((unsigned int)(-1))&gt;&gt;1);        int recordi &#x3D; -1;                for(int i &#x3D; 0;i &lt; number_of_jobs;i++) &#123;            if(job_submitted_time[i] &gt; currenttime) &#123;                break;            &#125; else if(record[i] !&#x3D; &#39;1&#39;) &#123;                if(job_required_time[i] &lt; mintime) &#123;                    recordi &#x3D; i;                    mintime &#x3D; job_required_time[i];                &#125;            &#125; else if(record[i] &#x3D;&#x3D; &#39;1&#39;) &#123;                if(i &gt; last) &#123;                    last &#x3D; i;                &#125;            &#125;        &#125;        if(recordi &#x3D;&#x3D; -1) &#123;            currenttime &#x3D; job_submitted_time[last + 1];            k++;            continue;        &#125;        record[recordi] &#x3D; &#39;1&#39;;        job_sched_start[recordi] &#x3D; currenttime;        currenttime +&#x3D; job_required_time[recordi];    &#125;&#125;int main() &#123;    int n &#x3D; 10, i;    FCFS(n, job_submitted_time, job_required_time, fcfs_result);    puts(&quot;FCFS results:&quot;);    for (i &#x3D; 0; i &lt; n; ++i) printf(&quot;job % 2d: [% 9d]\n&quot;, i, fcfs_result[i]);    SJF(n, job_submitted_time, job_required_time, sjf_result);    puts(&quot;SJF results:&quot;);    for (i &#x3D; 0; i &lt; n; ++i) printf(&quot;job % 2d: [% 9d]\n&quot;, i, sjf_result[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab3实验报告</title>
      <link href="/2022/05/09/2022-cao-zuo-xi-tong-lab3-shi-yan-bao-gao/"/>
      <url>/2022/05/09/2022-cao-zuo-xi-tong-lab3-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab3实验报告"><a href="#Lab3实验报告" class="headerlink" title="Lab3实验报告"></a>Lab3实验报告</h2><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="Thinking-3-1：为什么要判断e-gt-env-id-x3D-envid？"><a href="#Thinking-3-1：为什么要判断e-gt-env-id-x3D-envid？" class="headerlink" title="Thinking 3.1：为什么要判断e-&gt;env_id !&#x3D; envid？"></a>Thinking 3.1：为什么要判断e-&gt;env_id !&#x3D; envid？</h4><p><strong>答：</strong>因为上一步通过索引取envs数组中的第“id”个进程块e时，去掉了envid的前22位，而只取了后10位。因此，e-&gt;env_id !&#x3D; envid这一步确定进程e的id确实是传入的envid。后10位在生成的时候只与进程页的物理位置有关，idx &#x3D; e - envs。而前面22位才是保证进程unique的关键（由调用次数决定，可以保证unique）。要保证一个进程的id号完全对应，看后十位不够，还得对比前22位也确实是一样的。如果没有这步判断会造成错误：可能输入的id并不是进程id号，而仅仅是进程的物理位置与另一个进程相同。</p><h4 id="Thinking-3-2-结合include-x2F-mmu-h-中的地址空间布局，思考env-setup-vm-函数："><a href="#Thinking-3-2-结合include-x2F-mmu-h-中的地址空间布局，思考env-setup-vm-函数：" class="headerlink" title="Thinking 3.2 结合include&#x2F;mmu.h 中的地址空间布局，思考env_setup_vm 函数："></a>Thinking 3.2 <strong>结合include&#x2F;mmu.h 中的地址空间布局，思考env_setup_vm 函数：</strong></h4><p><strong>• UTOP 和ULIM 的含义分别是什么，UTOP 和ULIM 之间的区域与UTOP以下的区域相比有什么区别？</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/4A0C910BE613420AAF5DE98A3128D499?method=download&shareKey=126757fe2c93df1e59e885f1f66e2d82" alt="a"></p><p><strong>答：</strong>我们的虚拟内存空间使用的是2G&#x2F;2G模式（如图）。</p><ul><li>UTOP是user exception stack 的高位地址，UTOP以下是进程自己使用的；</li><li>ULIM是INterrupts &amp; Exception的低位地址，ULIM以上包括kesg0，kseg1,是内核使用的。</li><li>UTOP与ULIM中间一部分，分别是User VPT、PAGES、ENVS。这三部分也是各有用处，PAGES对应的是之前物理页框数组pages，ENVS对应的是进程数组envs，而User VPT对应的是进程自己的页表，这一部分是内核主动暴露给进程使用的空间。<ul><li>在本次实验中，UTOP和ULIM中间这一部分与UTOP的区别是，初始化进程页表时，UTOP以下的空间是进程自己使用，没有使用前这一部分对应页表清零。而中间这一部分已经由内核映射到<code>boot_pgdir</code>中，需要从boot_pgdir中直接拷贝。</li></ul></li></ul><p><strong>• 请结合系统自映射机制解释代码中pgdir[PDX(UVPT)]&#x3D;env_cr3的含义。</strong></p><p><strong>答</strong>：cr3记录页目录自身的物理地址，根据自映射的机制，在页目录的第<code>PTBase/4MB</code>项(由于进程页目录的宏定义为UVPT，且除以4MB相当于取32位的前10位，所以就相当于<strong>PDX(UVPT)</strong>)，该项存储的便是页目录自身的物理地址，因此我们要将页目录该处设为传入插入cr3,即<code>pgdir[PDX(UVPT)]=env_cr3</code>。</p><p><strong>• 谈谈自己对进程中物理地址和虚拟地址的理解。</strong></p><p><strong>答：</strong>每个进程看到的都只能是虚拟地址空间，进程需要的物理地址空间存储在进程的页表当中。物理地址空间是硬件决定，虚拟空间则是人为约定。对于不同的进程来说。每个进程都有着各自独立的虚拟地址空间，这样进程切换时不同的进程对相同的虚拟地址空间进行访问时互不影响，而且可以方便的实现数据共享。</p><h4 id="Thinking-3-3-找到-user-data-这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）"><a href="#Thinking-3-3-找到-user-data-这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）" class="headerlink" title="Thinking 3.3  找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）"></a>Thinking 3.3  <strong>找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不</strong>可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）</h4><p><strong>答：</strong> <strong>来源及作用</strong>：</p><ul><li>来源</li></ul><p>首先在env.c中的load_icode函数中调用了load_elf函数，这里user_data传入的是<code>(void *)e</code>,即目标进程e的控制块PCB指针。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Step 3: load the binary using elf loader. *&#x2F;    r &#x3D; load_elf(binary, size, &amp;entry_point, (void *)e, load_icode_mapper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>作用</li></ul><p>接着load_elf调用load_icode_mapper，并把user_data传给了load_icode_mapper，在load_icode_mapper中我们可以看到，它将user_data类型转换为了PCB块，通过PCB获得了当前要操作的进程的所有信息，之后便可以进行使用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token punctuation">)</span>user_data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个参数的存在方便我们通过函数指针向更内层的函数传值，没有它不可以，通过上述分析来源与作用我们可以知道，没有user_data，load_icode_mapper无法得知PCB信息，也无法进行加载操作。</p><ul><li>例子</li></ul><p>在stdlib库中</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void qsort(void*base, size_t num, size_t width, int(__cdecl*compare)(const void*,const void*));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三个参数告诉了程序应当如何分割base起始的内存数据，方便调用传入的比较函数进行排序操作。</p><h4 id="Thinking-3-4-结合load-icode-mapper-的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？"><a href="#Thinking-3-4-结合load-icode-mapper-的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？" class="headerlink" title="Thinking 3.4  结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？"></a>Thinking 3.4  <strong>结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？</strong></h4><p><strong>答</strong>：可能的情况有以下几种，<strong>容易出错的地方我认为在第一页和最后一页的拷贝上，因为这里是两部分的交集，需要慎重考虑</strong>。</p><p>关于<code>.text &amp; .data</code>：</p><ul><li>第一页，如果offset&gt;那么0,那么需要考虑这一页offset之前的部分已经装填过内容，不能进行alloc，insert新的页面，否则会清零。我们只需要拷贝<code>offset</code>后面的部分。如果offset&#x3D;&#x3D;0，那么就不用考虑那么多，正常申请页面进行拷贝。</li><li>最后一页，如果前半部分属于.text &amp; .data，后半部分属于.bss，这会影响到bss的拷贝，在拷贝bss时需要额外考虑这种情况。</li></ul><p>关于<code>.bss</code>：</p><ul><li>第一页，如上所述，需要同前半段的<code>.test &amp; .data</code>段协同考虑，也需要计算offset，跟.text &amp; .data部分的考虑方式相同，如果offset&gt;0,不能申请页面，只拷贝部分，如果offse&#x3D;&#x3D;0，正常申请页面拷贝。</li><li>最后一页，即前半部分属于<code>.bss</code>，后半段在需要复制的内容之外。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct Env *env &#x3D; (struct Env*)user_data;&#x2F;*如果va不在开头，那么求出va相对于页面开头的偏移*&#x2F;u_long offset &#x3D; va-ROUNDDOWN(va,BY2PG);&#x2F;*得到进程的页目录*&#x2F;Pde* pgdir &#x3D; env-&gt;env_pgdir;int size&#x3D;0;&#x2F;*如果offset&gt;0那么显然va不在开头*&#x2F;if(offset&gt;0)&#123;    &#x2F;*检查va是否已经对应了一个物理页面*&#x2F;    p&#x3D;page_lookup(pgdir,va,NULL);    &#x2F;*如果没有，就分配一个*&#x2F;    if(p&#x3D;&#x3D;NULL)&#123;        r&#x3D;page_alloc(&amp;p);        if(r&lt;0)&#123;            return r;        &#125;        page_insert(pgdir,p,va,PTE_R);    &#125;    &#x2F;*这里比较页面p剩余内存大小和bin_size，     *如果页面剩余大小就能装下bin_size     *那就是情况(1)，这样一来就直接全拷贝进去就可以了*&#x2F;    size &#x3D; BY2PG-offset;    size &#x3D; (bin_size&lt;size)?bin_size:size;    bcopy((void *)bin,(void *)(page2kva(p)+offset),size);&#125;&#x2F;*如果内存是第一种情况，那么size&#x3D;&#x3D;bin_size， *此时不会进入循环，如果是二三种情况，则会进入循环*&#x2F;i&#x3D;size;for(;i&lt;bin_size;i+&#x3D;size)&#123;    &#x2F;*因为这里是从页面的开头开始写的，     *我们直接申请一个新的页面*&#x2F;    r&#x3D;page_alloc(&amp;p);    if(r&lt;0)&#123;        return r;    &#125;    page_insert(pgdir,p,va+i,PTE_R);    &#x2F;*这里size的用法如下，     *i为已经读取了的字节，bin_size-i是还要读取的字节     *如果BY2PG&gt;(bin_size-i)的话，我们就再写一页，     *否则，我们就只把剩下的字节写入，     *size&#x3D;bin_size-i，这次循环末尾就会把i设置为     *bin_size，从而跳出循环*&#x2F;    size(BY2PG&lt;(bin_size-i))?BY2PG:(bin_size-i);    bcopy((void *)(bin+i),(void *)(page2kva(p)),size);&#125;&#x2F;*sgsize考虑方法与上面相同*&#x2F;offset &#x3D; va+i-ROUNDDOWN(va+i,BY2PG);if(offset &gt; 0)&#123;    p&#x3D;page_looup(pgdir,(va+i),NULL);    if(p&#x3D;&#x3D;NULL)&#123;        r&#x3D;page_alloc(&amp;p);        if(r&lt;0)&#123;            return r;        &#125;        page_insert(pgdir,p,va+i,PTE_R);    &#125;    size&#x3D;BY2PG-offset;    size&#x3D;((sgsize-i)&lt;size)?(sgsize-i):size;    bzero((void*)(page2kva(p)+offset),size);    i&#x3D;i+size;&#125;while(i&lt;sgsize)&#123;    r&#x3D;page_alloc(&amp;p);    if(r&lt;0)&#123;        return r;    &#125;    page_insert(pgdir,p,va+i,PTE_R);    size&#x3D;(BY2PG&lt;(sgsize-i))?BY2PG:(sgsize-i);    bzero((void *)page2kva(p),size);    i&#x3D;i+size;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-5-思考上面这一段话，并根据自己在lab2-中的理解，回答："><a href="#Thinking-3-5-思考上面这一段话，并根据自己在lab2-中的理解，回答：" class="headerlink" title="Thinking 3.5 思考上面这一段话，并根据自己在lab2 中的理解，回答："></a><strong>Thinking 3.5 思考上面这一段话，并根据自己在lab2 中的理解，回答：</strong></h4><p><strong>•</strong> <strong>你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址?</strong></p><p><strong>答：</strong>虚拟地址。</p><p><strong>• 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？</strong></p><p><strong>答：</strong>阅读代码我们得知，该值是从<code>load_elf</code>中的<code>*entry_point = ehdr-&gt;e_entry;</code>语句中进行赋值，我们从elf文件的同一个部分读取入口值赋给entry_point，因此它对于每个进程是一样的，elf文件结构的统一决定了该值的统一。</p><h4 id="Thinking-3-6-请查阅相关资料解释，上面提到的epc是什么？为什么要将env-tf-pc设置为epc呢？"><a href="#Thinking-3-6-请查阅相关资料解释，上面提到的epc是什么？为什么要将env-tf-pc设置为epc呢？" class="headerlink" title="Thinking 3.6 请查阅相关资料解释，上面提到的epc是什么？为什么要将env_tf.pc设置为epc呢？"></a><strong>Thinking 3.6</strong> <strong>请查阅相关资料解释，上面提到的epc是什么？为什么要将env_tf.pc设置为epc呢？</strong></h4><p><strong>答：</strong>《计算机组成》中介绍过EPC寄存器就是用来存放异常中断发生时进程正在执行的指令的地址的。其作用是处理完中断后可以返回到之前的位置继续执行。</p><h4 id="Thinking-3-7-关于-TIMESTACK，请思考以下问题："><a href="#Thinking-3-7-关于-TIMESTACK，请思考以下问题：" class="headerlink" title="Thinking 3.7 关于 TIMESTACK，请思考以下问题："></a><strong>Thinking 3.7</strong> <strong>关于 TIMESTACK，请思考以下问题：</strong></h4><p><strong>•</strong> <strong>操作系统在何时将什么内容存到了 TIMESTACK 区域</strong></p><p><strong>答：</strong>操作系统在发生中断时将进程的状态保存到<code>TIMESTACK</code>中，分析如下。</p><p>在stackframe.S有这样一段代码</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">.macro get_spmfc0k1, CP0_CAUSEandik1, 0x107Cxorik1, 0x1000bnezk1, 1fnoplisp, 0x82000000 &#x2F;&#x2F;测到是中断异常则将栈指针置于TIMESTACK处j2fnop1:bltzsp, 2fnoplwsp, KERNEL_SPnop2:nop.endm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的功能为获取栈指针的值，若检测到是中断异常则将栈指针置于<code>TIMESTACK</code>处，这样在发生中断时我们就能将当前进程的状态存入<code>TIMESTACK</code>处，从而进行保存。</p><p><strong>•</strong> <strong>TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同</strong></p><p>将栈指针设在<code>TIMESTACK</code>还是<code>KERNEL_SP</code>与<code>CP0_CAUSE</code>有关，在发生中断时将进程的状态保存到<code>TIMESTACK</code>中，在发生系统调用时，将进程的状态保存到<code>KERNEL_SP</code>中。</p><h4 id="Thinking-3-8-试找出上述-5-个异常处理函数的具体实现位置。"><a href="#Thinking-3-8-试找出上述-5-个异常处理函数的具体实现位置。" class="headerlink" title="Thinking 3.8 试找出上述 5 个异常处理函数的具体实现位置。"></a><strong>Thinking 3.8</strong> <strong>试找出上述 5 个异常处理函数的具体实现位置。</strong></h4><p><strong>答：</strong><code>handle_int</code>可以在genex.S中直接找到。其定义为如下代码</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">NESTED(handle_int, TF_SIZE, sp).set    noat&#x2F;&#x2F;1: j 1bnopSAVE_ALLCLI.set    atmfc0    t0, CP0_CAUSEmfc0    t2, CP0_STATUSand t0, t2andi    t1, t0, STATUSF_IP4bnez    t1, timer_irqnopEND(handle_int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过grep查找，可以找到<code>handle_tlb,handle_mod,handle_reversed</code>三个函数都与genex.S有关，但是我在genex.S中并未找到定义他们的代码。但是我在最后找到了与他们相关的函数，<code>do_reserved</code>与<code>handle_reversed</code>相关，<code>handle_tlb</code>与<code>do_refill</code>相关。虽然没有完全明白这里mips代码的含义，但是可以推测，除了<code>handle_sys</code>的另外四个函数都定义在<code>genex.S</code>中。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">BUILD_HANDLER reserved do_reserved cliBUILD_HANDLER tlb   do_refill   cliBUILD_HANDLER mod   page_fault_handler cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于<code>handle_sys</code>函数，我们可以直接找到他在syscall.S中实现。</p><h4 id="Thinking-3-9-阅读-kclock-asm-S-和-genex-S-两个文件，并尝试说出-set-timer-和timer-irq-函数中每行汇编代码的作用"><a href="#Thinking-3-9-阅读-kclock-asm-S-和-genex-S-两个文件，并尝试说出-set-timer-和timer-irq-函数中每行汇编代码的作用" class="headerlink" title="Thinking 3.9 阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和timer_irq 函数中每行汇编代码的作用"></a><strong>Thinking 3.9 阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和timer_irq 函数中每行汇编代码的作用</strong></h4><p><strong>答：</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">#include &lt;asm&#x2F;regdef.h&gt;#include &lt;asm&#x2F;cp0regdef.h&gt;#include &lt;asm&#x2F;asm.h&gt;#include &lt;kclock.h&gt;.macro  setup_c0_status set clr    .set    push    mfc0    t0, CP0_STATUS    or  t0, \set|\clr    xor t0, \clr    mtc0    t0, CP0_STATUS    .set    pop.endm    .textLEAF(set_timer)    li t0, 0xc8    sb t0, 0xb5000100    &#x2F;&#x2F;向0xb5000100 位置写入0xc8,设置时钟频率1 秒钟中断200次    sw  sp, KERNEL_SP &#x2F;&#x2F;栈指针调到KERNEL_SPsetup_c0_status STATUS_CU0|0x1001 0&#x2F;&#x2F;设置SR寄存器，使能时钟中断    jr ra    nopEND(set_timer)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>timer_irq函数</li></ul><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">timer_irq:1:jsched_yield &#x2F;&#x2F;跳转到我们实现的sched_ yield函数nop&#x2F;*li t1, 0xfflw    t0, delayaddu  t0, 1swt0, delaybeqt0,t1,1fnop*&#x2F;jret_from_exception &#x2F;&#x2F;从中断和异常返回nop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-3-10-阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。"><a href="#Thinking-3-10-阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。" class="headerlink" title="Thinking 3.10 阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。"></a><strong>Thinking 3.10 阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</strong></h4><p><strong>答：</strong>操作系统中，设置了一个进程就绪队列，并且给每一个进程添加了一个时间片，时间片在实验中即为进程的优先级priority，这个时间片起到计时的作用，时间片的时间走完，则代表该进程需要执行时钟中断操作，此时将这个进程移动到就绪队列的尾端，并复原其时间片，再让就绪队列靠前的RUNNABLE的进程执行相应的时间片段，按照这种规律实现循环往复，从而做到根据时钟周期切换进程。</p><hr><h3 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h3><h4 id="难点1：初始化新进程虚拟地址空间，即env-setup-vm函数的填写"><a href="#难点1：初始化新进程虚拟地址空间，即env-setup-vm函数的填写" class="headerlink" title="难点1：初始化新进程虚拟地址空间，即env_setup_vm函数的填写"></a>难点1：初始化新进程虚拟地址空间，即<code>env_setup_vm</code>函数的填写</h4><p><img src="https://img2020.cnblogs.com/blog/2324282/202104/2324282-20210422151222369-1152440206.png"></p><p>这个函数的编写需要我们充分理解地址空间的划分。我们的虚拟内存空间使用的是2G&#x2F;2G模式.</p><ul><li>UTOP以下是进程自己使用的，在还没用的情况下自然是清零。</li><li>ULIM以上是内核使用的，自然应该从boot_pgdir中直接拷贝。</li><li>主要是中间一部分，分别是User VPT、PAGES、ENVS。这三部分也是各有用处，PAGES对应的是之前物理页框数组pages，ENVS对应的是进程数组envs，也要从boot_pgdir中拷贝，而User VPT对应的是进程自己的页表，需要之后手动设置。</li></ul><h4 id="难点2：load-icode-mapper的编写需要考虑到多种情况"><a href="#难点2：load-icode-mapper的编写需要考虑到多种情况" class="headerlink" title="难点2：load_icode_mapper的编写需要考虑到多种情况"></a>难点2：load_icode_mapper的编写需要考虑到多种情况</h4><p><img src="https://img-blog.csdnimg.cn/20200416091854392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JpeXVlaml1emhhbw==,size_16,color_FFFFFF,t_70"></p><p>上图只是部分情况，在编写这一部分函数是需要充分考虑各种情况，必须进行充分的构思之后才可以正确的编写代码，尤其是text段与bss段的开始和结尾部分，有几种我没有考虑到，从而花费了一些时间来debug，这进一步告诉我们提前架构与设计，考虑各种情况的重要性。</p><h4 id="难点三：sched-yield进程调度算法的编写"><a href="#难点三：sched-yield进程调度算法的编写" class="headerlink" title="难点三：sched_yield进程调度算法的编写"></a>难点三：sched_yield进程调度算法的编写</h4><p>进程的调度函数sched_yeild也是本次实验的难点之一，总结的该函数主要的步骤为如下几步：</p><ol><li>设置两个队列，其中一个为目前的进程调度队列<code>q0</code>，另一个为一个空队列<code>q1</code>。</li><li>首先判断当前队列指针指向的队首进程的<code>env_status</code>.<ul><li>若为<code>ENV_FREE</code>，将该进程从队列中移除</li><li>若为<code>ENV_NOT_RUNNABLE</code>，将其插入另一个队列的尾部</li><li>若为<code>ENV_RUNNABLE</code>，判断这个进程的时间片是否用完，若用完则复原其时间片并将其插入到另一个队列尾部</li><li>当一个队列为空时，通过<code>point = 1-point</code>将指针转移到另一个队列队首</li></ul></li></ol><h3 id="体会与感悟"><a href="#体会与感悟" class="headerlink" title="体会与感悟"></a>体会与感悟</h3><ul><li>需要提前架构好设计，考虑到各种情况，不能急着写代码</li></ul><p>在load_icode_mapper里，我因为少考虑了一些情况而花费了许多时间去debug。关于提前设计不能只在脑中构思，这样的凭空构思很容易少考虑情况，在纸上进行一些简单的绘图和记录，能够列举更全面的情况，根据这样的构思设计编代码，正确性会更高。</p><ul><li>理论课的重要性</li></ul><p>在本次Lab3-extra的实验中，我因为理论课知识的不扎实而完美的理解错了题意😇，没有做出Extra，遗憾的错过了加分机会。在Extra实验中，需要我们实现PV原语操作，题目中有两种资源分别用1,2表示，且他们的数目可以有多个。然而，由于我理论课知识的缺失，在我的设计架构中，我用flag1，flag2来记录他们是否持有资源1，资源2，但我错误的认为一个进程拥有某一资源的数目只能唯一（即一个进程不能拥有多个资源1），导致了我只要释放一个资源，其对应的flag变为0，这在现在看来显然是错误的（属于是追悔莫及了），我应该将flag换成一个计数器count，进程拥有count1，count2记录拥有资源1，资源2的数目，根据count1,count2就可以正常的进行设计和输出status。</p><p>这次实验中，我对进程的理解更加深刻了，结合理论课知识的学习，我在实验课上更加了解了一个进程在操作系统中是如何组织，如何创建，如何运行，发生异常如何处理等实际过程，是一种理论课所无法带来的直观感，我想这也是实验课的价值所在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022操作系统Lab2实验报告</title>
      <link href="/2022/05/09/2022-cao-zuo-xi-tong-lab2-shi-yan-bao-gao/"/>
      <url>/2022/05/09/2022-cao-zuo-xi-tong-lab2-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h3 id="Lab2实验报告"><a href="#Lab2实验报告" class="headerlink" title="Lab2实验报告"></a>Lab2实验报告</h3><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h4><ul><li><strong>在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？</strong></li></ul><p><strong>答</strong>：指针变量中存储的地址是虚拟地址</p><ul><li><strong>MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？</strong></li></ul><p><strong>答</strong>：使用的是物理地址。</p><h4 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h4><ul><li><strong>请从可重用性的角度，阐述用宏来实现链表的好处。</strong></li></ul><p><strong>答</strong>：宏来实现链表，代码少，同时可以实现对链表的各种操作，使用时可以直接使用宏来操作链表，效率更高。</p><ul><li><strong>请你查看实验环境中的 &#x2F;usr&#x2F;include&#x2F;sys&#x2F;queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</strong></li></ul><p><strong>答</strong>：插入操作上，如果插入到某一链表项之后，三者的性能差异不大。但是如果插入到某一链表项之前，三者存在差异，<strong>对于单向链表和循环链表，因为当前链表项没有指向前一链表项的指针，无法得知前一个链表项的地址信息</strong>，因此需要<strong>循环</strong>去寻找，单向链表<strong>从链表头开始</strong>逐一寻找，循环链表由于具有循环结构，可以<strong>从当前链表项处往后</strong>逐一寻找，但是<strong>双向链表由于有指向前一链表项的指针</strong>，可以直接得知前一链表项的地址，对前一链表项进行操作，不需要循环，<strong>插入操作双向链表更加优越</strong>。</p><p>对于删除操作，也涉及到对于前一链表项的操作，对于单向链表和循环链表同样需要循环寻找前一链表项，<strong>双向链表也更加优越</strong> 。</p><h4 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h4><p>答：C是正确的</p><h4 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h4><p><strong>请你寻找上述两个 boot_* 函数在何处被调用。</strong></p><p><strong>答</strong>：在<code>mips_vm_init</code>中被调用，该函数用于初始化二级页表。</p><h4 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h4><ul><li>请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性</li></ul><p><strong>答</strong>：<code>ASID</code>是用于区分不同进程的一个标识符，操作系统可以运行多个进程，如果不使用<code>ASID</code>，那么进程切换后TLB内所有的内容都失效了，因为不同的进程虚拟地址和物理地址的映射关系不同，然而每次切换进程都要清空TLB显然不合理，因此引入<code>ASID</code>以区分不同进程，很好的解决了这一问题，TLB不需要每次切换都清空。</p><ul><li>请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量</li></ul><p><strong>答</strong>：查询后得知，<code>ASID</code>占据了<code>EntryHi</code>寄存器的6~11位共6位，因此 R3000 中可容纳不同的地址空间的最大数量为64.</p><h4 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h4><ul><li><strong>tlb_invalidate 和 tlb_out 的调用关系是怎样的？</strong></li></ul><p><strong>答</strong>：tlb_invalidate 调用tlb_out。 </p><ul><li><strong>请用一句话概括 tlb_invalidate 的作用</strong></li></ul><p><strong>答</strong>：tlb_invalidate()作用是调用tlb_out()把va对应的TLB项清空。</p><ul><li><strong>逐行解释 tlb_out 中的汇编代码</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#include &lt;asm&#x2F;regdef.h&gt;#include &lt;asm&#x2F;cp0regdef.h&gt;#include &lt;asm&#x2F;asm.h&gt;LEAF(tlb_out)&#x2F;&#x2F;1: j 1bnopmfc0k1,CP0_ENTRYHImtc0a0,CP0_ENTRYHI  &#x2F;&#x2F;1.这两条设置协处理器，读取并写入cp0的$10noptlbp&#x2F;&#x2F;2.tlbp指令，该指令检查TLB&#x2F;&#x2F;如果TLB中有项和EntryHi寄存器匹配，就把Index寄存器设置为对应的项，&#x2F;&#x2F;如果没有匹配的项，就把Index最高位设置为1nopnopnopnopmfc0k0,CP0_INDEXbltzk0,NOFOUND&#x2F;&#x2F;3.读取Index的值，如果小于零，显然没找到，那就跳转到NOFOUND，nopmtc0zero,CP0_ENTRYHImtc0zero,CP0_ENTRYLO0noptlbwi&#x2F;&#x2F;4.找到了，那就写入TLB&#x2F;&#x2F;5.并且tlbwi把ENTRYHI和ENTRYLO0写入Index所指的项NOFOUND:mtc0k1,CP0_ENTRYHIjra&#x2F;&#x2F;没有找到，恢复遍历之前的状况，跳转回之前函数nopEND(tlb_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Thinking-2-7"><a href="#Thinking-2-7" class="headerlink" title="Thinking 2.7"></a>Thinking 2.7</h4><p>*<em>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位</em>***系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 &#x3D; 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase ，请你计算：</p><ul><li><strong>三级页表页目录的基地址</strong></li></ul><p><strong>答</strong>：<code>PTbase+(PTbase/1GB)*4KB</code></p><ul><li><strong>映射到页目录自身的页目录项(自映射)</strong></li></ul><p><strong>答</strong>：<code>PTbase+(PTbase/1GB)*4KB+(PTbase/1GB)*4B</code></p><h4 id="Thinking-2-8"><a href="#Thinking-2-8" class="headerlink" title="Thinking 2.8"></a>Thinking 2.8</h4><ul><li><strong>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</strong></li></ul><p><strong>答</strong>：x86架构的内存管理机制分为两部分：分段机制和分页机制。<strong>分段机制</strong>为程序提供彼此隔离的代码区域、数据区域、栈区域，从而避免了同一个处理器上运行的多个程序互相影响。<strong>分页机制</strong>实现了传统的按需分页、虚拟内存机制，可以将程序的执行环境按需映射到物理内存。此外，分页机制还可以用于提供多任务的隔离。X86CPU发出逻辑地址，根据其中的段选择器和偏移查询全局描述符表和线性地址表得到线性地址，再通过分页，得到物理地址.</p><p>不过和MIPS不同的是，X86的分段是必须的，分页是不必须的，而且在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。 转换失败的地址则由CR3存放。</p><h3 id="实验难点："><a href="#实验难点：" class="headerlink" title="实验难点："></a>实验难点：</h3><h4 id="难点一："><a href="#难点一：" class="headerlink" title="难点一："></a>难点一：</h4><p>le_next是指针，le_prev是指向le_next的指针，是一个指针的指针，在理解LIST_INSERT_BEFORE 等函数的时候很容易绕晕，<del>本人就被绕晕了</del>，因为本身指针就比较绕，涉及到指针的指针就更绕了。以LIST_INSERT_BEFORE 为例，这里记录一下我对这一部分的理解，以防之后又被绕进去。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#define LIST_INSERT_BEFORE(listelm, elm, field) do &#123;                        \</span>                <span class="token punctuation">(</span>elm<span class="token punctuation">)</span>-<span class="token punctuation">></span>field.le_prev = <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span>-<span class="token punctuation">></span>field.le_prev;                \                //把elm的prev 直接换成 listlm的prev                                <span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span>, field<span class="token punctuation">)</span> = <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span>;                            \                //把elm的next 指向 listlm                                *<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span>-<span class="token punctuation">></span>field.le_prev = <span class="token punctuation">(</span>elm<span class="token punctuation">)</span>;                              \                //*<span class="token punctuation">(</span>listelm<span class="token punctuation">)</span>-<span class="token punctuation">></span>field.le_prev 相当于取到原来listlm的前一个元素的next，将其指向elm                //这里很巧妙，双重指针的用处就在这里，用来修改前一个元素的next指针                                <span class="token punctuation">(</span>listelm<span class="token punctuation">)</span>-<span class="token punctuation">></span>field.le_prev = &amp;<span class="token function">LIST_NEXT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>elm<span class="token punctuation">)</span>, field<span class="token punctuation">)</span>;            \                //最后修改listlm的prev。让其指向elm的next，这里因为是双重指针，所以要用到&amp;取址        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>梳理好之后，终于才算是不绕了！</p><h4 id="难点二"><a href="#难点二" class="headerlink" title="难点二"></a>难点二</h4><p>关于二级页表的结构这一知识点，同样具有难度。其大致结构为我们首先需要将虚拟地址按照规定的结构拆分，得到页目录项，页表项以及偏移，并随着二级页表结构逐层向下查找，最终在根据页表查询的基地址加上偏移得到相应的物理地址。如下图:</p><p><img src="https://note.youdao.com/yws/api/personal/file/957CECEBA37D4283828C862617E53B9A?method=download&shareKey=074ceb5ddfb351b56b2b8e96c105764c" alt="a"></p><h4 id="难点三"><a href="#难点三" class="headerlink" title="难点三"></a>难点三</h4><p>在本次实验中涉及到很多页面地址转换，虚拟地址与物理地址的转换，需要深刻理解和掌握才能熟练应用，在本次实验中我进行了整理记录</p><ul><li><strong>page2pa：得到某个page结构体的物理地址</strong></li><li><strong>pa2page：得到某个物理地址所对应的Page结构体，是page2pa的逆操作</strong></li><li><strong>page2kva：得到某个Page结构体的内核虚拟地址</strong></li><li><strong>page2ppn：由页面得到对应的物理页号，因为Page对象在内存中是连续分布的所以可以直接减去首地址得到。</strong></li><li><strong>PADDR：将某个内核虚拟地址转化为物理地址</strong></li><li><strong>KADDR：将某个物理地址转化为内核虚拟地址</strong></li></ul><h3 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h3><p>这次的实验中，我感受到了很大的难度和极高的挑战度。首先是二级页表的知识，自映射相关的知识、虚拟，物理地址的知识我在理论课上没有掌握的很好。而做好课下课上实验必须要有理论知识的指导，理论知识的缺乏让我对这次<code>Lab2</code>实验感受到一定的难度。也算是在这次实验中得到了一个教训，实验做好的基础一定要把理论知识学好，在今后我将投入更多的时间和精力来扎实巩固我的理论知识。</p><p> 在lab2中，我更加体会到了熟练阅读代码，理解代码的重要性。lab2的大部分代码补全基本全部集中在pamp.c这一个函数中，在地址转化等操作中，所用到的函数和宏函数很多，他们之间的关系理解起来也有难度。如果想要让自己的实验进行更加顺利，需要对系统中的每一个代码都进行理解性阅读，搞清楚这个代码封装了哪些函数，主要用于实现哪些功能，只有这样，才能在使用函数时能够得心应手，节省时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种PV操作问题总结</title>
      <link href="/2022/05/09/ji-chong-pv-cao-zuo-wen-ti-zong-jie/"/>
      <url>/2022/05/09/ji-chong-pv-cao-zuo-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="OS-Homework-4"><a href="#OS-Homework-4" class="headerlink" title="OS Homework 4"></a>OS Homework 4</h2><hr><h3 id="1-1-读者写者问题（写者优先）"><a href="#1-1-读者写者问题（写者优先）" class="headerlink" title="1.1 读者写者问题（写者优先）"></a>1.1 读者写者问题（写者优先）</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>首先读者写者问题肯定需要一个<code>mutex</code>信号量保护缓冲区。</p></li><li><p>用read变量实现写优先，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。</p></li><li><p><code>readcount,writecount</code>两个int变量记录读者写者数量，用于改变<code>read</code>信号量，相应的有<code>rcmutex，wcmutex</code>两个信号量保护他们读写的互斥。</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;实现读者写者问题（写者优先）int readcount &#x3D; 0 ;&#x2F;&#x2F;记录当前读者数量 int writecount &#x3D; 0; &#x2F;&#x2F;记录写者数量semaphore rcmutex &#x3D; 1; &#x2F;&#x2F;保护更新readcount变量时的互斥 semaphore wcmutex &#x3D; 1;&#x2F;&#x2F;保护更新writecount变量的互斥 semaphore read &#x3D; 1;&#x2F;&#x2F;信号量read，初值是1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。semaphore filemutex &#x3D; 1;&#x2F;&#x2F;临界资源互斥 &#x2F;&#x2F;写者 writer() &#123;while(1) &#123;P(wcmutex);&#x2F;&#x2F;申请writecount资源 if(!writecount) &#x2F;&#x2F;说明这是第一个写者，这时申请read用于阻塞后续读者 P(read);&#x2F;&#x2F;阻塞读者writecount++;V(wcmutex) &#x2F;&#x2F;释放writecount            &#x2F;&#x2F;进入临界区P(filemutex)&#x2F;&#x2F;临界区代码writing();V(filemmutex)&#x2F;&#x2F;出临界区            P(wcmutex);writecount--;&#x2F;&#x2F;该写者操作完毕，计数器减一if(!writecount)&#x2F;&#x2F;如果是当前等待队列最后一个写者，释放read锁，不再阻塞读者V(read);V(wcmutex) &#125;&#125;&#x2F;&#x2F;读者reader() &#123;while(1) &#123;P(read);&#x2F;&#x2F;如果有写者在等待，则轮不到读者，读者一直被阻塞P(rcmutex);if(!readcount) &#x2F;&#x2F;只有第一个读者申请临界资源锁，因为要实现共享读，后续读者无需申请，直接进入临界资源读取P(filemutex);readcount++;V(rcmutex);V(read);&#x2F;&#x2F;这是一个理解难点，我们需要及时释放read锁，如果这时来了一个写者就能够继续及时阻塞读者，实现写者优先&#x2F;&#x2F;临界代码 reading();P(rcmutex);readcount--;if(!readcount)&#x2F;&#x2F;如果读者队列已空，释放临界区资源V(file);V(rcmutex); &#125;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-寿司店问题"><a href="#1-2-寿司店问题" class="headerlink" title="1.2 寿司店问题"></a>1.2 寿司店问题</h3><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><ul><li>通过eating，waiting记录当前正在eat的线程个数和等待的线程个数。eating用于改变must_wait变量（eating&#x3D;&#x3D;5使，must_wait &#x3D; true，eating&#x3D;&#x3D;0时 为false）。waiting用于放人进来eat，当eating &#x3D;&#x3D; 0时，放n &#x3D; min(5,waiting)个人进来。对这两个变量需要一个mutex即可，因为二者是一个整体，在操作这两个变量是我们需要同时操作。</li><li>must_wait线程在申请时首先判断该变量，该变量为true说明已经有5人</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int eating &#x3D; 0, waiting &#x3D; 0;Semaphore mutex &#x3D; 1, queue &#x3D; 1;bool must_wait &#x3D; false;Customer()&#123;  P(mutex);  if (must_wait)&#123;    waiting++;    V(mutex); &#x2F;&#x2F;对waiting变量的保护可以释放    P(queue);&#x2F;&#x2F; 被阻塞，坐着等待排队，等待被唤醒  &#125;  else &#123;    eating++;    must_wait &#x3D; (eating &#x3D;&#x3D; 5)     &#x2F;&#x2F; 一旦我是最后一个来坐下吃导致人满的就要等所有人一起吃完，好难过    V(mutex);&#x2F;&#x2F; 对eating变量的保护可以释放  &#125;  &#x2F;&#x2F; 上一部分已经解决了进店后是等待还是吃的问题  Eat_sushi();&#x2F;&#x2F; else的人和被唤醒的排队者成功进入这一步  P(mutex);   &#x2F;&#x2F; 开启对eating, waiting变量保护  eating--;&#x2F;&#x2F; 吃的人-1,如果5个没全吃完，不可以换下一批人吃  if (eating &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F; 最后一个吃完的人离开才可以进顾客    int n &#x3D; min(5, waiting);&#x2F;&#x2F; 放顾客进来的数量，不超过5个    waiting -&#x3D; n;    eating +&#x3D;n;    must_wait &#x3D; (eating &#x3D;&#x3D; 5)    for(int i &#x3D; 0; i&lt;n; i++)      V(queue);  &#x2F;&#x2F; 唤醒排队的n个人继续进程  &#125;  V(mutex);&#x2F;&#x2F; 允许下一个吃完的人对变量和队列进行操作&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-三个进程的奇偶数消费者-生产者问题"><a href="#1-3-三个进程的奇偶数消费者-生产者问题" class="headerlink" title="1.3 三个进程的奇偶数消费者-生产者问题"></a>1.3 三个进程的奇偶数消费者-生产者问题</h3><h4 id="实现思路：-1"><a href="#实现思路：-1" class="headerlink" title="实现思路："></a>实现思路：</h4><ul><li>P1为生产者，P2，P3分别为奇偶数消费者，三者共享一个缓冲区，首先肯定需要一个mutex信号量互斥整个缓冲区，接着需要一个empty信号量让生产者可以申请空缓冲区用于生产，目前为止与普通的生产者消费者模式相同。</li><li>但是由于P2只取奇数，P3只取偶数，因此原先我们用的full信号量相当于要分成两个，odd与even，用于代表当前装有奇数、偶数缓冲区的个数，其跟原先我们使用的full的作用一样。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define N 100Semaphore empty &#x3D; N;  &#x2F;&#x2F; 假设初始条件下缓冲区有N个空位Semaphore mutex &#x3D; 1;Semaphore odd &#x3D; 0;Semaphore even &#x3D; 0;void P1()&#123;  int integer;  while(true)&#123;    integer &#x3D; produce(); &#x2F;&#x2F; 生成一个整数    P(empty); &#x2F;&#x2F; down(empty)，若empty为0则会被阻塞（等待别人拿走）    P(mutex);&#x2F;&#x2F; 开始互斥，down(mutex)    put();&#x2F;&#x2F; 放入缓冲区    V(mutex);&#x2F;&#x2F; 访问临界区结束，up(mutex)    if(integer %2 &#x3D;&#x3D; 0)&#123;      V(even);&#x2F;&#x2F; 是偶数    &#125; else &#123;      V(odd);&#x2F;&#x2F; 是奇数    &#125;  &#125;&#125;void P2()&#123;  while(true)&#123;    P(odd);&#x2F;&#x2F; 请求一个奇数，down(odd)    P(mutex);&#x2F;&#x2F; 互斥    getodd();    V(mutex);    V(empty);&#x2F;&#x2F; 缓冲区多一个位置，up(empty)    countodd();  &#125;&#125;void P3()&#123;  while(true)&#123;    P(even);&#x2F;&#x2F; 请求一个偶数，down(even)    P(mutex);&#x2F;&#x2F; 互斥    geteven();    V(mutex);    V(empty);&#x2F;&#x2F; 缓冲区多一个位置，up(empty)    counteven();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-搜索-插入-删除问题-类似读者写者问题"><a href="#1-4-搜索-插入-删除问题-类似读者写者问题" class="headerlink" title="1.4 搜索-插入-删除问题(类似读者写者问题)"></a>1.4 搜索-插入-删除问题(类似读者写者问题)</h3><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路:"></a>实现思路:</h4><ul><li>定义信号量No_search &amp; No_insert表示此时没有搜索和插入线程，用于删除线程与插入线程，删除线程与搜算线程互斥，同时由于一个删除线程P(No_insert)以后，其他删除线程再次P(No_insert)便会阻塞，所以No_insert顺便也可以作为删除进程之间互斥。</li><li>信号量<code>insertMutex， searchMutex</code>用于保护searcher,inserter这两个int变量，他俩的作用是记录插入搜索线程的数量，以改变No_search &amp; No_insert（如果数量为零则释放）。</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">Semaphore insertMutex &#x3D;1, searchMutex &#x3D; 1; &#x2F;&#x2F; 保护searcher,inserter变量Semaphore No_search &#x3D; 1; &#x2F;&#x2F; 顾名思义，为1时没有搜索进程访问Semaphore No_insert &#x3D; 1; &#x2F;&#x2F; 为1时没有插入进程访问&#x2F;&#x2F;当上述两个信号量同时为1，删除者才可以进行删除操作int searcher &#x3D; 0, inserter &#x3D; 0;void Search()&#123;  P(searchMutex);    searcher++;    if (searcher &#x3D;&#x3D; 1)&#x2F;&#x2F; 第一个进来的搜索者加锁      P(No_search)  V(searchMutex);  Searching(); &#x2F;&#x2F; 访问临界区，多个搜索无需互斥  P(searchMutex);  searcher--;  if (searcher &#x3D;&#x3D; 0)      V(No_search); &#x2F;&#x2F; 表示此时没有搜索线程在进行，解锁  V(searchMutex);&#125;void Insert()&#123;  P(insertMutex);  inserter++;  if (inserter &#x3D;&#x3D; 1)      P(No_insert);  V(insertMutex);    P(insertMutex); &#x2F;&#x2F; 既然可以和搜索线程并行，那么不用管Searcher  Inserting();&#x2F;&#x2F; 访问临界区，多个插入者要互斥访问，一次一个insert  V(insertMutex);    P(insertMutex);  inserter--;  if (inserter &#x3D;&#x3D; 0)      V(No_insert); &#x2F;&#x2F; 解锁，可唤醒删除者  V(insertMutex);&#125;void Delete()&#123;  &#x2F;&#x2F; 删除线程与其他任何线程互斥  P(No_search);  P(No_insert); &#x2F;&#x2F; 若为1则可进入，这个信号量顺便也可以当作删除者的互斥保护  Deleting();&#x2F;&#x2F; 搜索和插入线程都没，成功进入临界区  V(No_insert);  V(No_search);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象第1单元作业总结</title>
      <link href="/2022/05/09/mian-xiang-dui-xiang-di-1-dan-yuan-zuo-ye-zong-jie/"/>
      <url>/2022/05/09/mian-xiang-dui-xiang-di-1-dan-yuan-zuo-ye-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是对第一次面向对象课程作业的总结，文章首先总结了本次作业我的总体架构思路，接着分析了三次作业中我的架构迭代历程，之后对于我的最终架构给出了代码度量分析，且分析了架构的优缺点。之后文章分析了在Hack过程中的收获，以及在本次作业设计，编写中我学到的东西，尤其是<strong>关于深浅克隆</strong>这一部分我分享了我认为比较好的一些资料，和我自己的理解，希望uu们不要跟我一样在这一知识点再犯错误。最后文章阐述了本次作业中我的心得体会。文章如有错误，谢谢指正！</p><hr><h3 id="一-总体架构思路"><a href="#一-总体架构思路" class="headerlink" title="一.总体架构思路"></a>一.总体架构思路</h3><p>在本次作业中，我们的最终需求是对一个表达式进行化简计算，并进行一些必要的合并与优化。然而要进行计算，首要任务是进行表达式的解析。总而言之，要完成解析和计算这两个需求，我设计了如下架构，我的架构简而言之是：递归向下解析，自底向上计算，输出前再进行合理优化。形象化的表示一下就是如下的流程图。</p><p><img src="https://note.youdao.com/yws/api/personal/file/57F941BFE671421C9AF4B1001A2B78E1?method=download&shareKey=c636f34fcf32c9ad8e157a213642308c"></p><p>在我的架构中，将表达式抽象为了<strong>四个层次</strong>，在作业指导书中，由于已经给出了表达式的形式化表示，我们可以很容易抽象出以下层次：</p><ul><li><p><code>Expr</code>：表达式层</p></li><li><p><code>Term</code>：<code>Expr</code>以<code>+-</code>的形式包含多个<code>Term</code>项层</p></li><li><p><code>Factor</code>：<code>Term</code>项以<code>*</code>形式包含多个<code>Factor</code>因子</p></li><li><p><code>Element</code>:上述三个层次均包含一个属性，其类型是一个<code>Element</code>数组，有了<code>Element</code>层，方便进行自底向上的运算。</p><ul><li><p>在第一次作业中 <code>Element = a*x**b</code></p></li><li><p>在第二、三次作业中 <code>Element = a*x*b*[sin][cos]</code>,其中<code>[sin][cos]</code>指<code>Sin、Cos</code>类的数组</p></li></ul></li></ul><p>有了以上这些层次，我们首先对输入进行递归向下解析，解析出表达式中包含哪些层次，经过自底向上的计算，可以得到每个层次的<code>[Elements]</code>数组，最终得到的<code>Expr</code>表达式的<code>[Elements]</code>数组便是我们得到的初步计算结果，经过合并同类项等优化便可以进行输出。</p><h3 id="二-迭代过程"><a href="#二-迭代过程" class="headerlink" title="二.迭代过程"></a>二.迭代过程</h3><p>在这一部分简要阐述了我的三次迭代心路历程，其中并没有放<code>UML</code>类图，因为三次作业我没有做大规模的重构，三次作业的<code>UML</code>类图重复相似部分较多，我将会在<strong>代码度量分析</strong>一节中分析<code>UML</code>类图，其中标明了每次作业的新增与修改部分。</p><h4 id="2-1第一次作业"><a href="#2-1第一次作业" class="headerlink" title="2.1第一次作业"></a>2.1第一次作业</h4><ul><li><strong>分析</strong></li></ul><p>在第一次作业中，首次上手<code>java</code>作业打了我一个措手不及，因为之前写的都是流程式的程序，开始时构思面向对象式的架构没有很好地思路，属于是一头雾水了，花了很多时间去理解题目并和同学交流，并且在助教给的训练项目中也得到了一些启发，最终构思了上述的程序架构。</p><ul><li><strong>解析方法上</strong>，在<code>HW1</code>中，由于因子层面只有常数因子，变量因子与表达式因子，总的来说类型较少，因此采用了<strong>正则表达式</strong>进行识别，识别流程示意图如下：</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/B8460413ACA241C7BC617C8C8BBF9BD0?method=download&shareKey=f982690aadfddbd60e53a6b8e044d3e6" alt="HW1"></p><ul><li><p><strong>计算方法上</strong>，在<code>HW1</code>中，涉及到<code>a*x**b</code>之间的乘法与加减法，只需系数与系数的计算，指数与指数的计算，不再赘述，但在这里我<strong>第一次遇到了深克隆和浅克隆的问题</strong>，这个问题在本次作业中多次困扰我，这一问题在之后的Bug部分详细阐述。</p></li><li><p><strong>优化方法上</strong>，由于最后的形式是许多<code>a*x**b</code>进行相加，优化方法上只涉及到合并同类项，之后输出时再进行简单的优化即可，例如指数为1不输出指数，变量因子系数为1不输出系数等。</p></li></ul><h4 id="2-2第二次作业"><a href="#2-2第二次作业" class="headerlink" title="2.2第二次作业"></a>2.2第二次作业</h4><ul><li><strong>分析</strong></li></ul><p>在本次作业中，新增了自变量函数，求和函数，三角函数三种因子,这要求我们对新增的这三种因子进行识别与计算。此外，由于在解析<code>f与sum</code>时需要进行自变量的替换，替换后可能出现表达式括号嵌套的形式，这要求架构中的解析过程要支持嵌套括号的形式，这是本次作业一个潜在的需求。</p><ul><li><strong>重构解析方法</strong>：在本次解析过程中，由于因子的形式多样，如果继续使用正则表达式进行识别，一来<strong>正则表达式很难准确构造</strong>，二来由于<strong>正则式的不准确所带来的潜在Bug</strong>也比较多。因此我对每个层次<strong>解析方法</strong><code>Parse</code>进行了重构，<strong>采用类似栈的方法，对括号层数进行解析，根据当前括号所处的层数和简单的字符判断</strong>，可以依此解析出<code>Term</code>，<code>Factor</code>等层次。这样写的好处是不需要绞尽脑汁构造正则表达式，正确性也容易验证，对于新增的几个因子<ul><li><code>sin，cos</code>，将括号内的内容当做<strong>常数或变量因子</strong>重新解析</li><li><code>f,sum</code>因子，进行字符串的替换，展开等处理后看做<strong>表达式</strong>重新解析</li></ul></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/7AF67256C2514CF19598F5D26B99EB90?method=download&shareKey=04f263d33be4bd685246b3268522028e" alt="HW2"></p><ul><li><p><strong>修改计算方法</strong>：</p><p>本次作业中的计算，不仅仅是<code>a*x**b</code>之间的乘法与加减法,此时<code>Element</code>是<code>a*x*b*[sin][cos]</code>，需要修改两处：</p><ul><li><code>[Elements]*[Elements]</code>,除了修改系数a，指数b，另需要将二者[sin][cos]数组合并，这里又涉及到了深拷贝与浅拷贝问题。然而<strong>梅开二度</strong>，我在这里又没有意识到犯了浅拷贝这个“错误”，虽然<code>HW2</code>中没有出现问题，但导致我在<code>HW3</code>优化二倍角时出现了错误，这里会在Bug部分详细阐述。</li><li><code>[Elements]+-[Elements]</code>，这里需要修改<code>equals</code>方法，合并同类项时考虑[sin][cos]数组是否一致。</li></ul></li><li><p><strong>新增优化方法</strong>：</p><ul><li>在解析过程中进行初步优化，对于<code>sin(0),cos(0),sin()**0,cos()**0</code>，<strong>在解析的过程中就将其解析为对应常数</strong>，进行初步优化。</li><li>三角函数计算的优化<ul><li>在<code>HW2</code>，因为时间关系，只增加了简单的<code>Acos(B)**2+Asin(B)**2=A</code>的合并，其中<code>A</code>是任意项，<code>B</code>是三角函数内的常数或变量因子。</li></ul></li></ul></li></ul><h4 id="2-3第三次作业"><a href="#2-3第三次作业" class="headerlink" title="2.3第三次作业"></a>2.3第三次作业</h4><ul><li><strong>分析</strong></li></ul><p>在本次作业中，新增了函数间的相互调用，三角函数内嵌套等新需求。关于函数之间的相互调用，在<code>HW2</code>中对于自定义函数的处理方法是，进行自变量的替换后直接看做表达式进行处理，因此<code>HW2</code>架构已经可以实现函数之间的互调用。在本次作业中主要实现了三角函数的内嵌套，相较于第二部分修改较少。</p><ul><li><strong>修改解析方法</strong>，  如上文所述，此次迭代，<strong>只需要修改三角函数内部嵌套部分的解析方式</strong>。显而易见，将括号内部的部分当做<code>Expr</code>表达式继续解析即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/B2F525E399E9490CB1FA8989B96B8A67?method=download&shareKey=6e17a41843a7f8ff4de21666f5b379e6"></p><ul><li><strong>计算方法</strong>：不需要修改。</li><li><strong>新增优化方法</strong><ul><li>二倍角公式，在<code>HW3</code>中实现了二倍角的简化，<code>2Asin(B)cos(B) = Asin(2B)</code>,<strong>遗憾的是这里将<code>HW2</code>中的Bug显现了出来</strong>，因为在优化时对B进行了系数的加倍，而在计算时采用的<strong>浅克隆方式</strong>，修改B导致了其他某些<code>sin</code>，<code>cos</code>内部的内容也随之修改。</li></ul></li></ul><h3 id="三-代码度量分析"><a href="#三-代码度量分析" class="headerlink" title="三.代码度量分析"></a>三.代码度量分析</h3><p>先放一下<code>HW3</code>最终的<code>UML</code>类图</p><p><img src="https://note.youdao.com/yws/api/personal/file/04BAF07845ED401195D6536C1582A325?method=download&shareKey=a2b0020feda0fa741dccb15900e18342"></p><ul><li><p>第二次作业修改了<code>Caculate</code>内的方法，新增<code>Sin,Cos</code>,自定义函数<code>Fun,Sum</code>类，修改了<code>Element</code>属性，其他<code>UML</code>部分与第一次作业基本相同。</p></li><li><p>第三次作业修改了<code>Sin,Cos</code>内部属性，同时更新了<code>Caculate</code>计算方法，其他<code>UML</code>类基本未做变动。</p></li><li><p>优缺点分析</p><ul><li>优点是进行了比较系统的抽象，不同层次代表了表达式中不同的组合，</li><li>缺点是首先<code>Sin，Cos</code>两个类基本相同，可以合并，在编写代码时我为了区分<code>Cos，Sin</code>，创建了两个类，但其实二者基本相同，完全可以合并为一个类，以减少复杂度。此外，代码之间内在的的关联度高，不容易达到“高内聚低耦合”的原则，程序的结构化程度不是很好。</li></ul></li></ul><p>之前我并未接触过代码度量的含义，了解之后学习到其一些指标含义如下：</p><ol><li><code>CogC</code>：认知复杂度，反应一个方法的可理解性，循环分支等结构越多，可理解性越差，数值越高。</li><li><code>ev(G)</code>:基本复杂度是用来衡量程序非结构化程度的。</li><li><code>Iv(G)</code>:模块设计复杂度是用来衡量模块判定结构，即模块和其他模块的调用关系,越高说明模块和其他模块之间的调用关系复杂，耦合程度越高.</li><li><code>v(G)</code>:是用来衡量一个模块判定结构的复杂程度，数量上表现为独立路径的条数,数值越高说明程序越难以维护</li></ol><p><strong>方法复杂度</strong></p><table><thead><tr><th>PreFun.printans(ArrayList)</th><th>48.0</th><th>3.0</th><th>16.0</th><th>17.0</th></tr></thead><tbody><tr><td>PreFun.mergecs2(ArrayList)</td><td>42.0</td><td>10.0</td><td>9.0</td><td>12.0</td></tr><tr><td>Factor.parse()</td><td>31.0</td><td>4.0</td><td>12.0</td><td>15.0</td></tr><tr><td>Element.matchcs(Element)</td><td>30.0</td><td>9.0</td><td>10.0</td><td>12.0</td></tr><tr><td>Element.Element(String)</td><td>28.0</td><td>1.0</td><td>15.0</td><td>18.0</td></tr><tr><td>Fun.parse()</td><td>26.0</td><td>3.0</td><td>10.0</td><td>11.0</td></tr><tr><td>PreFun.neg(ArrayList)</td><td>19.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Expr.parse()</td><td>12.0</td><td>1.0</td><td>8.0</td><td>9.0</td></tr><tr><td>Term.parse()</td><td>12.0</td><td>1.0</td><td>7.0</td><td>8.0</td></tr><tr><td>PreFun.addcos(StringBuilder, Element)</td><td>10.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>PreFun.addsin(StringBuilder, Element)</td><td>10.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>PreFun.issingle(ArrayList)</td><td>8.0</td><td>5.0</td><td>11.0</td><td>12.0</td></tr><tr><td>Cos.cossequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Element.elementsequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>PreFun.mergecs(ArrayList)</td><td>7.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Sin.sinsequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr></tbody></table><p><strong>（由于方法较多，篇幅限制只列出了分析结果中数值较大，标红的部分数据。）</strong></p><p><strong>接下来进行代码度量结果的分析</strong>：</p><ul><li><p>从<strong>方法复杂度</strong>来看，可以看出其集中出现在<code>PreFun</code>内的优化函数上，原因是我在优化过程中采用的<code>for</code>与<code>if-else</code>较多，为优化性能对许多情况进行分别讨论，这导致了复杂度过高，这从某种程度上说明了我在优化部分容易出错的原因。</p></li><li><p>同时每个类内<code>Parse</code>方法，和<code>Element</code>方法的实现也比较复杂，这是因为<strong>耦合性过强</strong>，例如在我的架构中，他们都是为<strong>解析功能</strong>服务的函数，<code>Expr</code>的<code>parse</code>需要依赖<code>Term</code>中的<code>Parse</code>，而<code>Term</code>的<code>Parse</code>又需要依赖<code>Factor</code>的<code>Parse</code>，<strong>方法之间的依赖性很强</strong>，不容易达到“高内聚低耦合”的原则，程序的结构化程度不是很好。</p></li></ul><h3 id="四-Hack与被Hack"><a href="#四-Hack与被Hack" class="headerlink" title="四.Hack与被Hack"></a>四.Hack与被Hack</h3><h4 id="4-1-个人Bug发现与分析"><a href="#4-1-个人Bug发现与分析" class="headerlink" title="4.1 个人Bug发现与分析"></a>4.1 个人Bug发现与分析</h4><p>关于本次作业的Bug较多的集中在<strong>深克隆与浅克隆</strong>这个问题上，这可能与我的代码架构有关，在对<code>ArrayList</code>操作时使用了较多的<code>add</code>方法。</p><p>在一次作业中我首次遇到了深克隆与浅克隆的问题，但在课下时我已经发现了这个Bug并予以解决。但在第二次作业时，又再一次出现了深克隆浅克隆的问题，这个Bug原因是我在计算<code>[Elements]</code>数组时为了实现合并两数组的[sin][cos]，直接采用了<code>add</code>方法，因为第二次作业我并未对<code>Sin</code>,<code>Cos</code>内部进行操作，所以当时我认为直接采用<code>add</code>方法是正确的，简便的，因而这个Bug在第二次作业时并没有显现。</p><p>然而在第三次作业中，在优化部分我新增了<strong>二倍角优化方法</strong>，直接对<code>Sin</code>,<code>Cos</code>内部项的系数进行了操作，此时我忽略了之前采用<code>add</code>方法合并数组时采用了浅克隆而非深克隆，直接引发了第二次作业所埋下的隐患。<del>以后再也不瞎优化了(bushi</del>,所以有时候不优化，保证正确性可能会更好一点。不过言归正传，这个Bug十分隐蔽，我在课下并没有发现，导致一个强测点直接寄掉。</p><p>这个Bug出现的原因有二：</p><ul><li><p>一方面是因为对于深克隆浅克隆的理解还是不够深刻，在编写代码是没有意识到自己当前所写代码实际上是再进行克隆操作，也没有进一步思考这里的克隆是需要深克隆还是浅克隆，在第二次作业中我采用的浅克隆方式对于<code>HW2</code>的需求来说是<strong>“正确”</strong>的(因为恰巧第二次作业中<code>sin</code>，<code>cos</code>内部只有常数与自变量，不需要对其内部进行操作)，但其实是并<strong>不合理</strong>的，因为在架构中需要新构造一个项，进一步思考不难意识到我们需要的实际上是深克隆，关于深浅克隆的问题，为了加深我自己的理解，将在“我学到的”这一部分进行进一步阐述。</p></li><li><p>另一方面是因为在作业迭代的过程中，上一次作业的某些架构在本次作业中埋下了隐患。在进行作业的迭代时，编写完代码后我只检查了本次修改的，迭代的代码正确性，“理所当然的认为”之前的代码都通过了上一次强测，那肯定是正确的吧。但事实证明这样做法是错误的，我忽略了两次迭代之间的关联性，新增的需求可能会是上次架构中**”正确”但不合理<strong>的操作变为Bug。以后的作业中，应该</strong>有意识的去思考迭代过程中两次架构中有哪些可能产生Bug的关联之处，不能只着眼与本次作业的新增部分、修改部分，**以防止这种现象的发生。</p></li></ul><h4 id="4-2-互测他人Bug发现与分析"><a href="#4-2-互测他人Bug发现与分析" class="headerlink" title="4.2 互测他人Bug发现与分析"></a>4.2 互测他人Bug发现与分析</h4><p>本次互测发现了其他同学如下几个Bug</p><ul><li><code>-1+1</code>等简单的操作无法输出，这一Bug产生的原因是一些同学的架构进行迭代优化后，由于架构的不合理性，反而无法实现最基本的测试点，这也提醒了我们测试全面覆盖的重要性。</li><li><code>sum</code>上下界定义为了<code>int</code>，而非<code>BigInteger</code>，这一Bug产生的原因我认为可能是没有仔细阅读指导书，先入为主习惯性的将一些整数定义为了<code>int</code>，测试时</li><li><code>sum(i,下界,上界,i**2)</code>出现了问题，这一Bug产生的原因是进行字符串替换时没有加括号，这里的<code>i</code>是常数，只有替换时<strong>加括号</strong>才是正确的形式化表述。</li></ul><h3 id="五-我学到的"><a href="#五-我学到的" class="headerlink" title="五.我学到的"></a>五.我学到的</h3><h4 id="5-1-深克隆与浅克隆"><a href="#5-1-深克隆与浅克隆" class="headerlink" title="5.1 深克隆与浅克隆"></a>5.1 深克隆与浅克隆</h4><p><strong>深克隆与浅克隆</strong>在本次作业中对我的“身心摧残”已在上文阐述，接下来需要进一步深入理解深浅克隆的区别与实现，以防以后出现类似的问题。</p><p><strong>1.首先我们需要知道什么时候我们在进行克隆？</strong></p><ul><li>简而言之，如果此时我们在<strong>根据一个已有数据创建一个新数据</strong>的时候，我们便在进行克隆。<strong>意识到自己正在进行克隆十分重要</strong>，只有意识到了这一点才能进一步去思考深浅克隆的问题。</li></ul><p><strong>2.深浅克隆的区别是什么？</strong></p><ul><li>浅克隆不会克隆原对象中的引用类型，<strong>仅仅拷贝了引用类型的指向</strong>。深克隆则<strong>拷贝了所有</strong>。也就是说深克隆能够做到原对象和新对象之间完全没有影响。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/C83105F4641043D08AE35CE665499394?method=download&shareKey=82ec04ad13bd8b9b3650d744bf7675f9"></p><p><strong>3.我在深浅克隆中犯的错误</strong></p><ul><li>首先第一点，我没有意识到自己在进行克隆，之前并没有在代码中了解过克隆这个概念。</li><li>第二点，我在克隆操作中为了实现类中非基本数据类型的属性的克隆（在本次架构中是一个[Elements]数组），错误的使用了<code>addall</code>或<code>add</code>方法，这仅仅拷贝了引用类型的指向，并非深克隆。或从某种意义上讲，这都不是规范的克隆方法。</li></ul><p><strong>4.如何进行规范的克隆？</strong></p><ul><li>分享两篇博客资料，写的比较好，我在这里找到了答案。</li></ul><p>[<a href="https://blog.csdn.net/jeffleo/article/details/76737560">(40条消息) Java对象克隆——浅克隆和深克隆的区别_JeffCoding的博客-CSDN博客_浅克隆和深克隆的区别</a>]</p><p><a href="https://www.cnblogs.com/1314xf/p/10139971.html">java 深克隆（深拷贝）与浅克隆（拷贝）详解 - mindcarver - 博客园 (cnblogs.com)</a>(这一篇比较长，其实上一篇对于理解和实用来说就完全足够)</p><p>我来简单总结一下，java中<strong>已经为类准备了clone方法</strong>，我们不需要重复造轮子，要实现规范的<code>clone</code>，还需要以下两点：</p><ul><li><strong>实现Cloneable接口</strong>，只需在类的后面加<strong>implements Cloneable</strong>即可</li><li><strong>Override重写Clone方法</strong>，如何重写在上面两篇博文中都有很好的阐述。</li></ul><p>接下来，我认为重要的是理解为什么要重写<code>Clone</code>方法，对于只包含基本数据类型属性的类来说，<code>clone</code>方法完全够用，不需重写，<code>clone</code>后的新旧对象互不影响。重写<code>Clone</code>方法是为了应对类中<strong>包含了其他自定义的对象属性</strong>这种情况（比如在本次<code>HW2</code>作业中，我在<code>Sin</code>，<code>Cos</code>类中包含了<code>[Elements]</code>数组作为属性），这时<code>Clone</code>方法在拷贝这个属性时，拷贝的只是引用类型的指向，也就是我们所说的浅拷贝，后续再对这个属性进行操作时，便会在不经意间对新旧对象同时操作，这样的Bug很难查找出来，因此在设计时就要予以避免。</p><p>如何进行避免？方法也很简单，只需要在本类中修改重写的<code>Clone</code>方法，包含的其他自定义的对象里面也重写<code>Clone</code>方法，<strong>多个浅拷贝便可以实现深拷贝</strong>。引用第一篇博客中的例子如下（<code>Customer</code>类中包含顾客地址<code>Address</code>类），在两个类中均重写<code>Clone</code>方法，之后再调用<code>Clone</code>方法可以对<code>Customer</code>深克隆。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Address</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//Class Customer（Address是Customer的一个属性成员）</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Customer</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Customer</span> customer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Customer</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      customer<span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> customer<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总而言之，我认为对于java深浅拷贝的这样一种理解很准确：<strong>Java</strong>中定义的<strong>clone</strong>没有深浅之分，都是统一的调用<strong>Object</strong>的<strong>clone</strong>方法。为什么会有深克隆的概念？是<strong>由于我们在实现的过程中刻意的嵌套了<em>clone</em>方法的调用</strong>。也就是说<strong>深克隆就是在需要克隆的对象类型的类中全部实现克隆方法</strong>。</p><h4 id="5-2-去哪里找Bug"><a href="#5-2-去哪里找Bug" class="headerlink" title="5.2 去哪里找Bug"></a>5.2 去哪里找Bug</h4><p>这一点其实在理论课上有讲，我认为总结的是在太好了，这里再将其罗列一下。</p><ul><li>调用是否对返回值进行了接收和检查</li><li>类库及方法的使用是否符合要求</li><li><strong>容器访问的越界保护</strong>（课下自己测试过程中几次出现的数组越界问题）</li><li><strong>对象拷贝是否彻底</strong>（强测出现深浅克隆的Bug）</li><li>数值计算是否溢出</li><li>是否对循环体内对循环变量进行修改</li></ul><p>可以看到，我属于是精准踩雷有木有。所以在静态检查时，可以有意识的去思考以上检查要点，这能帮助我们更快更好的找到Bug，虽然不能覆盖所有Bug，但我觉得可以<strong>覆盖很大一部分</strong>非理解题意错误而导致的Bug。</p><h4 id="5-3-测试数据"><a href="#5-3-测试数据" class="headerlink" title="5.3 测试数据"></a>5.3 测试数据</h4><p>主要采用随机测试的方式，手动构造了一些我认为比较容易Error和Wrong Answer的边界数据，虽然也有一定的Hack量，但Hack成果并没有很显著，如果写个自动评测机可能会更好一点，周末开着自动评测机让其自动Hack，自己可以做其他的事情，<del>多是一件美事啊</del>。所以在这里我反思一下，下一次一定要写个自动评测机，下次一定。</p><h3 id="六-心得体会"><a href="#六-心得体会" class="headerlink" title="六. 心得体会"></a>六. 心得体会</h3><p>通过第一单元的作业，我有以下几点收获</p><ul><li>架构真的很重要，好的架构不仅正确度高，逻辑性强，在DeBug的时候很容易找到Bug的出处，有时候好的架构甚至会实现意想不到的功能，例如实现括号嵌套的支持等等。因此我们在开始动手之前，一定要多与同学进行交流，做好初步的设计工作，之后再逐步优化细节，进行实现。这样既可以减少之后重构的可能性，减少工作量，同时最终实现的效果正确性，准确性也会更好。</li><li>初步体会了面向对象与面向过程程序设计的不同，通过面向对象的程序设计，可以更好的实现代码维护与迭代更新，<strong>一次可能只需要修改某几个类就可以实现更多的需求</strong>，这一点是面向过程设计所做不到的。</li><li>最后一点肯定是更加熟悉了java中的各种语法以及容器的使用，从<code>HW1</code>的无从下手与茫然到慢慢熟练运用java中的常用类与常用功能，很像一个升级打怪的过程，在这个过程中我还是很满足的。第一单元的OO作业从心态和知识上都让我提升了很多，也收获了很多设计，编程经验，期待OO课程中之后的学习！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象第2单元作业总结</title>
      <link href="/2022/05/09/mian-xiang-dui-xiang-di-2-dan-yuan-zuo-ye-zong-jie/"/>
      <url>/2022/05/09/mian-xiang-dui-xiang-di-2-dan-yuan-zuo-ye-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是对第一次面向对象课程作业的总结，文章首先总结了本次作业我的总体架构思路，接着分析了三次作业中我的架构迭代历程，之后对于我的最终架构给出了代码度量分析，且分析了架构的优缺点。之后文章分析了在Hack过程中的收获，以及在本次作业设计，编写中我学到的东西，尤其是<strong>关于深浅克隆</strong>这一部分我分享了我认为比较好的一些资料，和我自己的理解，希望uu们不要跟我一样在这一知识点再犯错误。最后文章阐述了本次作业中我的心得体会。文章如有错误，谢谢指正！</p><hr><h3 id="一-总体架构思路"><a href="#一-总体架构思路" class="headerlink" title="一.总体架构思路"></a>一.总体架构思路</h3><p>在本次作业中，我们的最终需求是对一个表达式进行化简计算，并进行一些必要的合并与优化。然而要进行计算，首要任务是进行表达式的解析。总而言之，要完成解析和计算这两个需求，我设计了如下架构，我的架构简而言之是：递归向下解析，自底向上计算，输出前再进行合理优化。形象化的表示一下就是如下的流程图。</p><p><img src="https://note.youdao.com/yws/api/personal/file/57F941BFE671421C9AF4B1001A2B78E1?method=download&shareKey=c636f34fcf32c9ad8e157a213642308c"></p><p>在我的架构中，将表达式抽象为了<strong>四个层次</strong>，在作业指导书中，由于已经给出了表达式的形式化表示，我们可以很容易抽象出以下层次：</p><ul><li><p><code>Expr</code>：表达式层</p></li><li><p><code>Term</code>：<code>Expr</code>以<code>+-</code>的形式包含多个<code>Term</code>项层</p></li><li><p><code>Factor</code>：<code>Term</code>项以<code>*</code>形式包含多个<code>Factor</code>因子</p></li><li><p><code>Element</code>:上述三个层次均包含一个属性，其类型是一个<code>Element</code>数组，有了<code>Element</code>层，方便进行自底向上的运算。</p><ul><li><p>在第一次作业中 <code>Element = a*x**b</code></p></li><li><p>在第二、三次作业中 <code>Element = a*x*b*[sin][cos]</code>,其中<code>[sin][cos]</code>指<code>Sin、Cos</code>类的数组</p></li></ul></li></ul><p>有了以上这些层次，我们首先对输入进行递归向下解析，解析出表达式中包含哪些层次，经过自底向上的计算，可以得到每个层次的<code>[Elements]</code>数组，最终得到的<code>Expr</code>表达式的<code>[Elements]</code>数组便是我们得到的初步计算结果，经过合并同类项等优化便可以进行输出。</p><h3 id="二-迭代过程"><a href="#二-迭代过程" class="headerlink" title="二.迭代过程"></a>二.迭代过程</h3><p>在这一部分简要阐述了我的三次迭代心路历程，其中并没有放<code>UML</code>类图，因为三次作业我没有做大规模的重构，三次作业的<code>UML</code>类图重复相似部分较多，我将会在<strong>代码度量分析</strong>一节中分析<code>UML</code>类图，其中标明了每次作业的新增与修改部分。</p><h4 id="2-1第一次作业"><a href="#2-1第一次作业" class="headerlink" title="2.1第一次作业"></a>2.1第一次作业</h4><ul><li><strong>分析</strong></li></ul><p>在第一次作业中，首次上手<code>java</code>作业打了我一个措手不及，因为之前写的都是流程式的程序，开始时构思面向对象式的架构没有很好地思路，属于是一头雾水了，花了很多时间去理解题目并和同学交流，并且在助教给的训练项目中也得到了一些启发，最终构思了上述的程序架构。</p><ul><li><strong>解析方法上</strong>，在<code>HW1</code>中，由于因子层面只有常数因子，变量因子与表达式因子，总的来说类型较少，因此采用了<strong>正则表达式</strong>进行识别，识别流程示意图如下：</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/B8460413ACA241C7BC617C8C8BBF9BD0?method=download&shareKey=f982690aadfddbd60e53a6b8e044d3e6" alt="HW1"></p><ul><li><p><strong>计算方法上</strong>，在<code>HW1</code>中，涉及到<code>a*x**b</code>之间的乘法与加减法，只需系数与系数的计算，指数与指数的计算，不再赘述，但在这里我<strong>第一次遇到了深克隆和浅克隆的问题</strong>，这个问题在本次作业中多次困扰我，这一问题在之后的Bug部分详细阐述。</p></li><li><p><strong>优化方法上</strong>，由于最后的形式是许多<code>a*x**b</code>进行相加，优化方法上只涉及到合并同类项，之后输出时再进行简单的优化即可，例如指数为1不输出指数，变量因子系数为1不输出系数等。</p></li></ul><h4 id="2-2第二次作业"><a href="#2-2第二次作业" class="headerlink" title="2.2第二次作业"></a>2.2第二次作业</h4><ul><li><strong>分析</strong></li></ul><p>在本次作业中，新增了自变量函数，求和函数，三角函数三种因子,这要求我们对新增的这三种因子进行识别与计算。此外，由于在解析<code>f与sum</code>时需要进行自变量的替换，替换后可能出现表达式括号嵌套的形式，这要求架构中的解析过程要支持嵌套括号的形式，这是本次作业一个潜在的需求。</p><ul><li><strong>重构解析方法</strong>：在本次解析过程中，由于因子的形式多样，如果继续使用正则表达式进行识别，一来<strong>正则表达式很难准确构造</strong>，二来由于<strong>正则式的不准确所带来的潜在Bug</strong>也比较多。因此我对每个层次<strong>解析方法</strong><code>Parse</code>进行了重构，<strong>采用类似栈的方法，对括号层数进行解析，根据当前括号所处的层数和简单的字符判断</strong>，可以依此解析出<code>Term</code>，<code>Factor</code>等层次。这样写的好处是不需要绞尽脑汁构造正则表达式，正确性也容易验证，对于新增的几个因子<ul><li><code>sin，cos</code>，将括号内的内容当做<strong>常数或变量因子</strong>重新解析</li><li><code>f,sum</code>因子，进行字符串的替换，展开等处理后看做<strong>表达式</strong>重新解析</li></ul></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/7AF67256C2514CF19598F5D26B99EB90?method=download&shareKey=04f263d33be4bd685246b3268522028e" alt="HW2"></p><ul><li><p><strong>修改计算方法</strong>：</p><p>本次作业中的计算，不仅仅是<code>a*x**b</code>之间的乘法与加减法,此时<code>Element</code>是<code>a*x*b*[sin][cos]</code>，需要修改两处：</p><ul><li><code>[Elements]*[Elements]</code>,除了修改系数a，指数b，另需要将二者[sin][cos]数组合并，这里又涉及到了深拷贝与浅拷贝问题。然而<strong>梅开二度</strong>，我在这里又没有意识到犯了浅拷贝这个“错误”，虽然<code>HW2</code>中没有出现问题，但导致我在<code>HW3</code>优化二倍角时出现了错误，这里会在Bug部分详细阐述。</li><li><code>[Elements]+-[Elements]</code>，这里需要修改<code>equals</code>方法，合并同类项时考虑[sin][cos]数组是否一致。</li></ul></li><li><p><strong>新增优化方法</strong>：</p><ul><li>在解析过程中进行初步优化，对于<code>sin(0),cos(0),sin()**0,cos()**0</code>，<strong>在解析的过程中就将其解析为对应常数</strong>，进行初步优化。</li><li>三角函数计算的优化<ul><li>在<code>HW2</code>，因为时间关系，只增加了简单的<code>Acos(B)**2+Asin(B)**2=A</code>的合并，其中<code>A</code>是任意项，<code>B</code>是三角函数内的常数或变量因子。</li></ul></li></ul></li></ul><h4 id="2-3第三次作业"><a href="#2-3第三次作业" class="headerlink" title="2.3第三次作业"></a>2.3第三次作业</h4><ul><li><strong>分析</strong></li></ul><p>在本次作业中，新增了函数间的相互调用，三角函数内嵌套等新需求。关于函数之间的相互调用，在<code>HW2</code>中对于自定义函数的处理方法是，进行自变量的替换后直接看做表达式进行处理，因此<code>HW2</code>架构已经可以实现函数之间的互调用。在本次作业中主要实现了三角函数的内嵌套，相较于第二部分修改较少。</p><ul><li><strong>修改解析方法</strong>，  如上文所述，此次迭代，<strong>只需要修改三角函数内部嵌套部分的解析方式</strong>。显而易见，将括号内部的部分当做<code>Expr</code>表达式继续解析即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/B2F525E399E9490CB1FA8989B96B8A67?method=download&shareKey=6e17a41843a7f8ff4de21666f5b379e6"></p><ul><li><strong>计算方法</strong>：不需要修改。</li><li><strong>新增优化方法</strong><ul><li>二倍角公式，在<code>HW3</code>中实现了二倍角的简化，<code>2Asin(B)cos(B) = Asin(2B)</code>,<strong>遗憾的是这里将<code>HW2</code>中的Bug显现了出来</strong>，因为在优化时对B进行了系数的加倍，而在计算时采用的<strong>浅克隆方式</strong>，修改B导致了其他某些<code>sin</code>，<code>cos</code>内部的内容也随之修改。</li></ul></li></ul><h3 id="三-代码度量分析"><a href="#三-代码度量分析" class="headerlink" title="三.代码度量分析"></a>三.代码度量分析</h3><p>先放一下<code>HW3</code>最终的<code>UML</code>类图</p><p><img src="https://note.youdao.com/yws/api/personal/file/04BAF07845ED401195D6536C1582A325?method=download&shareKey=a2b0020feda0fa741dccb15900e18342"></p><ul><li><p>第二次作业修改了<code>Caculate</code>内的方法，新增<code>Sin,Cos</code>,自定义函数<code>Fun,Sum</code>类，修改了<code>Element</code>属性，其他<code>UML</code>部分与第一次作业基本相同。</p></li><li><p>第三次作业修改了<code>Sin,Cos</code>内部属性，同时更新了<code>Caculate</code>计算方法，其他<code>UML</code>类基本未做变动。</p></li><li><p>优缺点分析</p><ul><li>优点是进行了比较系统的抽象，不同层次代表了表达式中不同的组合，</li><li>缺点是首先<code>Sin，Cos</code>两个类基本相同，可以合并，在编写代码时我为了区分<code>Cos，Sin</code>，创建了两个类，但其实二者基本相同，完全可以合并为一个类，以减少复杂度。此外，代码之间内在的的关联度高，不容易达到“高内聚低耦合”的原则，程序的结构化程度不是很好。</li></ul></li></ul><p>之前我并未接触过代码度量的含义，了解之后学习到其一些指标含义如下：</p><ol><li><code>CogC</code>：认知复杂度，反应一个方法的可理解性，循环分支等结构越多，可理解性越差，数值越高。</li><li><code>ev(G)</code>:基本复杂度是用来衡量程序非结构化程度的。</li><li><code>Iv(G)</code>:模块设计复杂度是用来衡量模块判定结构，即模块和其他模块的调用关系,越高说明模块和其他模块之间的调用关系复杂，耦合程度越高.</li><li><code>v(G)</code>:是用来衡量一个模块判定结构的复杂程度，数量上表现为独立路径的条数,数值越高说明程序越难以维护</li></ol><p><strong>方法复杂度</strong></p><table><thead><tr><th>PreFun.printans(ArrayList)</th><th>48.0</th><th>3.0</th><th>16.0</th><th>17.0</th></tr></thead><tbody><tr><td>PreFun.mergecs2(ArrayList)</td><td>42.0</td><td>10.0</td><td>9.0</td><td>12.0</td></tr><tr><td>Factor.parse()</td><td>31.0</td><td>4.0</td><td>12.0</td><td>15.0</td></tr><tr><td>Element.matchcs(Element)</td><td>30.0</td><td>9.0</td><td>10.0</td><td>12.0</td></tr><tr><td>Element.Element(String)</td><td>28.0</td><td>1.0</td><td>15.0</td><td>18.0</td></tr><tr><td>Fun.parse()</td><td>26.0</td><td>3.0</td><td>10.0</td><td>11.0</td></tr><tr><td>PreFun.neg(ArrayList)</td><td>19.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Expr.parse()</td><td>12.0</td><td>1.0</td><td>8.0</td><td>9.0</td></tr><tr><td>Term.parse()</td><td>12.0</td><td>1.0</td><td>7.0</td><td>8.0</td></tr><tr><td>PreFun.addcos(StringBuilder, Element)</td><td>10.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>PreFun.addsin(StringBuilder, Element)</td><td>10.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>PreFun.issingle(ArrayList)</td><td>8.0</td><td>5.0</td><td>11.0</td><td>12.0</td></tr><tr><td>Cos.cossequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Element.elementsequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>PreFun.mergecs(ArrayList)</td><td>7.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Sin.sinsequal(ArrayList, ArrayList)</td><td>7.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr></tbody></table><p><strong>（由于方法较多，篇幅限制只列出了分析结果中数值较大，标红的部分数据。）</strong></p><p><strong>接下来进行代码度量结果的分析</strong>：</p><ul><li><p>从<strong>方法复杂度</strong>来看，可以看出其集中出现在<code>PreFun</code>内的优化函数上，原因是我在优化过程中采用的<code>for</code>与<code>if-else</code>较多，为优化性能对许多情况进行分别讨论，这导致了复杂度过高，这从某种程度上说明了我在优化部分容易出错的原因。</p></li><li><p>同时每个类内<code>Parse</code>方法，和<code>Element</code>方法的实现也比较复杂，这是因为<strong>耦合性过强</strong>，例如在我的架构中，他们都是为<strong>解析功能</strong>服务的函数，<code>Expr</code>的<code>parse</code>需要依赖<code>Term</code>中的<code>Parse</code>，而<code>Term</code>的<code>Parse</code>又需要依赖<code>Factor</code>的<code>Parse</code>，<strong>方法之间的依赖性很强</strong>，不容易达到“高内聚低耦合”的原则，程序的结构化程度不是很好。</p></li></ul><h3 id="四-Hack与被Hack"><a href="#四-Hack与被Hack" class="headerlink" title="四.Hack与被Hack"></a>四.Hack与被Hack</h3><h4 id="4-1-个人Bug发现与分析"><a href="#4-1-个人Bug发现与分析" class="headerlink" title="4.1 个人Bug发现与分析"></a>4.1 个人Bug发现与分析</h4><p>关于本次作业的Bug较多的集中在<strong>深克隆与浅克隆</strong>这个问题上，这可能与我的代码架构有关，在对<code>ArrayList</code>操作时使用了较多的<code>add</code>方法。</p><p>在一次作业中我首次遇到了深克隆与浅克隆的问题，但在课下时我已经发现了这个Bug并予以解决。但在第二次作业时，又再一次出现了深克隆浅克隆的问题，这个Bug原因是我在计算<code>[Elements]</code>数组时为了实现合并两数组的[sin][cos]，直接采用了<code>add</code>方法，因为第二次作业我并未对<code>Sin</code>,<code>Cos</code>内部进行操作，所以当时我认为直接采用<code>add</code>方法是正确的，简便的，因而这个Bug在第二次作业时并没有显现。</p><p>然而在第三次作业中，在优化部分我新增了<strong>二倍角优化方法</strong>，直接对<code>Sin</code>,<code>Cos</code>内部项的系数进行了操作，此时我忽略了之前采用<code>add</code>方法合并数组时采用了浅克隆而非深克隆，直接引发了第二次作业所埋下的隐患。<del>以后再也不瞎优化了(bushi</del>,所以有时候不优化，保证正确性可能会更好一点。不过言归正传，这个Bug十分隐蔽，我在课下并没有发现，导致一个强测点直接寄掉。</p><p>这个Bug出现的原因有二：</p><ul><li><p>一方面是因为对于深克隆浅克隆的理解还是不够深刻，在编写代码是没有意识到自己当前所写代码实际上是再进行克隆操作，也没有进一步思考这里的克隆是需要深克隆还是浅克隆，在第二次作业中我采用的浅克隆方式对于<code>HW2</code>的需求来说是<strong>“正确”</strong>的(因为恰巧第二次作业中<code>sin</code>，<code>cos</code>内部只有常数与自变量，不需要对其内部进行操作)，但其实是并<strong>不合理</strong>的，因为在架构中需要新构造一个项，进一步思考不难意识到我们需要的实际上是深克隆，关于深浅克隆的问题，为了加深我自己的理解，将在“我学到的”这一部分进行进一步阐述。</p></li><li><p>另一方面是因为在作业迭代的过程中，上一次作业的某些架构在本次作业中埋下了隐患。在进行作业的迭代时，编写完代码后我只检查了本次修改的，迭代的代码正确性，“理所当然的认为”之前的代码都通过了上一次强测，那肯定是正确的吧。但事实证明这样做法是错误的，我忽略了两次迭代之间的关联性，新增的需求可能会是上次架构中**”正确”但不合理<strong>的操作变为Bug。以后的作业中，应该</strong>有意识的去思考迭代过程中两次架构中有哪些可能产生Bug的关联之处，不能只着眼与本次作业的新增部分、修改部分，**以防止这种现象的发生。</p></li></ul><h4 id="4-2-互测他人Bug发现与分析"><a href="#4-2-互测他人Bug发现与分析" class="headerlink" title="4.2 互测他人Bug发现与分析"></a>4.2 互测他人Bug发现与分析</h4><p>本次互测发现了其他同学如下几个Bug</p><ul><li><code>-1+1</code>等简单的操作无法输出，这一Bug产生的原因是一些同学的架构进行迭代优化后，由于架构的不合理性，反而无法实现最基本的测试点，这也提醒了我们测试全面覆盖的重要性。</li><li><code>sum</code>上下界定义为了<code>int</code>，而非<code>BigInteger</code>，这一Bug产生的原因我认为可能是没有仔细阅读指导书，先入为主习惯性的将一些整数定义为了<code>int</code>，测试时</li><li><code>sum(i,下界,上界,i**2)</code>出现了问题，这一Bug产生的原因是进行字符串替换时没有加括号，这里的<code>i</code>是常数，只有替换时<strong>加括号</strong>才是正确的形式化表述。</li></ul><h3 id="五-我学到的"><a href="#五-我学到的" class="headerlink" title="五.我学到的"></a>五.我学到的</h3><h4 id="5-1-深克隆与浅克隆"><a href="#5-1-深克隆与浅克隆" class="headerlink" title="5.1 深克隆与浅克隆"></a>5.1 深克隆与浅克隆</h4><p><strong>深克隆与浅克隆</strong>在本次作业中对我的“身心摧残”已在上文阐述，接下来需要进一步深入理解深浅克隆的区别与实现，以防以后出现类似的问题。</p><p><strong>1.首先我们需要知道什么时候我们在进行克隆？</strong></p><ul><li>简而言之，如果此时我们在<strong>根据一个已有数据创建一个新数据</strong>的时候，我们便在进行克隆。<strong>意识到自己正在进行克隆十分重要</strong>，只有意识到了这一点才能进一步去思考深浅克隆的问题。</li></ul><p><strong>2.深浅克隆的区别是什么？</strong></p><ul><li>浅克隆不会克隆原对象中的引用类型，<strong>仅仅拷贝了引用类型的指向</strong>。深克隆则<strong>拷贝了所有</strong>。也就是说深克隆能够做到原对象和新对象之间完全没有影响。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/C83105F4641043D08AE35CE665499394?method=download&shareKey=82ec04ad13bd8b9b3650d744bf7675f9"></p><p><strong>3.我在深浅克隆中犯的错误</strong></p><ul><li>首先第一点，我没有意识到自己在进行克隆，之前并没有在代码中了解过克隆这个概念。</li><li>第二点，我在克隆操作中为了实现类中非基本数据类型的属性的克隆（在本次架构中是一个[Elements]数组），错误的使用了<code>addall</code>或<code>add</code>方法，这仅仅拷贝了引用类型的指向，并非深克隆。或从某种意义上讲，这都不是规范的克隆方法。</li></ul><p><strong>4.如何进行规范的克隆？</strong></p><ul><li>分享两篇博客资料，写的比较好，我在这里找到了答案。</li></ul><p>[<a href="https://blog.csdn.net/jeffleo/article/details/76737560">(40条消息) Java对象克隆——浅克隆和深克隆的区别_JeffCoding的博客-CSDN博客_浅克隆和深克隆的区别</a>]</p><p><a href="https://www.cnblogs.com/1314xf/p/10139971.html">java 深克隆（深拷贝）与浅克隆（拷贝）详解 - mindcarver - 博客园 (cnblogs.com)</a>(这一篇比较长，其实上一篇对于理解和实用来说就完全足够)</p><p>我来简单总结一下，java中<strong>已经为类准备了clone方法</strong>，我们不需要重复造轮子，要实现规范的<code>clone</code>，还需要以下两点：</p><ul><li><strong>实现Cloneable接口</strong>，只需在类的后面加<strong>implements Cloneable</strong>即可</li><li><strong>Override重写Clone方法</strong>，如何重写在上面两篇博文中都有很好的阐述。</li></ul><p>接下来，我认为重要的是理解为什么要重写<code>Clone</code>方法，对于只包含基本数据类型属性的类来说，<code>clone</code>方法完全够用，不需重写，<code>clone</code>后的新旧对象互不影响。重写<code>Clone</code>方法是为了应对类中<strong>包含了其他自定义的对象属性</strong>这种情况（比如在本次<code>HW2</code>作业中，我在<code>Sin</code>，<code>Cos</code>类中包含了<code>[Elements]</code>数组作为属性），这时<code>Clone</code>方法在拷贝这个属性时，拷贝的只是引用类型的指向，也就是我们所说的浅拷贝，后续再对这个属性进行操作时，便会在不经意间对新旧对象同时操作，这样的Bug很难查找出来，因此在设计时就要予以避免。</p><p>如何进行避免？方法也很简单，只需要在本类中修改重写的<code>Clone</code>方法，包含的其他自定义的对象里面也重写<code>Clone</code>方法，<strong>多个浅拷贝便可以实现深拷贝</strong>。引用第一篇博客中的例子如下（<code>Customer</code>类中包含顾客地址<code>Address</code>类），在两个类中均重写<code>Clone</code>方法，之后再调用<code>Clone</code>方法可以对<code>Customer</code>深克隆。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Address</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//Class Customer（Address是Customer的一个属性成员）</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Customer</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Customer</span> customer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Customer</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      customer<span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> customer<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总而言之，我认为对于java深浅拷贝的这样一种理解很准确：<strong>Java</strong>中定义的<strong>clone</strong>没有深浅之分，都是统一的调用<strong>Object</strong>的<strong>clone</strong>方法。为什么会有深克隆的概念？是<strong>由于我们在实现的过程中刻意的嵌套了<em>clone</em>方法的调用</strong>。也就是说<strong>深克隆就是在需要克隆的对象类型的类中全部实现克隆方法</strong>。</p><h4 id="5-2-去哪里找Bug"><a href="#5-2-去哪里找Bug" class="headerlink" title="5.2 去哪里找Bug"></a>5.2 去哪里找Bug</h4><p>这一点其实在理论课上有讲，我认为总结的是在太好了，这里再将其罗列一下。</p><ul><li>调用是否对返回值进行了接收和检查</li><li>类库及方法的使用是否符合要求</li><li><strong>容器访问的越界保护</strong>（课下自己测试过程中几次出现的数组越界问题）</li><li><strong>对象拷贝是否彻底</strong>（强测出现深浅克隆的Bug）</li><li>数值计算是否溢出</li><li>是否对循环体内对循环变量进行修改</li></ul><p>可以看到，我属于是精准踩雷有木有。所以在静态检查时，可以有意识的去思考以上检查要点，这能帮助我们更快更好的找到Bug，虽然不能覆盖所有Bug，但我觉得可以<strong>覆盖很大一部分</strong>非理解题意错误而导致的Bug。</p><h4 id="5-3-测试数据"><a href="#5-3-测试数据" class="headerlink" title="5.3 测试数据"></a>5.3 测试数据</h4><p>主要采用随机测试的方式，手动构造了一些我认为比较容易Error和Wrong Answer的边界数据，虽然也有一定的Hack量，但Hack成果并没有很显著，如果写个自动评测机可能会更好一点，周末开着自动评测机让其自动Hack，自己可以做其他的事情，<del>多是一件美事啊</del>。所以在这里我反思一下，下一次一定要写个自动评测机，下次一定。</p><h3 id="六-心得体会"><a href="#六-心得体会" class="headerlink" title="六. 心得体会"></a>六. 心得体会</h3><p>通过第一单元的作业，我有以下几点收获</p><ul><li>架构真的很重要，好的架构不仅正确度高，逻辑性强，在DeBug的时候很容易找到Bug的出处，有时候好的架构甚至会实现意想不到的功能，例如实现括号嵌套的支持等等。因此我们在开始动手之前，一定要多与同学进行交流，做好初步的设计工作，之后再逐步优化细节，进行实现。这样既可以减少之后重构的可能性，减少工作量，同时最终实现的效果正确性，准确性也会更好。</li><li>初步体会了面向对象与面向过程程序设计的不同，通过面向对象的程序设计，可以更好的实现代码维护与迭代更新，<strong>一次可能只需要修改某几个类就可以实现更多的需求</strong>，这一点是面向过程设计所做不到的。</li><li>最后一点肯定是更加熟悉了java中的各种语法以及容器的使用，从<code>HW1</code>的无从下手与茫然到慢慢熟练运用java中的常用类与常用功能，很像一个升级打怪的过程，在这个过程中我还是很满足的。第一单元的OO作业从心态和知识上都让我提升了很多，也收获了很多设计，编程经验，期待OO课程中之后的学习！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主存储器</title>
      <link href="/2022/05/09/zhu-cun-chu-qi/"/>
      <url>/2022/05/09/zhu-cun-chu-qi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟存储系统</title>
      <link href="/2022/05/09/xu-ni-cun-chu-xi-tong/"/>
      <url>/2022/05/09/xu-ni-cun-chu-xi-tong/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数字模块</title>
      <link href="/2022/05/09/shu-zi-mo-kuai/"/>
      <url>/2022/05/09/shu-zi-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="数字模块"><a href="#数字模块" class="headerlink" title="数字模块"></a>数字模块</h2><h3 id="半加器与全加器"><a href="#半加器与全加器" class="headerlink" title="半加器与全加器"></a>半加器与全加器</h3><ul><li>半加器没有考虑进位，相当于一个异或门</li><li>全加器：</li></ul><h5 id="行波进位加法器"><a href="#行波进位加法器" class="headerlink" title="行波进位加法器"></a>行波进位加法器</h5><p><img src="https://note.youdao.com/yws/api/personal/file/4A82FB8FBB614A8B9EC8E1EAFF53B8E0?method=download&shareKey=13816bb38172af4236b25ae359fcd1eb" alt="1"><br>串行进位，依此串联</p><h5 id="先行进位加法器"><a href="#先行进位加法器" class="headerlink" title="先行进位加法器"></a>先行进位加法器</h5><p><img src="https://note.youdao.com/yws/api/personal/file/FC56D45439FC45748E3F223823C14ED3?method=download&shareKey=43ec1bafebae5e3ba74256c05e5877e9" alt="2"><br>并行进位，提前计算进位，不必等待前一位输出进位后再计算</p><h5 id="前缀加法器"><a href="#前缀加法器" class="headerlink" title="前缀加法器"></a>前缀加法器</h5><p>参加《数字设计与计算机体系结构P149》，实际上应用了前缀的思想，需要的硬件数多，实现速度最快，为对数级。</p><hr><h3 id="减法器"><a href="#减法器" class="headerlink" title="减法器"></a>减法器</h3><p>将负数以补码的形式表示出来，输入到全加器中即可实现。</p><hr><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul><li>相等比较器，使用异或门检查每一位是否相等，最后使用与门作与</li><li>量值比较器，二者做减法，检查最高位01，判断是大于等于，还是小于</li></ul><hr><h3 id="ALU算术逻辑单元"><a href="#ALU算术逻辑单元" class="headerlink" title="ALU算术逻辑单元"></a>ALU算术逻辑单元</h3><ul><li>实现加，减法，量值比较，与运算，或运算，是大多数计算机的核心<br><img src="https://note.youdao.com/yws/api/personal/file/E6EC7EAAB72D45CFA794F2453FBAF259?method=download&shareKey=8628617def2fc94f51475d90ce4100f7" alt="3"></li></ul><h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p><img src="https://note.youdao.com/yws/api/personal/file/D2BA58A290C54D01B4D585E383C3B927?method=download&shareKey=f050174849962641682f0fd3b244de98" alt="4"></p><h3 id="编码器译码器略"><a href="#编码器译码器略" class="headerlink" title="编码器译码器略"></a>编码器译码器略</h3><h3 id="多位选择器"><a href="#多位选择器" class="headerlink" title="多位选择器"></a>多位选择器</h3><ul><li>多位选择器可以正常作为选择功能使用，也可以反着用，把输出作为选择端，输入作为数据端，就可以实现数据端的任意逻辑组合电路<br><img src="https://note.youdao.com/yws/api/personal/file/B84BFAB05D094F1DADF48EB0BF38757C?method=download&shareKey=743fe6bac84f18a902f0b7f1d13b135d" alt="5"></li></ul><hr><h3 id="数据寄存器与数据锁存器"><a href="#数据寄存器与数据锁存器" class="headerlink" title="数据寄存器与数据锁存器"></a>数据寄存器与数据锁存器</h3><p><strong>数据寄存器</strong><br><img src="https://note.youdao.com/yws/api/personal/file/A1631345396F4BFE9B3B82124745AB46?method=download&shareKey=90ad7333df6a28fabd31fffc4eada20c" alt="1"></p><ul><li>由边沿触发的触发器构成（D触发），脉冲敏感型 </li><li>适用于数据有效提前于控制信号</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span>posedge clk <span class="token keyword">or</span> posedge rst<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>数据锁存器</strong></p><ul><li>由电位触发器（D锁存器）组成，电平敏感</li><li>数据有效滞后于控制信号</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span>clk <span class="token keyword">or</span> rst<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><h4 id="四位右移寄存器"><a href="#四位右移寄存器" class="headerlink" title="四位右移寄存器"></a>四位右移寄存器</h4><p><img src="https://note.youdao.com/yws/api/personal/file/64638569CC7A4641BB504764B9680022?method=download&shareKey=efa473c569f7ace0f1019069bb1d818f" alt="44"></p><ul><li>由四个D触发组成，数据从左端输入，依此通过低位寄存器，高位触发器的输出送低位触发器的输入</li><li>有两种工作方式<ul><li>串入并出：N位移位寄存器经过N个CP后，最后一个输出恰好为第一个输入，此时从低位到高位的输出正好为完整的输入串，称为并行输出。</li><li>串入串出；每一个输出都会串行输出输入串，只不过后级触发器的输出比前一个触发器要晚一个周期，把处于串入串出的移位寄存器称为<strong>延迟线</strong>。</li></ul></li></ul><h4 id="双向移位寄存器"><a href="#双向移位寄存器" class="headerlink" title="双向移位寄存器"></a>双向移位寄存器</h4><p><strong>通过在触发器的输入端增加门电路来增加控制左右移的功能</strong><br><img src="https://note.youdao.com/yws/api/personal/file/2E83B9F516954A45A6D031A5A34BE929?method=download&shareKey=e7f7bfaec1a208e77a68d61bb6dc6371" alt="3"></p><ul><li>CT74194芯片：一共四个功能，通过S1，S0控制<br><img src="https://note.youdao.com/yws/api/personal/file/7B0E78D4E3C54B8983DDC51D0BB7103D?method=download&shareKey=2e134456bdfc0b4ead27941887df8a94" alt="4"></li></ul><hr><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><h4 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h4><ul><li>功能：计数计时，分频，产生节拍脉冲和序列脉冲</li><li>分类<ul><li>时钟方式：同步计数器，异步计数器</li><li>计数方式：M进制计数器</li><li>状态分类：加法，减法，加&#x2F;减法</li></ul></li><li>同步二进制计数器也称为分频器，实际上CP进行了2，4，8，16分频</li></ul><h4 id="异步计数器"><a href="#异步计数器" class="headerlink" title="异步计数器"></a>异步计数器</h4><ul><li>高位触发器的时钟信号由低位触发器的输出提供，高位触发器的翻转等待低一位的触发器反转后才能进行。</li><li>触发器不同步，出现尖锋脉冲<br><img src="https://note.youdao.com/yws/api/personal/file/DBD3D2E6B38249489973D9D75E1ABD7C?method=download&shareKey=99397cfe426733cb3aa59d593eb75f79" alt="11"></li></ul><hr><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>分类：</p><ul><li>按介质：半导体，磁介质，光盘</li><li>按访问方式：随机访问（RAM），顺序访问，直接访问，只读存储器（ROM）</li><li>按功能：<ul><li>高速缓冲存储器（Cache）是介于中央处理器和主存储器之间的高速小容量存储器</li><li>主存储器，一般由半导体存储器</li><li>控制存储器</li><li>辅助存储器，磁存储器，不易失性<br>性能指标：</li></ul></li><li>访问时间<ul><li>对于随机访问存储器，指给定地址到存储器完成读或写操作所需的时间</li><li>其他类型：定位到目标位置的时间</li></ul></li><li>存储周期：两次访问存储单元间的最小时间</li><li>带宽计算<ul><li>随机访问存储器：<code>1/周期</code></li><li>其他类型：<br><img src="https://note.youdao.com/yws/api/personal/file/B0FE9B454B1C477285250D522E9D58D5?method=download&shareKey=20db72df25cbfbf51432cc4b684850e7" alt="1"><br><strong>以下是计算机内部存储系统</strong><br><img src="https://note.youdao.com/yws/api/personal/file/A81342C375A44578988ACAA6DBDB22A7?method=download&shareKey=c18f292d6c0f8f409c4550badd68274f" alt="2"><br>二级存储系统由Cache和主存储器构成</li></ul></li></ul><h4 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h4><ul><li>随机访问存储器RAM<ul><li>静态随机访问存储器SRAM，集成度低，不必刷新，用作Cache，快</li><li>动态随机访问存储器DRAM，需要刷新，集成度高，用作主存，慢</li></ul></li><li>只读存储器ROM<ul><li>不可在线改写内容</li><li>块擦除存储器Flash ROM</li></ul></li></ul><h5 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h5><p><img src="https://note.youdao.com/yws/api/personal/file/A97EABB052554835B7305D54C3215354?method=download&shareKey=02c0561714ff07048fbc84ccb174542f" alt="3"></p><ul><li>字选线决定是否对当前存储单元进行操作</li><li>以A点的电平状态代表0，1</li><li>左右两侧为数据读写线</li></ul><h5 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h5><p><img src="https://note.youdao.com/yws/api/personal/file/393230E675D648EBA69E65A96813744F?method=download&shareKey=d55fdbc773da5aa54902e50fa585db80" alt="4"></p><ul><li>采用电容充放电原理</li><li>读出时，将D线充电2.5V，字选线选中，若内部为3.5V高电平，电流从内往外，若内部低电平0V，电流从外往内。（但读出时会对原有状态造成破坏，读出完毕后内部电路变为2.5V的一个中间态，所以需要）</li><li>写入时，将D线置高或低电平，字选线选中，对内部电容进行充放电</li></ul><h5 id="存储芯片内部结构"><a href="#存储芯片内部结构" class="headerlink" title="存储芯片内部结构"></a>存储芯片内部结构</h5><p>存储芯片容量&#x3D;字单元数*每个字单元的位数<br><strong>多个存储位元（存储单元）构成一个字单元，多个字单元构成一个存储芯片，任一时刻可以（也只能）访问1024个独立字单元中的任意一个，每次读写的数据位数是一个字单元的容量（2位）</strong><br>地址线：由字单元的个数决定<br>数据线：因为每次只能读写一个字单元，所以字单元里有几个存储位元，就需要几根数据线<br><img src="https://note.youdao.com/yws/api/personal/file/80CF6339D32143E7A80A4DF8122F4C08?method=download&shareKey=628e6043b1a6ebbad955d94efb92f96b" alt="6"><br>如图，每一个小方块是一个存储位元，我们把行选和列选的管教弄成相同的，这样可以在芯片中重复利用管脚。搭配使用译码器，mos管就可以实现定位到每一个<strong>字单元</strong>进行操作。<br><img src="https://note.youdao.com/yws/api/personal/file/2A9D8D3DA7A141C7B3B7130B23972BB4?method=download&shareKey=c3dc38b55c49e803d56823a07d6ca743" alt="7"><br>如上图，封装时将行选和列选的管教公用，通过控制端选择行选还是列选。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首挂P4的珍贵记录</title>
      <link href="/2022/05/09/shou-gua-p4-de-zhen-gui-ji-lu/"/>
      <url>/2022/05/09/shou-gua-p4-de-zhen-gui-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>下次考试的时候需注意：</p><ol><li><strong>先把所有的模块都生成在一个prj文件里，这样考试开始时可以快速的将各个mips文件复制进去</strong></li><li>做完第一步后，将文件夹复制3次，分别用来解决三个测试，防止写代码的过程中改来改去</li><li><strong>先写一个先写一个MARS，生成txt文件，把wcg文件设置出来方便debug，应该包括：</strong></li><li>修改的过程中先改数据通路，再改控制通路</li></ol><h3 id="Problem1"><a href="#Problem1" class="headerlink" title="Problem1"></a>Problem1</h3><h4 id="构造指令"><a href="#构造指令" class="headerlink" title="构造指令"></a>构造指令</h4><p>格式：<code>rlb rt rs imm</code></p><ul><li>解释：将GPR(rs)低imm位全部取反，输出到GPR(rt)内</li><li>思路：在CU里面加上rlb判断信号，我们在ALU中输入GPR(rs)和imm来实现取反计算，然后输出到rt内部，改变的控制信号主要是：ALUControl,ALUsrc选取imm输入,GRF的A3端要选择rt作为输入端,RegWrite信号也要加一个</li><li>问题主要出在<strong>位选信号时不能使用变量在括号</strong>里，并且我写了一个for循环，但<strong>for循环的终止条件判断也必须是一个常数</strong>，所以也不可行，最终导致了TLE的发生，<strong>其实位选信号有特殊的写法可以使其包含变量</strong>，但是我在课下看到了这个语法，但没有特别注意也没有掌握，emo了。。。。。第一个题直接放弃了。</li></ul><h3 id="Problem2"><a href="#Problem2" class="headerlink" title="Problem2"></a>Problem2</h3><h4 id="bnezalc"><a href="#bnezalc" class="headerlink" title="bnezalc"></a>bnezalc</h4><p><code>bnezalc rs offset</code></p><pre class="line-numbers language-none"><code class="language-none">if GRF(rs)!&#x3D;0    PC &lt; PC+4+signextend(offset||00)    GRF(31) &lt; PC+4else     PC &lt; PC+4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>问题这里涉及到寄存器的写信号，跟P3一样，我一开始有没有注意到如果rs &#x3D; 0，不能让RegWrite信号为1，我直接把RegWrite信号里面加了bnezalc，这样会导致错误</li><li>终终终于发现bug了！！！！和我课下写的BLEZ发生了冲突（由于代码不规范导致的）</li></ul><pre class="line-numbers language-none"><code class="language-none">原代码：assign Blez &#x3D; (RD1 &lt;&#x3D; 32&#39;d0); assign Bnezalc &#x3D; RD1!&#x3D;0;assign Blez_MUX &#x3D; (Blez|Bnezalc)?Pcplusimm:PCplus4;&#x2F;&#x2F;我一看，这里bnezalc的NPC不是和Blez一样吗，太好了，可以合并啊！其实是错的。。。。。。。这里 Blez_MUX会永远为Pcplusimm，因为RD1&#x3D;0的时候，Blez为1，emo了。。。。always @( *) begin    case(Branch)    3&#39;d0:NPC &#x3D; PCplus4;    3&#39;d1:NPC &#x3D; ALUzero_MUX;    3&#39;d2:NPC &#x3D; NPC_j;    3&#39;d3:NPC &#x3D; Ra;    3&#39;d4:NPC &#x3D; Blez_MUX；3&#39;d5:NPC &#x3D; Blez_MUX；        default NPC&#x3D;32&#39;d0;    endcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里我们不应该对判断信号贸然的进行合并，例如这些blez，bne，beq等等等因为一个信号判断为真，必然会对其他判断信号产生影响，虽然他们的NPC都是一样的，以后写代码的时候应该注意</strong></p><pre class="line-numbers language-none"><code class="language-none">更改后代码：assign Blez &#x3D; (RD1 &lt;&#x3D; 32&#39;d0); assign Bnezalc &#x3D; RD1!&#x3D;0;    always @( *) begin    case(Branch)    3&#39;d0:NPC &#x3D; PCplus4;    3&#39;d1:NPC &#x3D; ALUzero_MUX;    3&#39;d2:NPC &#x3D; NPC_j;    3&#39;d3:NPC &#x3D; Ra;    3&#39;d4:NPC &#x3D; (Blez)?Pcplusimm:PCplus4;3&#39;d5:NPC &#x3D; (Bnezalc)?Pcplusimm:PCplus4;    default NPC&#x3D;32&#39;d0;    endcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Problem3"><a href="#Problem3" class="headerlink" title="Problem3"></a>Problem3</h3><h4 id="lwrr"><a href="#lwrr" class="headerlink" title="lwrr"></a>lwrr</h4><ul><li>格式 <code>lwrr rt ,offset(base)</code></li><li>含义</li></ul><pre class="line-numbers language-none"><code class="language-none">addr&#x3D;GRF(base)+offset从DM[addr]取出值WD（这里跟lw指令一模一样）将WD循环右移存入rt！！！（注意这里的循环右移是按照8byte为一个单位右移的）byte &lt; addr[1:0]WD应该经8byte循环右移为&#123;WD[8*byte-1:0],WD[31:8*byte]&#125;（注意这里是伪代码，位选信号不能为非常量，具体实现可以用右移操作实现，或者是直接把所有情况（4种）列出来用MUX输出即可，）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现过程：在DM里加入控制信号，如果此时的指令为lwrr，直接在DM中就把进行循环位移处理，然后再进行输出<br><strong>考完才发现理解错题意了，整个一个大无语，我还以为是按1byte为单位循环右移，离谱，不好好看题的结果</strong><br>##补充</li><li>循环右移 b位 a &#x3D; (a &gt;&gt; b)|(a&lt;&lt; (32’d32-b));循环左移一样</li><li>算数右移b   a &#x3D; $signed($signed(a) &gt;&gt;&gt; b);注意要套两个$signed</li></ul><h4 id="这两天的P4之前过的都很顺利，还以为计组也不是很难吗。结果该来的还是来了，还是代码写的太少，bug写的太少，做计组要笑！！！！！fighting！！下一关流水线。"><a href="#这两天的P4之前过的都很顺利，还以为计组也不是很难吗。结果该来的还是来了，还是代码写的太少，bug写的太少，做计组要笑！！！！！fighting！！下一关流水线。" class="headerlink" title="这两天的P4之前过的都很顺利，还以为计组也不是很难吗。结果该来的还是来了，还是代码写的太少，bug写的太少，做计组要笑！！！！！fighting！！下一关流水线。"></a>这两天的P4之前过的都很顺利，还以为计组也不是很难吗。结果该来的还是来了，还是代码写的太少，bug写的太少，做计组要笑！！！！！fighting！！下一关流水线。</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序逻辑</title>
      <link href="/2022/05/09/shi-xu-luo-ji/"/>
      <url>/2022/05/09/shi-xu-luo-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h3><hr><h4 id="RS锁存器"><a href="#RS锁存器" class="headerlink" title="RS锁存器"></a>RS锁存器</h4><h5 id="基本的RS锁存器"><a href="#基本的RS锁存器" class="headerlink" title="基本的RS锁存器"></a>基本的RS锁存器</h5><p>如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/4D339BFD974249A9824B4471781068ED?method=download&shareKey=d00240532aa059cb1e338f2e9688fc0a" alt="a"><br>运用了<strong>双稳态电路</strong>实现了如下功能(低电平有效类型)：</p><table><thead><tr><th align="center">~RD</th><th align="center">~SD</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">触发器保持原状态不变(Q不变)</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">置0（Q&#x3D;0）</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">置1（Q&#x3D;1）</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">不确定状态（由于门延迟而产生了竞争）</td></tr></tbody></table><h5 id="钟控RS锁存器"><a href="#钟控RS锁存器" class="headerlink" title="钟控RS锁存器"></a>钟控RS锁存器</h5><p>加入了时钟信号：<br><img src="https://note.youdao.com/yws/api/personal/file/7CC3B7215DA04563A8638B68EA554E81?method=download&shareKey=78c7a705c7448374089969b6d66619ca" alt="2"><br><img src="https://note.youdao.com/yws/api/personal/file/2E2F7E20214F409DAC16C59E4F6B0D9C?method=download&shareKey=1ebac36d709e326a66c93c541dba16f6" alt="3"><br>当CP&#x3D;0时，RS锁存器输入均为1，保持原状态。<br>CP&#x3D;1时，RS锁存器正常工作。</p><h5 id="钟控D锁存器-钟控RS-反相器"><a href="#钟控D锁存器-钟控RS-反相器" class="headerlink" title="钟控D锁存器(钟控RS+反相器)"></a>钟控D锁存器(钟控RS+反相器)</h5><p>钟控D所存通过加入反向器，保证两个输入不同，避免了出现类似RS锁存器的不确定状态。<br><img src="https://note.youdao.com/yws/api/personal/file/74136CBC854A4D30BB88816D52A4F819?method=download&shareKey=cc83478c2dff963b57f6ebba3f3cf9b8" alt="d"></p><table><thead><tr><th align="center">CP</th><th align="center">D</th><th align="center">function</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">x</td><td align="center">保持原态</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">置1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">置0</td></tr></tbody></table><hr><h5 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h5><p>两个反相的D锁存器构成，持股发起的抓捕富态变化只在时钟的有效沿发生变化（上升沿或下降沿），D锁存器电平敏感，D触发器边沿触发。寄存器便是由多个共享CLK信号的D触发器构成<br><img src="https://note.youdao.com/yws/api/personal/file/D3C16E3318464D0882D76A4F1E72314D?method=download&shareKey=7d5dd1e3b92ece4687d9ab296c05e86b" alt="3"></p><h5 id="带使能端的D触发和带重置功能的D触发"><a href="#带使能端的D触发和带重置功能的D触发" class="headerlink" title="带使能端的D触发和带重置功能的D触发"></a>带使能端的D触发和带重置功能的D触发</h5><p>只需将使能端与在时钟端，或将重置端与在信号输入端。</p><p><img src="https://note.youdao.com/yws/api/personal/file/9891E081BB994864808F7909BD3E9830?method=download&shareKey=50112449e9e78249f481ebd4efbfd543" alt="4"><br><img src="https://note.youdao.com/yws/api/personal/file/E0866D7136F049CB94990EA16AA56F15?method=download&shareKey=4e26c0515fab8d20742a1a43b3823ae3" alt="5"></p><hr><h5 id="JK触发器"><a href="#JK触发器" class="headerlink" title="JK触发器"></a>JK触发器</h5><p>将RS&#x3D;11的无序状态转化为了翻转功能:<br><img src="https://note.youdao.com/yws/api/personal/file/F58CCBA967DF40BE9BADE2A15BA2FA59?method=download&shareKey=9613ef863baff5dd7abc5cf126c12164" alt="6"></p><table><thead><tr><th align="center">J</th><th align="center">K</th><th align="center">function</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">保持</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">置0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">置1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">翻转（取反）</td></tr></tbody></table><hr><h3 id="一个Mealy的例子"><a href="#一个Mealy的例子" class="headerlink" title="一个Mealy的例子"></a>一个Mealy的例子</h3><p><img src="https://note.youdao.com/yws/api/personal/file/422D1DB9DB4140BA9E6B5453FE2B9CDB?method=download&shareKey=104cea3899abde8b675917b753690132" alt="9"></p><p>题目中只要求不重复检测，在这里为了练习我们分两种情况讨论(<strong>有限状态机的难点在于画出状态转换图，其他剩下的便是工作量的问题</strong>)</p><hr><p><strong>不重复检测情况</strong>：1101101只算一个1101<br>状态转换图：<br><img src="https://note.youdao.com/yws/api/personal/file/27325F789C93419CA235E475959277AB?method=download&shareKey=3bc8913c778f1cbab26230ede242f4c3" alt="rr"><br>之后为每个状态编码，画出状态转换表，将电路分成两个子电路（状态转换与状态输出，最后加一个寄存器）很容易便可以画出Logisim电路，不做叙述，这里附一个verilog程序，在这个HDL程序内我们利用了<code>Always@(*)</code>搭建组合逻辑，可以学习一下：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">code_checker</span><span class="token punctuation">(</span>    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>    <span class="token keyword">input</span> data<span class="token punctuation">,</span>    <span class="token keyword">input</span> clr<span class="token punctuation">,</span>    <span class="token keyword">output</span> <span class="token keyword">reg</span> out    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> S0<span class="token operator">=</span><span class="token number">3'b000</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> S1<span class="token operator">=</span><span class="token number">3'b001</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> S2<span class="token operator">=</span><span class="token number">3'b010</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> S3<span class="token operator">=</span><span class="token number">3'b011</span><span class="token punctuation">;</span><span class="token keyword">parameter</span> S4<span class="token operator">=</span><span class="token number">3'b100</span><span class="token punctuation">;</span><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> status<span class="token punctuation">;</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> clr<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token comment">//注意这里不仅有时钟上升沿，还有reset信号上升沿</span>    <span class="token function">if</span><span class="token punctuation">(</span>clr<span class="token punctuation">)</span><span class="token keyword">begin</span>        status <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span><span class="token comment">//reset</span>    <span class="token keyword">end</span>    <span class="token keyword">else</span> <span class="token keyword">begin</span>        <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>            S0<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>status <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span><span class="token keyword">else</span> status<span class="token operator">&lt;=</span> S1<span class="token punctuation">;</span>            S1<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span>status <span class="token operator">&lt;=</span> S2<span class="token punctuation">;</span><span class="token keyword">else</span> status <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span>            S2<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>status <span class="token operator">&lt;=</span> S3<span class="token punctuation">;</span><span class="token keyword">else</span> status <span class="token operator">&lt;=</span> S2<span class="token punctuation">;</span>            S3<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>status <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span><span class="token keyword">else</span> status <span class="token operator">&lt;=</span> S4<span class="token punctuation">;</span>            S4<span class="token punctuation">:</span> <span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span>status <span class="token operator">&lt;=</span> S1<span class="token punctuation">;</span><span class="token keyword">else</span> status <span class="token operator">&lt;=</span> S0<span class="token punctuation">;</span>            <span class="token keyword">default</span> <span class="token punctuation">:</span>status <span class="token operator">&lt;=</span>S0<span class="token punctuation">;</span>        <span class="token keyword">endcase</span>   <span class="token comment">//case 语法可以不用加begin，end</span>    <span class="token keyword">end</span>    <span class="token keyword">end</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">begin</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>        S0<span class="token punctuation">:</span>out <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        S1<span class="token punctuation">:</span>out <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        S2<span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        S3<span class="token punctuation">:</span><span class="token function">if</span><span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span>out <span class="token operator">=</span><span class="token number">1'b1</span><span class="token punctuation">;</span><span class="token keyword">else</span> out <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span><span class="token comment">//易错</span>        S4<span class="token punctuation">:</span> out <span class="token operator">=</span> <span class="token number">1'b0</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> out <span class="token operator">=</span><span class="token number">1'b0</span><span class="token punctuation">;</span>    <span class="token keyword">endcase</span><span class="token keyword">end</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mealy编写注意事项：</p><ul><li>有reset信号需要在always@（posedge clk or <strong>posedge clr</strong>）写明。</li><li>mealy状态机的状态输出与输入有关，可以用always建立组合逻辑，建立组合逻辑时建议使用阻塞赋值&#x3D;。</li><li>case语句中一定要写明<code>default</code>状态.</li><li>mealy的组合逻辑与moore不同，不能仅凭当前状态判断输出。</li><li>状态机的case语句判定的一般都是status的变化</li></ul><p><strong>若重复检测</strong>：1101101算两个1101，只要改变一下状态转换图即可<br><img src="https://note.youdao.com/yws/api/personal/file/8ABFDCE30063401D88C8AED395C91FDD?method=download&shareKey=0e8447da9530ba8c28f2f3067e3a7ab3" alt="eee"></p><h3 id="重点–时序电路的时序"><a href="#重点–时序电路的时序" class="headerlink" title="重点–时序电路的时序"></a>重点–时序电路的时序</h3><p><img src="https://note.youdao.com/yws/api/personal/file/4F8B5CAD1D8F41CAA189098BFAED8402?method=download&shareKey=1d46cf3b452e103d2e629dd08fc986f8" alt="a"><br><img src="https://note.youdao.com/yws/api/personal/file/FBC27D856B88469B9396C81F81FC9157?method=download&shareKey=1e97febfd3d6d2a6d33bacf1f6a9d4a6" alt="b"></p><ul><li><strong>同步时序电路的时钟周期与组合逻辑最长路径有关</strong></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/78584CBDA4564167AB6F78B5A0BBCDBD?method=download&shareKey=844c503bb7c2076ed26635bcc7c09c9d" alt="C"></p><ul><li><strong>保持时间约束与组合逻辑最短路径有关</strong></li></ul><hr><h3 id="数据寄存器与数据锁存器"><a href="#数据寄存器与数据锁存器" class="headerlink" title="数据寄存器与数据锁存器"></a>数据寄存器与数据锁存器</h3><p><strong>数据寄存器</strong><br><img src="https://note.youdao.com/yws/api/personal/file/A1631345396F4BFE9B3B82124745AB46?method=download&shareKey=90ad7333df6a28fabd31fffc4eada20c" alt="1"></p><ul><li>由边沿触发的触发器构成（D触发），脉冲敏感型 </li><li>适用于数据有效提前于控制信号</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span>posedge clk <span class="token keyword">or</span> posedge rst<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>数据锁存器</strong></p><ul><li>由电位触发器（D锁存器）组成，电平敏感</li><li>数据有效滞后于控制信号</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span>clk <span class="token keyword">or</span> rst<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><h4 id="四位右移寄存器"><a href="#四位右移寄存器" class="headerlink" title="四位右移寄存器"></a>四位右移寄存器</h4><p><img src="/"></p><ul><li>由四个D触发组成，数据从左端输入，依此通过低位寄存器，高位触发器的输出送低位触发器的输入</li><li>有两种工作方式<ul><li>串入并出：N位移位寄存器经过N个CP后，最后一个输出恰好为第一个输入，此时从低位到高位的输出正好为完整的输入串，称为并行输出。</li><li>串入串出；每一个输出都会串行输出输入串，只不过后级触发器的输出比前一个触发器要晚一个周期，把处于串入串出的移位寄存器称为<strong>延迟线</strong>。</li></ul></li></ul><h4 id="双向移位寄存器"><a href="#双向移位寄存器" class="headerlink" title="双向移位寄存器"></a>双向移位寄存器</h4><p><strong>通过在触发器的输入端增加门电路来增加控制左右移的功能</strong><br><img src="https://note.youdao.com/yws/api/personal/file/2E83B9F516954A45A6D031A5A34BE929?method=download&shareKey=e7f7bfaec1a208e77a68d61bb6dc6371" alt="3"></p><ul><li>CT74194芯片：一共四个功能，通过S1，S0控制<br><img src="https://note.youdao.com/yws/api/personal/file/7B0E78D4E3C54B8983DDC51D0BB7103D?method=download&shareKey=2e134456bdfc0b4ead27941887df8a94" alt="4"></li></ul><hr><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><h4 id="同步计数器"><a href="#同步计数器" class="headerlink" title="同步计数器"></a>同步计数器</h4><ul><li>功能：计数计时，分频，产生节拍脉冲和序列脉冲</li><li>分类<ul><li>时钟方式：同步计数器，异步计数器</li><li>计数方式：M进制计数器</li><li>状态分类：加法，减法，加&#x2F;减法</li></ul></li><li>同步二进制计数器也称为分频器，实际上CP进行了2，4，8，16分频</li></ul><h4 id="异步计数器"><a href="#异步计数器" class="headerlink" title="异步计数器"></a>异步计数器</h4><ul><li>高位触发器的时钟信号由低位触发器的输出提供，高位触发器的翻转等待低一位的触发器反转后才能进行。</li><li>触发器不同步，出现尖锋脉冲<br><img src="https://note.youdao.com/yws/api/personal/file/DBD3D2E6B38249489973D9D75E1ABD7C?method=download&shareKey=99397cfe426733cb3aa59d593eb75f79" alt="11"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog学习</title>
      <link href="/2022/05/09/verilog-xue-xi/"/>
      <url>/2022/05/09/verilog-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HDL语言（Verilog）学习要点-预习"><a href="#HDL语言（Verilog）学习要点-预习" class="headerlink" title="HDL语言（Verilog）学习要点(预习)"></a>HDL语言（Verilog）学习要点(预习)</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Z与x"><a href="#Z与x" class="headerlink" title="Z与x"></a>Z与x</h3><p>HDL用<strong>Z</strong>表示浮空值，代表高阻状态，即与电路断开，用<strong>x</strong>代表无效的逻辑电平（<em>未知状态或冲突状态</em>）。</p><ul><li>例如在初始化时，状态节点会被初始化为<strong>x</strong>，代表未知状态。</li><li>例如一条总线被两个使能的三态缓冲器驱动为不同的值，则也输出<strong>x</strong>，代表冲突状态。</li><li>接收浮空输入，无效输入，未初始化的输入都会输出<strong>x</strong>。</li></ul><hr><h3 id="case，if语句"><a href="#case，if语句" class="headerlink" title="case，if语句"></a>case，if语句</h3><p><strong>case</strong>语句一般都要写上default，且这两种语法都必须出现在<strong>always</strong>语句块中。</p><hr><h3 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h3><ul><li><p><strong>&#x3D;</strong> 为阻塞赋值，与编程语言一样，需要按顺序执行,组合逻辑一般使用阻塞赋值，可以使用多个assign，也可以使用always语句块。例如如下实现全加器，两种方法均可 <strong>(都是用了阻塞赋值)</strong> ：</p></li><li><p>&lt;&#x3D;为非阻塞赋值，当信号发生变化时并行执行，但一般不用于组合逻辑中，使用非阻塞赋值可以得到正确的结果但会执行多次always中的语句，使仿真速度变慢，参考 <em>《数字设计与计算机体系结构 P126》</em> 。</p></li></ul><hr><h3 id="定义状态机时-typedef-enum的使用-不过这个好像只能systemVerilog-使用，我们使用的verilog没有这个语法，后来在发现。。。。。。。"><a href="#定义状态机时-typedef-enum的使用-不过这个好像只能systemVerilog-使用，我们使用的verilog没有这个语法，后来在发现。。。。。。。" class="headerlink" title="定义状态机时 typedef enum的使用 (不过这个好像只能systemVerilog 使用，我们使用的verilog没有这个语法，后来在发现。。。。。。。)"></a>定义状态机时 <code>typedef enum</code>的使用 (不过这个好像只能systemVerilog 使用，我们使用的verilog没有这个语法，后来在发现。。。。。。。)</h3><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">typedef enum reg [1:0] &#123;S0,S1,S2&#125; statustype;statustype [1:0] status;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上代码自动赋值S0,S1,S2,相当于</p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">parameter S0&#x3D;0;parameter S1&#x3D;1;parameter S2&#x3D;2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>当状态机的状态非常多时</strong>，可以不用一个个定义独热码，非常实用。</p><h3 id="模块实例化"><a href="#模块实例化" class="headerlink" title="模块实例化"></a>模块实例化</h3><p><img src="https://note.youdao.com/yws/api/personal/file/8391DC0390C7419EAC9C74CEE124CAED?method=download&shareKey=c5c78d09f579cb1e34b1c20331b53c4f" alt="pic"><br>且模块实例化可以改变引用模块中参数的位宽</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">Decode</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>F<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">parameter</span> Width <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>polarity<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">endmodule</span> <span class="token keyword">module</span> Top<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A4<span class="token punctuation">;</span>    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> B16<span class="token punctuation">;</span>    Decode #<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">D1</span><span class="token punctuation">(</span>A4<span class="token punctuation">,</span>B16<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将Decode中的两个parameter的值更改为4，1</span><span class="token keyword">end</span> <span class="token keyword">module</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h5 id="wire型"><a href="#wire型" class="headerlink" title="wire型"></a>wire型</h5><ul><li>输出信号自动默认为wire类型</li><li>不能存储值，必须受到驱动器的驱动（assign，赋值语句）</li></ul><h5 id="reg类型"><a href="#reg类型" class="headerlink" title="reg类型"></a>reg类型</h5><ul><li>寄存器</li><li>默认初始值x，需要初始化</li></ul><h5 id="memory类型"><a href="#memory类型" class="headerlink" title="memory类型"></a>memory类型</h5><ul><li>通过定义寄存器数组实现</li><li>与C语言中数组的使用方法类似</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> mem<span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义256个8位存储器，地址0~255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>位运算符 &amp; ，|，<del>，^(异或)，</del>^（异或非）</li><li>逻辑运算符 &amp;&amp;，||，！</li><li>移位运算符 &lt;&lt;,&gt;&gt;（0填补）</li><li>位拼接运算符 { }</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token punctuation">&#123;</span>b<span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span>b<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>b<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">&#125;</span><span class="token comment">//注意重复法使用时需要再套一个括号</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>等式运算符 &#x3D;&#x3D;，！&#x3D;，！&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;<ul><li>&#x3D;&#x3D;&#x3D;是全等，每一位都要相等，包括x，z</li><li>&#x3D;&#x3D;是值相等，当有不定值时不能判断相等</li></ul></li></ul><h3 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h3><ul><li>顺序块</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">begin end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>并行块<ul><li>进入并行块后块内语句同时执行</li><li>每条语句延迟时间相对于程序进入块内的仿真时间</li><li></li></ul></li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">fork<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>块名<span class="token comment">//块内声明语句</span>    语句<span class="token number">1</span>；    语句<span class="token number">2</span>；    <span class="token comment">//...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul><li>语法与C语言中类似</li><li>if语句块若没有写明else，则会生成额外的寄存器，因此写if语句最好写完整。</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>begin     <span class="token keyword">if</span><span class="token punctuation">(</span>al<span class="token punctuation">)</span> q<span class="token operator">=</span>d<span class="token punctuation">;</span>    <span class="token comment">//没有写else，当al=0时变量q没有新的赋值，变量将保持原值，也就是综合后生成一个关于q的锁存器，这个锁存器不是我们原先想要的</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><pre class="line-numbers language-v" data-language="v"><code class="language-v">case <span class="token punctuation">(</span>expression<span class="token punctuation">)</span>    s1<span class="token punctuation">:</span>    s2<span class="token punctuation">:</span>    <span class="token comment">//...</span>    default<span class="token punctuation">:</span>endcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>case 不写明default会生成不必要的锁存器</li></ul><h4 id="循环-forever"><a href="#循环-forever" class="headerlink" title="循环 forever"></a>循环 forever</h4><pre class="line-numbers language-v" data-language="v"><code class="language-v">forever begin<span class="token comment">//多条语句</span>end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>用于产生周期性的波形</li><li>不能像always一样写在程序中，而要写在initial中</li></ul><h4 id="循环-repeat"><a href="#循环-repeat" class="headerlink" title="循环 repeat"></a>循环 repeat</h4><pre class="line-numbers language-v" data-language="v"><code class="language-v">parameter size<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span>reg <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>opa<span class="token punctuation">,</span>opb<span class="token punctuation">;</span>reg <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>result<span class="token punctuation">;</span>begin<span class="token punctuation">:</span>mult    reg <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>shift_opa<span class="token punctuation">,</span>shift_opb<span class="token punctuation">;</span>    shift_opa<span class="token operator">=</span>opa<span class="token punctuation">;</span>    shift_opb<span class="token operator">=</span>opb<span class="token punctuation">;</span>    result <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    repeat <span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token comment">//重复8次</span>    begin        <span class="token keyword">if</span><span class="token punctuation">(</span>shift_opb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            result <span class="token operator">=</span> result<span class="token operator">+</span>shift_opa<span class="token punctuation">;</span>        shift_opa <span class="token operator">=</span>shift_opa <span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>        shift_opb <span class="token operator">=</span> shift_opb <span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环for与while"><a href="#循环for与while" class="headerlink" title="循环for与while"></a>循环for与while</h3><ul><li><strong>特别提一下for中一般用integer i做循环变量</strong></li></ul><hr><h3 id="结构说明语句"><a href="#结构说明语句" class="headerlink" title="结构说明语句"></a>结构说明语句</h3><h4 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h4><ul><li>只执行一次</li></ul><h4 id="always"><a href="#always" class="headerlink" title="always"></a>always</h4><ul><li>不断执行直到仿真过程结束</li><li>常与时序控制语句相结合</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always #period clk<span class="token operator">=</span><span class="token operator">~</span>clk<span class="token punctuation">;</span>always@<span class="token punctuation">(</span>posedge clk<span class="token punctuation">)</span>begin<span class="token comment">//...</span>endalways@<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>begin<span class="token comment">//...</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>电平敏感时序控制</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">always     <span class="token function">wait</span><span class="token punctuation">(</span>count_enable<span class="token punctuation">)</span>  #<span class="token number">20</span> count<span class="token operator">=</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>程序将持续监视count_enable,当其值为1时，执行后面的语句。</p><hr><h3 id="task及function说明语句"><a href="#task及function说明语句" class="headerlink" title="task及function说明语句"></a>task及function说明语句</h3><ul><li>函数与主模块使用一个仿真时间单位，任务可以定义自己的时间单位</li><li>函数不能启动任务，任务可以启动其他任务及函数</li><li>函数至少有一个输入变量，任务可以没有</li><li>函数返回一个值，任务不返回值（但任务有输出值）<br><strong>函数的目的是通过返回一个值响应输入信号的值，而任务可以支持多种目的，可以计算多个结果的值，这些结果枝只能通过task的任务输出或总线端口输出</strong><br><strong>可以这么理解，任务是一个小的module，可以有多种用途</strong></li></ul><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><pre class="line-numbers language-v" data-language="v"><code class="language-v">task my_task<span class="token punctuation">;</span>    input a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    output c<span class="token punctuation">,</span>e<span class="token punctuation">;</span>    <span class="token comment">//.....</span>    c<span class="token operator">=</span><span class="token comment">//...</span>    e<span class="token operator">=</span><span class="token comment">//...</span>endtask<span class="token function">my_task</span><span class="token punctuation">(</span>a0<span class="token punctuation">,</span>b0<span class="token punctuation">,</span>c0<span class="token punctuation">,</span>d0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//任务调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任务可以启动其他的任务，可以启动的任务数无限制，也可以启动其他的函数。<br>一个例子(只是一个行为模块，不可综合)：</p><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token keyword">module</span> <span class="token function">light</span><span class="token punctuation">(</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>reg clock<span class="token punctuation">,</span>red<span class="token punctuation">,</span>amber<span class="token punctuation">,</span>green<span class="token punctuation">;</span>parameter on<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>off<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>red_tics<span class="token operator">=</span><span class="token number">350</span><span class="token punctuation">,</span>amber_tics<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span>green_tics<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">;</span>initial beginred<span class="token operator">=</span>off<span class="token punctuation">;</span>amber<span class="token operator">=</span>off<span class="token punctuation">;</span>green<span class="token operator">=</span>off<span class="token punctuation">;</span>endalways beginred<span class="token operator">=</span>on<span class="token punctuation">;</span><span class="token function">light</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span>red_tics<span class="token punctuation">)</span><span class="token punctuation">;</span>green<span class="token operator">=</span>on<span class="token punctuation">;</span><span class="token function">light</span><span class="token punctuation">(</span>green<span class="token punctuation">,</span>green_tics<span class="token punctuation">)</span><span class="token punctuation">;</span>amber<span class="token operator">=</span>on<span class="token punctuation">;</span><span class="token function">light</span><span class="token punctuation">(</span>amber<span class="token punctuation">,</span>amber_tics<span class="token punctuation">)</span><span class="token punctuation">;</span>endtask light<span class="token punctuation">;</span><span class="token comment">//等待一定时间将该信号灯关掉</span>output color<span class="token punctuation">;</span>input <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> tics<span class="token punctuation">;</span>begin<span class="token function">repeat</span><span class="token punctuation">(</span>tics<span class="token punctuation">)</span>@<span class="token punctuation">(</span>posedge clock<span class="token punctuation">)</span><span class="token punctuation">;</span>color<span class="token operator">=</span>off<span class="token punctuation">;</span>endendtaskalways begin#<span class="token number">100</span> clock<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>#<span class="token number">100</span> clock<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Function（函数）"><a href="#Function（函数）" class="headerlink" title="Function（函数）"></a>Function（函数）</h4><ul><li>返回的是一个寄存器的值</li><li>没有return语句，最后函数运行完后返回寄存器的值是啥返回值就是啥</li><li>返回值自动定义为与函数名同名的寄存器</li><li>函数不能启动任务</li><li>函数不能包含任何时间控制语句（#，@，wait）</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">function <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>getbyte<span class="token punctuation">;</span><span class="token comment">//函数名为getbyte，返回寄存器也是getbyte，且为8位，如果不定义位宽自动默认为1位宽</span>intput <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>address<span class="token punctuation">;</span>begin    <span class="token comment">//....</span>    getbyte<span class="token operator">=</span><span class="token comment">//....</span>endendfunction<span class="token comment">//调用</span>word<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token function">getbyte</span><span class="token punctuation">(</span>msbyte<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getbyte</span><span class="token punctuation">(</span>lsbyte<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个例子关于阶乘：</p><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token keyword">module</span> tryfact<span class="token punctuation">;</span>    function<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>factorial<span class="token punctuation">;</span>        input<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>operand<span class="token punctuation">;</span>        reg <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>index<span class="token punctuation">;</span>        begin            factorial<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>index<span class="token operator">&lt;=</span>operand<span class="token punctuation">;</span>index<span class="token operator">=</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                factorial<span class="token operator">=</span>index<span class="token operator">*</span>factorial<span class="token punctuation">;</span>        end    endfunctionreg<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>result<span class="token punctuation">;</span>reg<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>n<span class="token punctuation">;</span>initial begin    result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>n<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">;</span>n<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>begin        $<span class="token function">display</span><span class="token punctuation">(</span><span class="token string quoted-string">"n=%d,result=%d"</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token operator">=</span>n<span class="token operator">*</span><span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    end    $<span class="token function">display</span><span class="token punctuation">(</span><span class="token string quoted-string">"finalresult=%d"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://note.youdao.com/yws/api/personal/file/66D3CCBB4BA7482D871D1BD37FEECF68?method=download&shareKey=6afbe6ea018f26f97b34af03d18077af" alt="A"></p><h4 id="自动递归函数"><a href="#自动递归函数" class="headerlink" title="自动递归函数"></a>自动递归函数</h4><ul><li>verilog中函数不能进行递归调用，因为没有栈，递归时将对同一区域进行操作，计算结果不确定。</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">function automatic integer factorial<span class="token punctuation">;</span>input <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>oper<span class="token punctuation">;</span>integer i<span class="token punctuation">;</span>begin    <span class="token keyword">if</span><span class="token punctuation">(</span>oper<span class="token operator">>=</span><span class="token number">2</span><span class="token punctuation">)</span>        factorial<span class="token operator">=</span><span class="token function">factorial</span><span class="token punctuation">(</span>oper<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>oper<span class="token punctuation">;</span><span class="token comment">//调用函数</span>    <span class="token keyword">else</span>        factorial <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>endendfuction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="常用系统任务"><a href="#常用系统任务" class="headerlink" title="常用系统任务"></a>常用系统任务</h3><h4 id="display-and-write"><a href="#display-and-write" class="headerlink" title="$display and $write"></a>$display and $write</h4><ul><li>都是输出信息，display自动换行，write不自动换行</li><li>%c，以ascll输出</li><li>%t，输出时间</li><li>%%，输出%号</li></ul><h4 id="readmemb-and-readmemh"><a href="#readmemb-and-readmemh" class="headerlink" title="$readmemb and $readmemh"></a>$readmemb and $readmemh</h4><p>参见语言模板 FILE I&#x2F;O说明。</p><hr><h3 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h3><ul><li>&#96;define</li><li>&#96;include</li><li>条件编译命令</li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v">`ifdef 宏名程序段<span class="token number">1</span>；`<span class="token keyword">else</span>程序段<span class="token number">2</span>；`endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>宏名若已定义，则编译程序段1，否则编译程序段2。</strong></p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><em><strong>三态缓冲器</strong></em></p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module tristate (    input [3:0]a,    input en,    output tri [3:0] y &#x2F;&#x2F;使用tri类型而不是trireg类型    );    assign y &#x3D; en? a : 4&#39;bz endmodule <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>4：1选择器（结构化建模）</strong></em></p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">module mux4 (    input [3:0]d0,d1,d2,d3,    input [1:0]s,    output [3:0] y );    wire [3:0] low,high;    &#x2F;&#x2F;使用了之前编写好的2：1复用器    mux2 lowmux(d0,d1,s[0],low);    mux2 highmux(d2,d3,s[0],high);    mux2 finalmux(low,high,s[1],y);endmodule <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>Cpu_checker</strong></em><br><img src="https://img-blog.csdnimg.cn/20210218115513426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plcmVteVpoYW8xOTk4,size_16,color_FFFFFF,t_70#pic_center" alt="有限状态机图"></p><pre class="line-numbers language-Verilog" data-language="Verilog"><code class="language-Verilog">&#96;timescale 1ns &#x2F; 1psmodule cpu_checker(    input clk,    input reset,    input [7:0] char,    input [15:0] freq,    output  [1:0] format_type,    output  [3:0] error_code    );&#x2F;&#x2F;额外寄存器变量需要3个parameter  S0&#x3D;4&#39;d0;parameter  S1&#x3D;4&#39;d1;parameter  Dextop&#x3D;3&#39;d4; parameter Hextop&#x3D;4&#39;d8;parameter YES&#x3D;1&#39;b1;parameter NO&#x3D;1&#39;b0;parameter initial_reg&#x3D;64&#39;b0000_0000;reg timewrong&#x3D;1&#39;b0;reg pcwrong&#x3D;1&#39;b0;reg addrwrong&#x3D;1&#39;b0;reg grfwrong&#x3D;1&#39;b0;reg [2:0] dexchecker;reg [3:0] hexchecker;reg [3:0] status;reg typereg;reg [63:0]Time&#x3D;64&#39;b0000_0000;reg [63:0]PC&#x3D;64&#39;b0000_0000;reg [63:0]GRF&#x3D;64&#39;b0000_0000;reg [63:0]ADDR&#x3D;64&#39;b0000_0000;assign  error_code &#x3D; &#123;grfwrong,addrwrong,pcwrong,timewrong&#125; ;initial begin    status &lt;&#x3D; S0;    dexchecker &lt;&#x3D; 3&#39;d0;    hexchecker &lt;&#x3D; 4&#39;d0;    typereg &lt;&#x3D; 1&#39;b0;endwire digitchar &#x3D; (char &gt;&#x3D; &quot;0&quot;&amp;&amp;char &lt;&#x3D;&quot;9&quot;)? YES : NO;wire hexchar &#x3D; (digitchar &#x3D;&#x3D; YES)? YES :(char &gt;&#x3D; &quot;a&quot;&amp;&amp;char &lt;&#x3D; &quot;f&quot;)? YES:NO;assign  format_type&#x3D; (status !&#x3D; 4&#39;d13)? 2&#39;b00:                    (typereg &#x3D;&#x3D; 1&#39;b0)? 2&#39;b01:2&#39;b10;always @(posedge clk) begin    if(reset &#x3D;&#x3D; 1&#39;b1)begin        status &lt;&#x3D; S0;        dexchecker &lt;&#x3D; 3&#39;d0;        hexchecker &lt;&#x3D; 4&#39;d0;        typereg &lt;&#x3D; 1&#39;b0;        Time &lt;&#x3D; initial_reg;        PC &lt;&#x3D; initial_reg;        GRF &lt;&#x3D; initial_reg;        ADDR &lt;&#x3D; initial_reg;        timewrong &lt;&#x3D; 1&#39;b0;        pcwrong &lt;&#x3D; 1&#39;b0;        grfwrong &lt;&#x3D; 1&#39;b0;        addrwrong &lt;&#x3D; 1&#39;b0;    end    case (status)        4&#39;d0:begin            Time &lt;&#x3D; initial_reg;            PC &lt;&#x3D; initial_reg;            GRF &lt;&#x3D; initial_reg;            ADDR &lt;&#x3D; initial_reg;            timewrong &lt;&#x3D; 1&#39;b0;            pcwrong &lt;&#x3D; 1&#39;b0;            grfwrong &lt;&#x3D; 1&#39;b0;            addrwrong &lt;&#x3D; 1&#39;b0;            if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d1:begin            Time &lt;&#x3D; initial_reg;            PC &lt;&#x3D; initial_reg;            GRF &lt;&#x3D; initial_reg;            ADDR &lt;&#x3D; initial_reg;            timewrong &lt;&#x3D; 1&#39;b0;            pcwrong &lt;&#x3D; 1&#39;b0;            grfwrong &lt;&#x3D; 1&#39;b0;            addrwrong &lt;&#x3D; 1&#39;b0;            if(digitchar &#x3D;&#x3D; YES)begin                status &lt;&#x3D; 4&#39;d2;                dexchecker &lt;&#x3D; 3&#39;d1;                Time &lt;&#x3D; char - &quot;0&quot;;            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D;S1;            else status &lt;&#x3D; S0;        end        4&#39;d2:begin            if(digitchar &#x3D;&#x3D; YES)begin                dexchecker &lt;&#x3D; dexchecker +3&#39;d1;                if(dexchecker +3&#39;b1&lt;&#x3D; Dextop)begin                    Time &lt;&#x3D; (Time &lt;&lt; 3)+(Time &lt;&lt; 1) + (char -&quot;0&quot;);                    status &lt;&#x3D; 4&#39;d2;                end                else status &lt;&#x3D; 4&#39;d0;            end            else if(char &#x3D;&#x3D; &quot;@&quot;)status &lt;&#x3D; 4&#39;d3;            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d3:begin            if(hexchar &#x3D;&#x3D; YES)            begin                status &lt;&#x3D; 4&#39;d4;                  hexchecker &lt;&#x3D; 4&#39;d1;                  PC &lt;&#x3D; (char-&quot;0&quot;);            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d4:begin            if(hexchar &#x3D;&#x3D; YES)begin                hexchecker &lt;&#x3D; hexchecker + 4&#39;d1;                if(hexchecker + 4&#39;b1&lt;&#x3D; Hextop)begin                    PC &lt;&#x3D; (PC &lt;&lt; 4)+((char &lt;&#x3D; &quot;9&quot;) ? (char - &quot;0&quot;) : (char - &quot;a&quot; + 64&#39;d10));                    status &lt;&#x3D; 4&#39;d4;                end                else status &lt;&#x3D; S0;            end            else if(char &#x3D;&#x3D; &quot;:&quot;)begin                if(hexchecker &#x3D;&#x3D; 4&#39;d8)status &lt;&#x3D; 4&#39;d5;                else status &lt;&#x3D; S0;            end            else if(char &#x3D;&#x3D; &quot;^&quot;) status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d5:begin            if(char &#x3D;&#x3D; &quot; &quot;)status &lt;&#x3D; 4&#39;d5;            else if(char &#x3D;&#x3D;&quot;^&quot;)status &lt;&#x3D; S1;            else if( char &#x3D;&#x3D; &quot;$&quot;)status &lt;&#x3D; 4&#39;d6;            else if(char &#x3D;&#x3D; 8&#39;d42)status &lt;&#x3D;4&#39;d7;            else status &lt;&#x3D; S0;        end        4&#39;d6:begin            typereg &lt;&#x3D; 1&#39;b0;            if(digitchar &#x3D;&#x3D; YES)begin                dexchecker &lt;&#x3D; 3&#39;d1;                GRF &lt;&#x3D; char-&quot;0&quot;;                status &lt;&#x3D; 4&#39;d8;            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D;S0;        end        4&#39;d8:begin            if(digitchar &#x3D;&#x3D;YES)begin                dexchecker &lt;&#x3D; dexchecker + 3&#39;d1;                if(dexchecker +3&#39;b1&lt;&#x3D; Dextop)begin                    GRF &lt;&#x3D; (GRF &lt;&lt; 3)+(GRF &lt;&lt; 1)+(char -&quot;0&quot;);                    status &lt;&#x3D; 4&#39;d8;                end                else status &lt;&#x3D; S0;            end            else if(char &#x3D;&#x3D; &quot; &quot;)status &lt;&#x3D; 4&#39;d9;            else if(char &#x3D;&#x3D; &quot;&lt;&quot;)status &lt;&#x3D;4&#39;d10;            else if(char &#x3D;&#x3D;&quot;^&quot;)status &lt;&#x3D;S1;            else status &lt;&#x3D;S0;        end        4&#39;d9:begin            if(char &#x3D;&#x3D;&quot; &quot;)status &lt;&#x3D; 4&#39;d9;            else if( char &#x3D;&#x3D; &quot;&lt;&quot;)status &lt;&#x3D; 4&#39;d10;            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d10:begin            if(char &#x3D;&#x3D; &quot;&#x3D;&quot;)status &lt;&#x3D; 4&#39;d11;            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;        end        4&#39;d11:begin            if( char &#x3D;&#x3D; &quot; &quot;)status &lt;&#x3D; 4&#39;d11;            else if(hexchar &#x3D;&#x3D; YES)            begin                hexchecker&lt;&#x3D; 4&#39;d1;                status &lt;&#x3D; 4&#39;d12;             end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D; S0;         end        4&#39;d12:begin            if(hexchar &#x3D;&#x3D; YES)begin                hexchecker &lt;&#x3D; hexchecker+4&#39;d1;                if(hexchecker +4&#39;b1&lt;&#x3D;Hextop)status &lt;&#x3D;4&#39;d12;                else status &lt;&#x3D; S0;            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D;S1;            else if( char &#x3D;&#x3D;&quot;#&quot;)begin                if(hexchecker &#x3D;&#x3D; 4&#39;d8)begin                    status &lt;&#x3D;4&#39;d13;                    &#x2F;&#x2F;time wrong?                    if((Time &amp; (-Time))&gt;&#x3D;(freq &gt;&gt;1)||Time &#x3D;&#x3D; initial_reg)timewrong &lt;&#x3D; 1&#39;b0;                    else timewrong &lt;&#x3D; 1&#39;b1;                    &#x2F;&#x2F;Pcwrong?                    if(PC &gt;&#x3D; 64&#39;h0000_3000 &amp;&amp; PC &lt;&#x3D; 64&#39;h0000_4fff)begin                        if((PC &amp; (-PC) )&gt;&#x3D; 64&#39;d4|| PC &#x3D;&#x3D; initial_reg)pcwrong &lt;&#x3D; 1&#39;b0;                        else pcwrong &lt;&#x3D; 1&#39;b1;                     end                    else pcwrong &lt;&#x3D; 1&#39;b1;                    &#x2F;&#x2F;grfwrong?                    if (typereg&#x3D;&#x3D;1&#39;b0)begin                        if(GRF &gt;&#x3D; 64&#39;d0&amp;&amp;GRF &lt;&#x3D; 64&#39;d31)grfwrong &lt;&#x3D; 1&#39;b0;                        else grfwrong &lt;&#x3D; 1&#39;b1;                    end                    &#x2F;&#x2F;addrwrong?                    else if(typereg &#x3D;&#x3D; 1&#39;b1)begin                        if(ADDR &gt;&#x3D; 64&#39;h0000_0000 &amp;&amp; ADDR &lt;&#x3D; 64&#39;h0000_2fff)begin                            if((ADDR &amp; (-ADDR)) &gt;&#x3D;64&#39;d4||ADDR &#x3D;&#x3D; initial_reg)addrwrong &lt;&#x3D; 1&#39;b0;                            else addrwrong &lt;&#x3D; 1&#39;b1;                        end                        else addrwrong &lt;&#x3D; 1&#39;b1;                    end                end                else status &lt;&#x3D;S0;            end            else status &lt;&#x3D;S0;        end        4&#39;d13:begin            timewrong &lt;&#x3D; 1&#39;b0;            pcwrong &lt;&#x3D; 1&#39;b0;            grfwrong &lt;&#x3D; 1&#39;b0;            addrwrong &lt;&#x3D; 1&#39;b0;            if(char  &#x3D;&#x3D;&quot;^&quot;)status  &lt;&#x3D;S1;            else status &lt;&#x3D;S0;        end        4&#39;d7:begin            typereg &lt;&#x3D; 1&#39;b1;            if(hexchar &#x3D;&#x3D; YES)begin                hexchecker &lt;&#x3D;4&#39;d1;                ADDR &lt;&#x3D; char-&quot;0&quot;;                status &lt;&#x3D;4&#39;d14;            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D;S1;            else status &lt;&#x3D;S0;        end        4&#39;d14:begin            if(hexchar &#x3D;&#x3D; YES)begin                hexchecker &lt;&#x3D; hexchecker+4&#39;d1;                if(hexchecker +4&#39;b1&lt;&#x3D;Hextop)begin                    ADDR &#x3D; (ADDR &lt;&lt; 4)+((char &lt;&#x3D; &quot;9&quot;) ? (char - &quot;0&quot;) : (char - &quot;a&quot; + 32&#39;d10));                    status &lt;&#x3D;4&#39;d14;                end                else status &lt;&#x3D; S0;            end            else if(char &#x3D;&#x3D; &quot; &quot;)begin                if(hexchecker &#x3D;&#x3D; 4&#39;d8)status &lt;&#x3D;4&#39;d9;                else status &lt;&#x3D;S0;            end            else if(char &#x3D;&#x3D; &quot;&lt;&quot;)begin                if(hexchecker &#x3D;&#x3D; 4&#39;d8)status &lt;&#x3D;4&#39;d10;                else status &lt;&#x3D;S0;            end            else if(char &#x3D;&#x3D; &quot;^&quot;)status &lt;&#x3D; S1;            else status &lt;&#x3D;S0;        end        default:status &lt;&#x3D; S0;                endcaseendendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编写该程序时，由于对非阻塞赋值不了解，犯了如下<font color=red>错误</font><br><img src="https://note.youdao.com/yws/api/personal/file/0D55C111835844B697593EECEDB414C6?method=download&shareKey=ecab4c2038bce57928a125e985a8ad4f" alt="错误示例"></p><p><em>上图易因为对非阻塞赋值的不理解而导致错误，非阻塞复制是在<strong>本语句块结束之后</strong>寄存器的值才发生改变，因此在进行大小判断时，<strong>必须加上4’b1代表理论上的寄存器取值</strong>，实际上寄存器的值还停留在上一周期。我写的时候就没有加4’b1,导致可以多读一位hexchecker。</em></p><h2 id="文末附一个ISE常用简便操作的网址"><a href="#文末附一个ISE常用简便操作的网址" class="headerlink" title="文末附一个ISE常用简便操作的网址"></a><strong>文末附一个ISE常用简便操作的网址</strong></h2><p><a href="https://www.cnblogs.com/ninghechuan/p/6214706.html">ISE使用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA_UNIX作业</title>
      <link href="/2022/05/09/buaa-unix-zuo-ye/"/>
      <url>/2022/05/09/buaa-unix-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h2 id="UNIX课程作业报告"><a href="#UNIX课程作业报告" class="headerlink" title="UNIX课程作业报告"></a>UNIX课程作业报告</h2><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>本次作业是一个简易shell，它由C语言编写，是一个为用户提供Linux操作系统的命令行式操作界面。本次作业实现的shell具有以下建议功能。</p><ul><li>可以运行不带参数的命令，带参数（额外实现）的外部命令</li><li>只能模拟实现简单的两个内部命令即<code>history</code>和<code>cd</code>指令</li><li>支持<code>I/O</code>重定向</li><li>支持管道，可以通过管道连接多个命令</li><li>退出时输入<code>exit</code>即可退出</li></ul><p>下面将由顶向下，从顶层架构到实现细节，逐步阐述本次大作业的实现思路。</p><h3 id="2-1-实现架构"><a href="#2-1-实现架构" class="headerlink" title="2.1 实现架构"></a>2.1 实现架构</h3><p>实现架构以流程图的方式给出：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220508224659405.png"></p><p>首先程序开始后进行INIT初始化操作，在本次作业中为了区分cd指令，history指令，管道指令，重定向指令定义了四个全局变量作为四个标记，标记当前读入的指令是哪一种类型的指令。INIT初始化操作便是将这四个标记初始化。</p><p>接着我们便可以开始fgets读入指令，对读入的指令进行解析，解析的功能是将四个标记置位。解析完毕后便可以执行excute函数执行指令。执行完后会再次循环上述过程，如果中途读入了exit指令便会退出程序。</p><h3 id="2-2-具体细节"><a href="#2-2-具体细节" class="headerlink" title="2.2 具体细节"></a>2.2 具体细节</h3><h4 id="2-2-1-cmd结构体："><a href="#2-2-1-cmd结构体：" class="headerlink" title="2.2.1 cmd结构体："></a>2.2.1 <code>cmd</code>结构体：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct cmd&#123;char *argv[10];int in_redir_fd;int out_redir_fd;&#125; command;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>agrv</code>是一个数组指针，其中保存着每个命令的参数，<code>in_redir_fd,out_redir_fd</code>是文件描述符，分别表示该指令的标准输入，标准输出，用于实现管道和重定向。</p><h4 id="2-2-2-cd-命令实现"><a href="#2-2-2-cd-命令实现" class="headerlink" title="2.2.2 cd 命令实现"></a>2.2.2 cd 命令实现</h4><p>cd命令实现较为简单，首先在parse解析时，如果解析到该指令为cd指令，则将pwdflag置1，进入excute函数执行指令后，调用字符串分割函数strtok（）得到cd 后面的path参数，接着直接调用chdir改变进程当前工作目录即可。</p><h4 id="2-2-3-history命令实现"><a href="#2-2-3-history命令实现" class="headerlink" title="2.2.3 history命令实现"></a>2.2.3 history命令实现</h4><p>本次作业实现的history命令可以实现的操作是<code>history n</code>显示最近的n条指令。具体的实现方法是通过一个数组记录最近输入的指令，如果检测到当前读入指令为history则会将该数组内的指令全部输出。</p><h4 id="2-2-4-管道pipe命令"><a href="#2-2-4-管道pipe命令" class="headerlink" title="2.2.4 管道pipe命令"></a>2.2.4 管道pipe命令</h4><p><strong>流程图：</strong></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220508224854832.png"></p><p><strong>用到的函数：</strong></p><table><thead><tr><th>用到的函数</th><th>作用</th></tr></thead><tbody><tr><td>pipe（）</td><td>实现管道</td></tr><tr><td>fork（）</td><td>创建子进程完成管道符号之前的指令</td></tr><tr><td>dup2（）</td><td>实现管道所需要的输出输出重定向</td></tr><tr><td>execvp（）</td><td>执行指令</td></tr><tr><td>strtok（）</td><td>分割字符串，识别命令，识别文件名</td></tr></tbody></table><p><strong>流程与步骤：</strong></p><ul><li><strong>pipe()管道函数的介绍</strong></li></ul><p>int pipe(int fd[2])，该函数创建的管道的两端处于一个进程中间，一个进程在由 pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（管道）。管道两端可 分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。</p><ul><li><p>首先使用strtok识别出指令</p></li><li><p>接着使用cmd_argvs函数识别每条指令的参数</p></li><li><p>创建子进程完成其中一条指令</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">close(fd[0]);dup2(fd[1],STDOUT_FILENO);&#x2F;&#x2F;修改文件描述符，改变命令输出，实现输出重定向close(fd[1]);execvp(cmd1.argv[0],cmd1.argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>父进程完成另一条指令</li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">close(pfd[1]);dup2(pfd[0],STDIN_FILENO);&#x2F;&#x2F;修改文件描述符，改变命令输入，实现输入重定向close(pfd[0]);execvp(cmd2.argv[0],cmd2.argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>父进程等待子进程结束后运行下一条命令，这里用到了waitpid（）命令，该命令可以指定等待某一子进程，调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</li></ul><h4 id="2-2-5-输入输出重定向"><a href="#2-2-5-输入输出重定向" class="headerlink" title="2.2.5 输入输出重定向"></a>2.2.5 输入输出重定向</h4><p><strong>用到的函数：</strong></p><table><thead><tr><th>用到的函数</th><th>作用</th></tr></thead><tbody><tr><td>strtok()</td><td>字符串分割函数，用于识别重定向符号链接的两个命令</td></tr><tr><td>dup2()</td><td>用于实现文件重定向，实现将标准输入输出文件描述符指定向我们定义的filename</td></tr><tr><td>close()</td><td>关闭文件</td></tr><tr><td>open()</td><td>打开我们要重定向到的文件</td></tr><tr><td>execvp()</td><td>执行文件函数，执行UNIX命令</td></tr><tr><td>fork()</td><td>创建子进程用于执行命令</td></tr></tbody></table><p><strong>流程与步骤：</strong></p><ul><li><p>strtok,字符串分割函数，用于获取重定向符号所连接的指令，以及指令中的信息（重定向输出的文件名，重定向输入的文件名等）</p></li><li><p>利用cmd_argvs函数获取cmd的参数</p></li><li><p>使用<code>dup2()</code>函数实现重定向,具体分以下三类</p><ul><li>识别到<code>&gt;</code>重定向标志符，<code>dup2(cmd1.outfd,STDOUT_FILENO);</code>将标准输出的文件描述符指向我们重定向需要输出的文件。</li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">if((cmd1.outfd &#x3D; open(instr,OUTFILE,PERM)) &lt; 0)&#123;sys_err(&quot;open failed&quot;);&#125;dup2(cmd1.outfd,STDOUT_FILENO);&#x2F;&#x2F;实现重定向close(cmd1.outfd);execvp(cmd1.argv[0],cmd1.argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>识别到<code>&gt;&gt;</code>文件描述符，依旧使用<code>dup2(cmd1.outfd,STDOUT_FILENO);</code>将标准输出的文件描述符指向我们重定向需要输出的文件,至于如何实现以append的形式输出，我们只需要使用open函数时</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if ((cmd1.outfd &#x3D; open(instr,OUTFILE_APPEND,PERM)) &lt; 0) &#123;&#x2F;&#x2F;实现以APPEND方式打开文件    ‘&#x2F;&#x2F;其中OUTFILE_APPEND &#x3D; O_WRONLY|O_CREAT|O_APPENDsys_err(&quot;open failed&quot;);&#125;dup2(cmd1.outfd,STDOUT_FILENO);&#x2F;&#x2F;实现重定向close(cmd1.outfd);execvp(cmd1.argv[0],cmd1.argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>识别到<code>&lt;</code>文件描述符，使用<code>dup2(cmd1.outfd,STDIN_FILENO);</code>将标准输入的文件描述符指向我们重定向输入的文件。</li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">if((cmd1.infd &#x3D; open(instr,O_RDONLY)) &lt; 0)&#123;&#x2F;&#x2F;只读方式打开文件sys_err(&quot;open failed&quot;);&#125;dup2(cmd1.infd,STDIN_FILENO);&#x2F;&#x2F;重定向输入close(cmd1.infd);execvp(cmd1.argv[0],cmd1.argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>子进程运行命令<code>execvp(cmd, args)</code></p></li><li><p>父进程等待子进程结束后运行下一条命令，这里仍然用到了waitpid（）命令，指定等待某一子进程。</p></li></ul><h3 id="3-1-我学到的"><a href="#3-1-我学到的" class="headerlink" title="3.1 我学到的"></a>3.1 我学到的</h3><h4 id="3-1-1-关于管道"><a href="#3-1-1-关于管道" class="headerlink" title="3.1.1 关于管道"></a>3.1.1 关于管道</h4><p>在操作系统和UNIX课程中我已经了解到了管道的相关概念，但是在本次大作业中具体实现管道这个概念时，我一开始无从下手，查阅相关资料后我了解到在Unix已经实现了一个相关函数pipe（），我们可以利用该函数实现管道。</p><ul><li><p>首先通过该函数创建管道， int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno。函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。</p></li><li><p>接着采用如下步骤实现父子进程间通信</p><ul><li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道22的读端和写端。</li><li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li></ul></li></ul><p><img src="https://img-blog.csdn.net/20161223173958916"></p><h4 id="3-1-2-关于重定向"><a href="#3-1-2-关于重定向" class="headerlink" title="3.1.2 关于重定向"></a>3.1.2 关于重定向</h4><p>在Unix课程学习中我了解到，Unix中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。为了表示和区分已经打开的文件，Unix 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。</p><table><thead><tr><th>文件描述符</th><th>文件名</th><th>类型</th></tr></thead><tbody><tr><td>0</td><td>stdin</td><td>标准输入</td></tr><tr><td>1</td><td>stdout</td><td>标准输出</td></tr><tr><td>2</td><td>stderr</td><td>标准错误输出</td></tr></tbody></table><p>而一个程序运行起来，进程会默认打开三个文件，即标准输出，标准输入与标准错误。知道了这些，实现起重定向就比较简单了，只需要使用open（）函数打开我们需要重定向到的文件，接着使用<code>dup2()</code>函数将进程的标准输出或标准输入重定向到该文件即可。</p><h3 id="3-2-扩展功能与优缺点"><a href="#3-2-扩展功能与优缺点" class="headerlink" title="3.2  扩展功能与优缺点"></a>3.2  扩展功能与优缺点</h3><h4 id="3-2-1-命令格式的限制"><a href="#3-2-1-命令格式的限制" class="headerlink" title="3.2.1 命令格式的限制"></a>3.2.1 命令格式的限制</h4><p>在本次大作业中我实现的shell指令与重定向、管道符号必须要用空格隔开，比如<code>cat shell.c &gt; ans.txt</code>不能写作<code>cat shell.c&gt;ans.txt</code>,同时指令的参数不能带引号，比如 <code>grep -n cmd</code> 不能写作<code>grep -n &quot;cmd&quot;</code>。这些显然都是myshell的功能不足之处，这是因为在本次作业中我使用了strtok字符串分割函数实现指令的分割与识别，这必然不能考虑到全面的情况，未来可能可以使用正则表达式匹配的方式覆盖更加全面的的情况。</p><h4 id="3-2-2-实现的连接方式比较简单"><a href="#3-2-2-实现的连接方式比较简单" class="headerlink" title="3.2.2 实现的连接方式比较简单"></a>3.2.2 实现的连接方式比较简单</h4><p>本次大作业实现的shell可以运行的指令比较简单，比如管道只能连接两个指令，不能有过多的管道符号与重定向符号例如<code>cat shell.c | grep -n cmd &gt; ans.txt </code>等。</p><h3 id="4-1-课程感悟与思考"><a href="#4-1-课程感悟与思考" class="headerlink" title="4.1 课程感悟与思考"></a>4.1 课程感悟与思考</h3><p>在本次作业中学习到了关于UNIX的很多知识，这些知识对我学习操作系统有很大的帮助，包括shell命令，文件管理，存储管理这些知识对我</p>]]></content>
      
      
      
        <tags>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成P5与P6的总结</title>
      <link href="/2022/05/09/ji-suan-ji-zu-cheng-p5-yu-p6-de-zong-jie/"/>
      <url>/2022/05/09/ji-suan-ji-zu-cheng-p5-yu-p6-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><strong>(阅前声明，我用的分布式译码方法，因此一些修改可能与集中式译码的方式不太一样）</strong></p><h4 id="P5与P6的套路"><a href="#P5与P6的套路" class="headerlink" title="P5与P6的套路"></a>P5与P6的套路</h4><p>在完成P5与P6的过程中，发现课上考的一些指令都大同小异，先将其整理为四类功能的组合。<br>所有新增指令是这几种功能的相互组合</p><ul><li><h5 id="条件存储-根据不同的条件，从DM中取出的数值不同"><a href="#条件存储-根据不同的条件，从DM中取出的数值不同" class="headerlink" title="条件存储 根据不同的条件，从DM中取出的数值不同"></a>条件存储 根据不同的条件，从DM中取出的数值不同</h5></li><li><h5 id="条件计算-根据不同的条件，ALU执行的运算结果不同"><a href="#条件计算-根据不同的条件，ALU执行的运算结果不同" class="headerlink" title="条件计算 根据不同的条件，ALU执行的运算结果不同"></a>条件计算 根据不同的条件，ALU执行的运算结果不同</h5></li><li><h5 id="条件跳转-根据不同的条件，NPC跳转还是不跳转"><a href="#条件跳转-根据不同的条件，NPC跳转还是不跳转" class="headerlink" title="条件跳转 根据不同的条件，NPC跳转还是不跳转"></a>条件跳转 根据不同的条件，NPC跳转还是不跳转</h5></li><li><h5 id="条件写入寄存器-根据不同的条件，指令写入寄存器的地址不同（根据不同的条件，指令写或不写也归入这一类中，因为我们使用AT法写地址为0就是不写，本质上还是写地址不确定）"><a href="#条件写入寄存器-根据不同的条件，指令写入寄存器的地址不同（根据不同的条件，指令写或不写也归入这一类中，因为我们使用AT法写地址为0就是不写，本质上还是写地址不确定）" class="headerlink" title="条件写入寄存器  根据不同的条件，指令写入寄存器的地址不同（根据不同的条件，指令写或不写也归入这一类中，因为我们使用AT法写地址为0就是不写，本质上还是写地址不确定）"></a>条件写入寄存器  根据不同的条件，指令写入寄存器的地址不同（根据不同的条件，指令写或不写也归入这一类中，因为我们使用AT法写地址为0就是不写，本质上还是写地址不确定）</h5></li></ul><p>至于为什么目前只看到这几种不同功能之间的组合，是因为P5，P6主要考察我们对于流水线问题的理解，而流水线中最重要的部分就是数据通路中的各个功能元件的使用，和阻塞转发的理解。</p><h4 id="要考察对于功能元件的理解，我们首先想想流水线中有哪些很重要的原件？"><a href="#要考察对于功能元件的理解，我们首先想想流水线中有哪些很重要的原件？" class="headerlink" title="要考察对于功能元件的理解，我们首先想想流水线中有哪些很重要的原件？"></a>要考察对于功能元件的理解，我们首先想想流水线中有哪些很重要的原件？</h4><ol><li><strong>在D级中</strong>，最重要的原件肯定是NPC和GPR，由于GPR没啥可改的，所以NPC是考试的重点，于是便有了条件跳转这种考查方式。</li><li><strong>E级</strong>，肯定是ALU，HILO乘除槽最重要，这俩本质都是一个计算部件，于是便有了条件计算这种考查方式。</li><li><strong>M级</strong>，无可置是DM，于是便有了条件存储这种考查方式。</li><li><strong>W级和F级</strong>都没有什么重要的功能部件，没有特别的考察方式。</li></ol><h4 id="要考察对于转发阻塞的理解，该如何考察呢？"><a href="#要考察对于转发阻塞的理解，该如何考察呢？" class="headerlink" title="要考察对于转发阻塞的理解，该如何考察呢？"></a>要考察对于转发阻塞的理解，该如何考察呢？</h4><p>由于在流水线中我们在所有的该转发的地方都转发了，阻塞只要用AT法，把Tnew，Tuse确定好就可以，总的来说已经很完备，没有什么可以改动的地方。于是便诞生了这样一种考查方式，<strong>如果写地址在一段时间内不确定呢</strong>？这样该如何转发和阻塞呢？<br>这就是我们的条件写寄存器功能，重点考察的是对于转发和阻塞功能的理解。<br>理解了为什么这样考察，有助于我们接下来更好的解题。</p><h3 id="1-如何进行条件判断？"><a href="#1-如何进行条件判断？" class="headerlink" title="1.如何进行条件判断？"></a>1.如何进行条件判断？</h3><p>所有上述四个功能的实现均基于条件判断。只有判断正确，我们才能确定是执行哪个功能？<br>看起来很简单，但这里又是一个很大的坑？**$signed的如何正确应用**<br>这里可以参考学长的博客，里面有关于$signed的理解，$signed搭配三目运算符，搭配小于&lt;,大于&gt;号很容易犯错。例如下面这样一种情况。</p><pre class="line-numbers language-v" data-language="v"><code class="language-v">always @<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>begin    <span class="token keyword">if</span><span class="token punctuation">(</span>$<span class="token function">signed</span><span class="token punctuation">(</span>ALU_A<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">//....wrong </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>$<span class="token function">signed</span><span class="token punctuation">(</span>ALU_A<span class="token punctuation">)</span><span class="token operator">&lt;</span>$<span class="token function">signed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">//....right</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行有符号数的大小比较时，最好全部加上<code>$signed</code>符号,因为整个表达式中只要有一个数被判定为无符号数，整个表达式中所有的<code>$signed</code>符号均可能失效，导致结果错误。条件判断目前看来的坑点就在于此。</p><h3 id="2-如何单独解决条件计算功能"><a href="#2-如何单独解决条件计算功能" class="headerlink" title="2.如何单独解决条件计算功能"></a>2.如何单独解决条件计算功能</h3><p>有了条件判断我们便可以执行这四条功能。首先是条件跳转功能，条件跳转只要更改CU控制信号，NPC内部case语句，CMP内部case语句即可。</p><h3 id="3-如何单独解决条件计算指功能"><a href="#3-如何单独解决条件计算指功能" class="headerlink" title="3.如何单独解决条件计算指功能"></a>3.如何单独解决条件计算指功能</h3><p>修改CU控制信号，修改ALU,HILO乘除槽内部逻辑。<br>这里还有一个坑点，老朋友$signed又来了，坑就坑在$signed与乘除法的搭配<br>我们知道verilog乘除法默认是无符号乘除的，如果这时冒出来什么奇奇怪怪的功能要求加减乘除混合<strong>有符号</strong>运算，这里又有一个坑。</p><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token punctuation">&#123;</span>HI<span class="token punctuation">,</span>LO<span class="token punctuation">&#125;</span><span class="token operator">=</span>HI<span class="token operator">+</span>$<span class="token function">signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">*</span>$<span class="token function">signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token comment">// wrong</span><span class="token punctuation">&#123;</span>HI<span class="token punctuation">,</span>LO<span class="token punctuation">&#125;</span><span class="token operator">=</span>$<span class="token function">signed</span><span class="token punctuation">(</span>$<span class="token function">signed</span><span class="token punctuation">(</span>HI<span class="token punctuation">)</span><span class="token operator">+</span>$<span class="token function">signed</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">*</span>$<span class="token function">signed</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//right</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>跟条件判断中的原因一样，还是<code>$signed</code>符号用法的坑，这时我们最好全都给他套上<code>$signed</code>,以防万一</p><h3 id="4-如何实现条件存储指令"><a href="#4-如何实现条件存储指令" class="headerlink" title="4.如何实现条件存储指令"></a>4.如何实现条件存储指令</h3><p>这个基本没有什么坑，只要修改CU控制信号，DM内部逻辑。</p><h3 id="5-如何实现条件写指令并将其与各种功能搭配"><a href="#5-如何实现条件写指令并将其与各种功能搭配" class="headerlink" title="5.如何实现条件写指令并将其与各种功能搭配"></a>5.如何实现条件写指令并将其与各种功能搭配</h3><p><strong>写在前面，这个是最复杂的</strong></p><ul><li>先实现条件写指令与其他功能的搭配。<ul><li>搭配方式（三种功能全都可以搭）：<ul><li>条件跳转+条件写</li><li>条件计算+条件写</li><li>条件存储+条件写</li></ul></li><li>可以看到，前面4种功能都进行了条件判断，条件写指令需要他们的条件判断信号。因此我们的实现方式如下：</li><li><ol><li>将所有的条件判断信号输出来（指的是从CMP,ALU，DM中输出），配合分布式译码输出的信号生成一个<strong>check信号</strong>，这些check信号都要一级一级传下去，并在每一级输入分布CU，以便条件写功能的实现，代码和具体解释如下。</li></ol></li></ul></li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token comment">//以下的xxx代表了一条具备条件跳转或条件计算或条件存储功能的指令，我们把它从CU中译出来并输出</span><span class="token comment">//条件跳转指令在D级生成check信号并传下去</span>assign D_check <span class="token operator">=</span> xxx<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>b_jump<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//条件计算指令在E级生成check信号并传下去</span>assign E_check <span class="token operator">=</span> xxx<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>ALUorHILO_judge<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//条件存储指令在M级生成check信号并传下去</span>assign M_check <span class="token operator">=</span> xxx<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>DM_judge<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ol start="2"><li>将check信号输入每一级CU后，根据指令搭配的说明，修改CU中的写地址译码和写数据译码，有了check信号这个概念，这步很简单，需要注意的是，如果我们的check信号不是从一开始的D级就产生，比如说在M级才产生，才输入CU，由于我们使用的是分布式译码，那么我们之前CU里面的check信号是一个x信号，出现不确定错误。这一步避免很简单，只需要在CU里面把<code>==</code>号，改成<code>===</code>号，规避x这类的错误判断</li></ol></li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token keyword">if</span><span class="token punctuation">(</span>xxx <span class="token operator">&amp;&amp;</span> check <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span>    RFA3 <span class="token operator">=</span> rt_addr<span class="token comment">//.................</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><ol start="3"><li>最后修改转发阻塞逻辑。我们明显可以看出这几条搭配有一个共同特点，<strong>一段时期不知道写地址是啥，究竟写还是不写？</strong></li></ol><ul><li>条件跳转+条件写,E级知道写地址</li><li>条件计算+条件写,M级知道写地址</li><li>条件存储+条件写,W级知道写地址</li><li>（PS.你可能会问，为什么都延后了一级，我认为在实际情况中，该级的条件判断输出是不稳定的，有一定延迟，把它输入到下一级流水线寄存器才是一个稳定的信号，所以我们按实际情况来想延后了一级）</li></ul></li><li><p><strong>我们规定，在明确写地址后才能转发。不明确写地址前，冒然转发会导致错误，这里搭配阻塞功能，只要可能发生冲突且此时不明确写地址，均阻塞</strong>。</p></li><li><p>接下来我们按照上述逻辑修改阻塞单元。</p><ul><li>条件跳转+条件写,E级知道写地址，不用修改阻塞，因为E级才开始有转发供给者，在这一级转发必不可能有错误。</li><li>条件计算+条件写,M级知道写地址，E级冒然转发可能有错误，可以在这里如果D级可能出现冲突，阻塞一个周期，等待该指令从E到M。</li><li>条件存储+条件写,W级知道写地址，E，M级冒然转发可能有错误，可以在这里如果D级可能出现冲突，阻塞两个周期，等待该指令从E到W。<br>举个例子，这里假设有一条lwso指令，既可能写rt，又可能写$31,我们这样修改E级阻塞.</li></ul></li></ul><pre class="line-numbers language-v" data-language="v"><code class="language-v"><span class="token comment">//stall rs</span>wire stall_rs_E <span class="token operator">=</span> <span class="token punctuation">(</span>Tuse_rs <span class="token operator">&lt;</span> Tnew_E<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lwso<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">(</span>D_rs_addr <span class="token operator">==</span> E_rt_addr<span class="token operator">||</span>D_rs_addr <span class="token operator">==</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">:</span>D_rs_addr <span class="token operator">==</span> E_RFA3<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>D_rs_addr<span class="token punctuation">;</span><span class="token comment">//stall_rt_E也是一样的修改</span>wire stall_rs <span class="token operator">=</span> stall_rs_E <span class="token operator">|</span> stall_rs_M<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>到此为止我们全部修改完毕，功能可以正常运行<br>最后，这几种功能可以各种搭配，但目前为止还只有搭配条件写的这种方式，希望可以通过对于考察方式的理解，帮助你更好的完成P5，P6的课上测试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成P2</title>
      <link href="/2022/05/09/ji-suan-ji-zu-cheng-p2/"/>
      <url>/2022/05/09/ji-suan-ji-zu-cheng-p2/</url>
      
        <content type="html"><![CDATA[<p><strong>查看程序运行指令数的代码</strong><br><code>java -jar Mars4_5.jar ic xxx.asm</code></p><h4 id="一维数组取址"><a href="#一维数组取址" class="headerlink" title="一维数组取址"></a>一维数组取址</h4><h4 id="二维数组取址"><a href="#二维数组取址" class="headerlink" title="二维数组取址"></a>二维数组取址</h4><h4 id="注意存取字，还是存取字节，要分别正确使用lw-sw-lb-sb"><a href="#注意存取字，还是存取字节，要分别正确使用lw-sw-lb-sb" class="headerlink" title="注意存取字，还是存取字节，要分别正确使用lw,sw;lb,sb;"></a>注意存取字，还是存取字节，要分别正确使用lw,sw;lb,sb;</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成P1</title>
      <link href="/2022/05/09/ji-suan-ji-zu-cheng-p1/"/>
      <url>/2022/05/09/ji-suan-ji-zu-cheng-p1/</url>
      
        <content type="html"><![CDATA[<h3 id="课下准备"><a href="#课下准备" class="headerlink" title="课下准备"></a>课下准备</h3><h5 id="关于-signed的理解"><a href="#关于-signed的理解" class="headerlink" title="关于$signed的理解"></a>关于<code>$signed</code>的理解</h5><ul><li>一个表达式如果存在一个无符号数，那么整个表达式都会被当做无符号数</li><li>位选、多位选择器、位拼接的结果是无符号的</li><li>比较表达式的结果是无符号的</li><li>计算表达式时，先得出最外层表达式的符号性，再向表达式内部的操作数传递符号性</li><li>尽量不要用sign搭配三目元算符，可以使用<code>always@（*）</code>搭配位拼接运算符，来实现左移和右移</li></ul><h5 id="三目运算符的使用"><a href="#三目运算符的使用" class="headerlink" title="三目运算符的使用"></a>三目运算符的使用</h5><p>涉及有符号数的运算，尽量不要使用三目运算符，如果三目运算符中包含一个无符号数，那么所有的操作数都会被当作无符号数来运算</p><h5 id="位拼接运算符错误写法"><a href="#位拼接运算符错误写法" class="headerlink" title="位拼接运算符错误写法"></a>位拼接运算符错误写法</h5><p>例如将16位a符号扩展<code>&#123;16&#123;a[15]&#125;,a&#125;</code>是错误的，少写了一层大括号，应该为<code>&#123;&#123;16&#123;a[15]&#125;&#125;,a&#125;</code></p><h5 id="assign用法"><a href="#assign用法" class="headerlink" title="assign用法"></a>assign用法</h5><p>assign 赋值时，右边为运算表达式，左边必须为一个register<br><code>Procedural assignment to a non-register C is not permitted, left-hand side should be reg/integer/time/genvar</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成P0</title>
      <link href="/2022/05/09/ji-suan-ji-zu-cheng-p0/"/>
      <url>/2022/05/09/ji-suan-ji-zu-cheng-p0/</url>
      
        <content type="html"><![CDATA[<h3 id="上机前注意事项"><a href="#上机前注意事项" class="headerlink" title="上机前注意事项"></a>上机前注意事项</h3><h5 id="1-有限状态机的题目一定要看清题目，不然后来要更改会非常麻烦，真的要认真看题，认真看题！！！"><a href="#1-有限状态机的题目一定要看清题目，不然后来要更改会非常麻烦，真的要认真看题，认真看题！！！" class="headerlink" title="1.有限状态机的题目一定要看清题目，不然后来要更改会非常麻烦，真的要认真看题，认真看题！！！"></a>1.有限状态机的题目一定要看清题目，不然后来要更改会非常麻烦，真的要认真看题，认真看题！！！</h5><h5 id="2-有限状态机的题目，最好把状态进行分位，这样修改子电路的时候也好修改，因为子电路是分位输入的，可以使用功能analysis-circuit，例如下面这个电路-他把状态码分位表示了，比较方便-所以搭建状态的时候可以外面分好，保存到寄存器时在合起来，寄存器输出时再分开"><a href="#2-有限状态机的题目，最好把状态进行分位，这样修改子电路的时候也好修改，因为子电路是分位输入的，可以使用功能analysis-circuit，例如下面这个电路-他把状态码分位表示了，比较方便-所以搭建状态的时候可以外面分好，保存到寄存器时在合起来，寄存器输出时再分开" class="headerlink" title="2.有限状态机的题目，最好把状态进行分位，这样修改子电路的时候也好修改，因为子电路是分位输入的，可以使用功能analysis circuit，例如下面这个电路,他把状态码分位表示了，比较方便,所以搭建状态的时候可以外面分好，保存到寄存器时在合起来，寄存器输出时再分开"></a>2.有限状态机的题目，最好把状态进行分位，这样修改子电路的时候也好修改，因为子电路是分位输入的，可以使用功能analysis circuit，例如下面这个电路,他把状态码分位表示了，比较方便,所以搭建状态的时候可以外面分好，保存到寄存器时在合起来，寄存器输出时再分开</h5><p><img src="https://note.youdao.com/yws/api/personal/file/444CF6B590AE41C7AC676C2E7196E523?method=download&shareKey=b4de594a05e555d3cbdc4c0a19b5d30c" alt="a"></p><h5 id="3-同步复位和异步复位的问题，同步复位我们可以使用与门，异步复位我们直接在该初始化的地方加reset"><a href="#3-同步复位和异步复位的问题，同步复位我们可以使用与门，异步复位我们直接在该初始化的地方加reset" class="headerlink" title="3.同步复位和异步复位的问题，同步复位我们可以使用与门，异步复位我们直接在该初始化的地方加reset"></a>3.同步复位和异步复位的问题，同步复位我们可以使用与门，异步复位我们直接在该初始化的地方加reset</h5><ul><li><strong>同步复位</strong><br><strong>同步复位一种更简便的实现方法</strong><br><img src="https://note.youdao.com/yws/api/personal/file/91EE4D8BCE2043A0BC0C74D39818E525?method=download&shareKey=4f8a4f76920029040cfe1b47be44bf1e" alt="sd"></li><li><strong>异步复位</strong><br>如第一个图，我们直接全部添加reset信号，可以立即实现对输出和状态寄存器的置0.</li></ul><h5 id="4-题中说要建立一个Moore状态机，如果此时有一个输出与输入有关，此时要在该输出处加一个寄存器，使其延缓一个周期，以从mealy状态机变为Moore状态机输出"><a href="#4-题中说要建立一个Moore状态机，如果此时有一个输出与输入有关，此时要在该输出处加一个寄存器，使其延缓一个周期，以从mealy状态机变为Moore状态机输出" class="headerlink" title="4.题中说要建立一个Moore状态机，如果此时有一个输出与输入有关，此时要在该输出处加一个寄存器，使其延缓一个周期，以从mealy状态机变为Moore状态机输出"></a>4.题中说要建立一个Moore状态机，如果此时有一个输出与输入有关，此时要在该输出处加一个寄存器，使其延缓一个周期，以从mealy状态机变为Moore状态机输出</h5><p>如第一个图，下面一个输出跟输入量有关，但由于此时我们要建立的是moore状态机而不是mealy，因此我们要把该输出滞后一个周期输出以对应moore周期，因此我们加了一个寄存器。</p><h5 id="5-写状态转换表的时候记得从高位到低位写，不然很别扭"><a href="#5-写状态转换表的时候记得从高位到低位写，不然很别扭" class="headerlink" title="5. 写状态转换表的时候记得从高位到低位写，不然很别扭"></a>5. 写状态转换表的时候记得从高位到低位写，不然很别扭</h5><h2 id="几个方法"><a href="#几个方法" class="headerlink" title="几个方法"></a>几个方法</h2><ol><li>取数据特定几位的方法，比如要取32位数据的x-y位，将一个32位1<code>logic</code>左移x位后取反，将一个32位1左移y位，取反，二者取与，即可将要取的地址位全部置1，此时只要与32位原数据与一下即可。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mips汇编语言</title>
      <link href="/2022/05/09/mips-hui-bian-yu-yan/"/>
      <url>/2022/05/09/mips-hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="Mips汇编语言学习（预习pre1）"><a href="#Mips汇编语言学习（预习pre1）" class="headerlink" title="Mips汇编语言学习（预习pre1）"></a>Mips汇编语言学习（预习pre1）</h2><h3 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a>大端存储与小端存储</h3><p><img src="https://note.youdao.com/yws/api/personal/file/8F744AD7AB4441F19CCC744C87C4A077?method=download&shareKey=dcf6d754f1ec4cd68d571f1406060482" alt="t"><br>在Mips中使用的是<em>小端存储</em>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>textli $t0<span class="token punctuation">,</span><span class="token number">0x12345678</span>sw $t0<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则在存储区内第一个格子显示的便是0x12345678，在存储区内，每一个格子从左到右地址增加，在每一个格子内，地址从右到左以此增加，每一个格子4个字节，一个字，正好一个<code>int</code>。<br>再比如，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>data <span class="token number">0x00001000</span> num<span class="token operator">:</span><span class="token punctuation">.</span><span class="token keyword">byte</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于使用了小端存储，所以数据存储时，在每一个存储字内，从右到左存储，存储满后再在高地址的字中存储,如下图：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://note.youdao.com/yws/api/personal/file/CAD044EE12144AF3B7D8A8D4D7CF9D34?method=download&shareKey=eaf54321411ca2b54b806af632e1b3f1" alt="a"></h2><h3 id="三种类型的指令"><a href="#三种类型的指令" class="headerlink" title="三种类型的指令"></a>三种类型的指令</h3><ul><li><strong>R型指令</strong>，一般为运算指令，如<code>add</code>，<code>sub</code>，<code>sll</code>等，一般有多个操作数</li><li><strong>I型指令</strong>，有16位立即数<ul><li>例如<code>addi</code>，<code>subi</code>，<code>ori</code></li><li>例如<code>beq</code>，<code>bgtz</code>带标签的跳转指令</li><li><code>sw</code>，<code>lw</code>带<code>offset</code>的存取指令</li></ul></li><li><strong>J型指令</strong><ul><li><code>j</code>，<code>jal</code>跳转指令</li></ul></li></ul><h3 id="系统调用与递归的使用"><a href="#系统调用与递归的使用" class="headerlink" title="系统调用与递归的使用"></a>系统调用与递归的使用</h3><p><strong>本题目内容为：</strong><br><img src="https://note.youdao.com/yws/api/personal/file/B871BA8C8FDF40168033616596970863?method=download&shareKey=4ddc8c329883643a20f62a1750c7c0f2" alt="a"><br><strong>先看一段代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>data graph<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">256</span>visit<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">40</span>path<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">40</span>stack<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">800</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>data空间初始化时不能过大，mips总共的存储空间大概有<strong>4000字节</strong>左右<br>在data数据段中我们定义了栈stack，栈用于函数调用后返回时获取之前的数据.在函数调用时我们规定用寄存器<code>$a0</code>,<code>$a1``$a2</code>,<code>$a3</code>传4个参，用<code>$v0</code>做返回值。在函数中，拿到参数后，<strong>一定要把参数从<code>$a0</code>中取出再使用</strong>，否则会发生错误。在调用参数时我们**需要在栈中存储返回地址<code>$ra</code>**，以便子函数知道返回到哪里，同时我们如果需要，也会存储一些<code>$s</code>，<code>$t</code>类型寄存器，同时可能会有多于4个的参数，这时我们还需要在栈内存储这些参数。<br>我们规定在栈中存储时按照以下顺序：<br><img src="https://note.youdao.com/yws/api/personal/file/FE343489099E40329445049C3D661C97?method=download&shareKey=08d25854d10eadb542e47596ad8068e6" alt="a"></p><p><strong>宏定义</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>macro <span class="token function">getindex</span><span class="token punctuation">(</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>i<span class="token punctuation">,</span><span class="token operator">%</span>j<span class="token punctuation">)</span> sll <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>i<span class="token punctuation">,</span><span class="token number">3</span>add <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>jsll <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span>end_macro<span class="token punctuation">.</span>macro <span class="token function">getindex2</span><span class="token punctuation">(</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>i<span class="token punctuation">)</span> <span class="token comment">//这里运用了宏定义，方便的获取数据存储的地址</span>li <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token number">0</span>add <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>isll <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span>end_macro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是主函数，主函数完成了：</p><ul><li>初始化栈</li><li>数据读入与存储</li><li>传参</li><li>处理返回值</li><li>最终输出</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>textmain<span class="token operator">:</span>la $sp<span class="token punctuation">,</span>stack   <span class="token comment">//让栈指针初始化</span>addiu $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">800</span>  <span class="token comment">//栈指针指向栈顶</span>li $v0<span class="token punctuation">,</span><span class="token number">5</span>syscallmove $s0<span class="token punctuation">,</span>$v0 #$s0 is the nli $v0<span class="token punctuation">,</span><span class="token number">5</span>syscallmove $s1<span class="token punctuation">,</span>$v0 #s1 is mli $t0<span class="token punctuation">,</span><span class="token number">0</span>  #ifor_i1_begin<span class="token operator">:</span>beq $t0<span class="token punctuation">,</span>$s1<span class="token punctuation">,</span>for_i1_end#read_graphli $v0<span class="token punctuation">,</span><span class="token number">5</span>syscallmove $t2<span class="token punctuation">,</span>$v0subi $t2<span class="token punctuation">,</span>$t2<span class="token punctuation">,</span><span class="token number">1</span>li  $v0<span class="token punctuation">,</span><span class="token number">5</span>syscallmove $t3<span class="token punctuation">,</span>$v0subi $t3<span class="token punctuation">,</span>$t3<span class="token punctuation">,</span><span class="token number">1</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t4<span class="token punctuation">,</span>$t2<span class="token punctuation">,</span>$t3<span class="token punctuation">)</span>#t4 store addressli $t5<span class="token punctuation">,</span><span class="token number">1</span> #t5 store the <span class="token number">1</span>sw $t5<span class="token punctuation">,</span><span class="token function">graph</span><span class="token punctuation">(</span>$t4<span class="token punctuation">)</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t4<span class="token punctuation">,</span>$t3<span class="token punctuation">,</span>$t2<span class="token punctuation">)</span>sw $t5<span class="token punctuation">,</span><span class="token function">graph</span><span class="token punctuation">(</span>$t4<span class="token punctuation">)</span>addi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span>j for_i1_beginfor_i1_end<span class="token operator">:</span>li $t5<span class="token punctuation">,</span><span class="token number">1</span>sw $t5<span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span>li $s2<span class="token punctuation">,</span><span class="token number">1</span>  #s2 is current<span class="token comment">//调用函数</span>#use hamcyclemove $a0<span class="token punctuation">,</span>$s2 #a0 is current <span class="token comment">//传参</span>jal hamcycle<span class="token comment">//函数返回</span>#judgebeq $v0<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token punctuation">,</span>if_is_0li $a0<span class="token punctuation">,</span><span class="token number">1</span>li $v0<span class="token punctuation">,</span><span class="token number">1</span>syscallj endif_is_0<span class="token operator">:</span>li $a0<span class="token punctuation">,</span><span class="token number">0</span>li $v0<span class="token punctuation">,</span><span class="token number">1</span>syscallend<span class="token operator">:</span>li $v0<span class="token punctuation">,</span><span class="token number">10</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是调用的函数，注意只要不是叶函数，还需往下调用子函数，一定要把该保存的保存到栈空间中，<strong>尤其是返回地址</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">hamcycle<span class="token operator">:</span>    <span class="token comment">//递归底层</span>bne $a0<span class="token punctuation">,</span>$s0<span class="token punctuation">,</span><span class="token keyword">else</span>move $t0<span class="token punctuation">,</span>$a0subi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>lw $t2<span class="token punctuation">,</span><span class="token function">path</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span> #t2 is path<span class="token punctuation">[</span>current <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t4<span class="token punctuation">,</span>$t2<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token punctuation">)</span>lw $t3<span class="token punctuation">,</span><span class="token function">graph</span><span class="token punctuation">(</span>$t4<span class="token punctuation">)</span>beq $t3<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token punctuation">,</span>if_hasno_verge_to0li $v0<span class="token punctuation">,</span><span class="token number">1</span>  <span class="token comment">//返回参数</span>jr $raif_hasno_verge_to0<span class="token operator">:</span>li $v0<span class="token punctuation">,</span><span class="token number">0</span>   <span class="token comment">//返回参数</span>jr $ra<span class="token keyword">else</span><span class="token operator">:</span>    <span class="token comment">//这里一定要把参数取出来再使用</span>move $t7<span class="token punctuation">,</span>$a0 #t7 is currentli $t0<span class="token punctuation">,</span><span class="token number">1</span> #t0 is i for_i2_begin<span class="token operator">:</span>beq $t0<span class="token punctuation">,</span>$s0<span class="token punctuation">,</span>for_i2_end#<span class="token keyword">if</span> visit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span>$$graph<span class="token punctuation">[</span>path<span class="token punctuation">[</span>current <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t4<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>lw $t1<span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span>$t4<span class="token punctuation">)</span>bne $t1<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token punctuation">,</span>else_has_visited move $t1<span class="token punctuation">,</span>$t7subi $t1<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span><span class="token number">1</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t2<span class="token punctuation">,</span>$t1<span class="token punctuation">)</span>lw $t3<span class="token punctuation">,</span><span class="token function">path</span><span class="token punctuation">(</span>$t2<span class="token punctuation">)</span> #t3 is path<span class="token punctuation">[</span>current <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t4<span class="token punctuation">,</span>$t3<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>lw $t5<span class="token punctuation">,</span><span class="token function">graph</span><span class="token punctuation">(</span>$t4<span class="token punctuation">)</span>li $t6<span class="token punctuation">,</span><span class="token number">1</span>bne $t5<span class="token punctuation">,</span>$t6<span class="token punctuation">,</span>else_has_visited#####<span class="token keyword">if</span> yes<span class="token function">getindex2</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>sw $t6<span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t7<span class="token punctuation">)</span>sw $t0<span class="token punctuation">,</span><span class="token function">path</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span>####<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">hamcycle</span><span class="token punctuation">(</span>current<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token comment">//重点！！！！！！！！，栈的使用</span>        <span class="token comment">//由于这里不是叶函数，所以一定要把返回地址$ra存进来，同时有用的临时变量也要存储起来，栈要从上到下使用</span>sw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>subi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>   <span class="token comment">//$t7返回后还要使用</span>subi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t0<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>   <span class="token comment">//$t0返回后还要使用，因为还要继续循环</span>subi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>addi $t7<span class="token punctuation">,</span>$t7<span class="token punctuation">,</span><span class="token number">1</span>move $a0<span class="token punctuation">,</span>$t7    <span class="token comment">//传参</span>jal hamcycle    <span class="token comment">//递归</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>   <span class="token comment">//栈用完了以后一定要回复，防止使用混乱</span>lw $t0<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>li $t1<span class="token punctuation">,</span><span class="token number">1</span>bne $v0<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span>if_isno_1li $v0<span class="token punctuation">,</span><span class="token number">1</span>jr $raif_isno_1<span class="token operator">:</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t7<span class="token punctuation">)</span>li $t2<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span>sw $t2<span class="token punctuation">,</span><span class="token function">path</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span><span class="token function">getindex2</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>sw $<span class="token number">0</span><span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span>else_has_visited<span class="token operator">:</span>addi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span>j for_i2_beginfor_i2_end<span class="token operator">:</span>li $v0<span class="token punctuation">,</span><span class="token number">0</span>jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码参考了DFS深度搜索算法<a href="https://blog.csdn.net/u011579908/article/details/68943534?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163292490216780255292122%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163292490216780255292122&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-68943534.first_rank_v2_pc_rank_v29&utm_term=%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9C%89%E6%97%A0%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF&spm=1018.2226.3001.4187">DFS寻找哈密顿回路</a></p><h3 id="快排算法练习"><a href="#快排算法练习" class="headerlink" title="快排算法练习"></a>快排算法练习</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><p><img src="https://note.youdao.com/yws/api/personal/file/B41D197BDF314F62959468D4D02A9FDC?method=download&shareKey=3b5809c8ebc38fd00e14bb0990342c96" alt="a"></p><h4 id="Mips语言"><a href="#Mips语言" class="headerlink" title="Mips语言"></a>Mips语言</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">.</span>data array<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">400</span> #arraystack<span class="token operator">:</span><span class="token punctuation">.</span>space <span class="token number">800</span>str_tips1<span class="token operator">:</span><span class="token punctuation">.</span>asciiz <span class="token string">"how many numbers do you want to qsort:"</span>str_tips2<span class="token operator">:</span><span class="token punctuation">.</span>asciiz <span class="token string">"please enter the numbers: "</span>str_tips3<span class="token operator">:</span><span class="token punctuation">.</span>asciiz <span class="token string">"these are sorted numbers:"</span>str_space<span class="token operator">:</span><span class="token punctuation">.</span>asciiz <span class="token string">" "</span><span class="token punctuation">.</span>macro <span class="token function">getindex</span><span class="token punctuation">(</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>i<span class="token punctuation">)</span> li <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token number">0</span>add <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>isll <span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token operator">%</span>ans<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span>end_macro<span class="token punctuation">.</span>macro <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">%</span>i<span class="token punctuation">,</span><span class="token operator">%</span>j<span class="token punctuation">)</span><span class="token function">getindex</span><span class="token punctuation">(</span>$s3<span class="token punctuation">,</span><span class="token operator">%</span>i<span class="token punctuation">)</span><span class="token function">getindex</span><span class="token punctuation">(</span>$s4<span class="token punctuation">,</span><span class="token operator">%</span>j<span class="token punctuation">)</span>lw $s5<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$s3<span class="token punctuation">)</span>lw $s6<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$s4<span class="token punctuation">)</span>sw $s5<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$s4<span class="token punctuation">)</span>sw $s6<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$s3<span class="token punctuation">)</span><span class="token punctuation">.</span>end_macro<span class="token punctuation">.</span>textmain<span class="token operator">:</span>la $sp<span class="token punctuation">,</span>stackaddiu $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">800</span>la $a0<span class="token punctuation">,</span>str_tips1li $v0<span class="token punctuation">,</span><span class="token number">4</span>syscallli $v0<span class="token punctuation">,</span><span class="token number">5</span>syscallmove $s0<span class="token punctuation">,</span>$v0  #$s0 is the amount of numbersla $a0<span class="token punctuation">,</span>str_tips2li $v0<span class="token punctuation">,</span><span class="token number">4</span>syscallread_numbers<span class="token operator">:</span>li $t0<span class="token punctuation">,</span><span class="token number">0</span>for_i1_begin<span class="token operator">:</span>beq $t0<span class="token punctuation">,</span>$s0<span class="token punctuation">,</span>for_i1_endli $v0<span class="token punctuation">,</span><span class="token number">5</span>syscall<span class="token function">getindex</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>sw $v0<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span>addi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span>j for_i1_beginfor_i1_end<span class="token operator">:</span>#a0 is left <span class="token punctuation">,</span>a1 is rightli $a0<span class="token punctuation">,</span><span class="token number">0</span>subi $a1<span class="token punctuation">,</span>$s0<span class="token punctuation">,</span><span class="token number">1</span>jal qsort #qsort has no <span class="token keyword">return</span> print<span class="token operator">:</span>li $t0<span class="token punctuation">,</span><span class="token number">0</span>for_i2_begin<span class="token operator">:</span>beq $t0<span class="token punctuation">,</span>$s0<span class="token punctuation">,</span>for_i2_end<span class="token function">getindex</span><span class="token punctuation">(</span>$t1<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>lw $t2<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$t1<span class="token punctuation">)</span>move $a0<span class="token punctuation">,</span>$t2li $v0<span class="token punctuation">,</span><span class="token number">1</span>syscallla $a0<span class="token punctuation">,</span>str_spaceli $v0<span class="token punctuation">,</span><span class="token number">4</span>syscalladdi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span>j for_i2_beginfor_i2_end<span class="token operator">:</span>li $v0<span class="token punctuation">,</span><span class="token number">10</span>syscallqsort<span class="token operator">:</span>    move $t6<span class="token punctuation">,</span>$a0 #left    move $t7<span class="token punctuation">,</span>$a1 #rightblt $t6<span class="token punctuation">,</span>$t7<span class="token punctuation">,</span>else_ifjr $raelse_if<span class="token operator">:</span>#<span class="token keyword">if</span> left <span class="token operator">&lt;</span> rightmove $t0<span class="token punctuation">,</span>$t6 #t0 is iaddi $t1<span class="token punctuation">,</span>$t7<span class="token punctuation">,</span><span class="token number">1</span> #t1 is j <span class="token function">getindex</span><span class="token punctuation">(</span>$t2<span class="token punctuation">,</span>$t6<span class="token punctuation">)</span>lw $t2<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$t2<span class="token punctuation">)</span> #t2 is pivotwhile1_begin<span class="token operator">:</span>while2_begin<span class="token operator">:</span>addi $t0<span class="token punctuation">,</span>$t0<span class="token punctuation">,</span><span class="token number">1</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t3<span class="token punctuation">,</span>$t0<span class="token punctuation">)</span>lw $t3<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$t3<span class="token punctuation">)</span> #t3 is k<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span>bge $t3<span class="token punctuation">,</span>$t2<span class="token punctuation">,</span>while2_endbeq $t0<span class="token punctuation">,</span>$t7<span class="token punctuation">,</span>while2_endj while2_beginwhile2_end<span class="token operator">:</span>while3_begin<span class="token operator">:</span>subi $t1<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span><span class="token number">1</span><span class="token function">getindex</span><span class="token punctuation">(</span>$t3<span class="token punctuation">,</span>$t1<span class="token punctuation">)</span>lw $t3<span class="token punctuation">,</span><span class="token function">array</span><span class="token punctuation">(</span>$t3<span class="token punctuation">)</span> #t3 is k<span class="token punctuation">[</span><span class="token operator">--</span>j<span class="token punctuation">]</span>ble $t3<span class="token punctuation">,</span>$t2<span class="token punctuation">,</span>while3_endbeq $t1<span class="token punctuation">,</span>$t6<span class="token punctuation">,</span>while3_endj while3_beginwhile3_end<span class="token operator">:</span><span class="token keyword">if</span><span class="token operator">:</span>bge $t0<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span><span class="token keyword">else</span><span class="token function">swap</span><span class="token punctuation">(</span>$t0<span class="token punctuation">,</span>$t1<span class="token punctuation">)</span>j while1_begin<span class="token keyword">else</span><span class="token operator">:</span>j while1_endwhile1_end<span class="token operator">:</span><span class="token function">swap</span><span class="token punctuation">(</span>$t6<span class="token punctuation">,</span>$t1<span class="token punctuation">)</span>########recursion1sw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store rasubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span> sw $t6<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store leftsubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store right subi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t1<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store jsubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>move $a0<span class="token punctuation">,</span>$t6subi $t5<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span><span class="token number">1</span>move $a1<span class="token punctuation">,</span>$t5jal qsortaddi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t1<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t6<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>########recursion2sw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store rasubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span> sw $t6<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store leftsubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store right subi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>sw $t1<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>#store jsubi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>addi $t5<span class="token punctuation">,</span>$t1<span class="token punctuation">,</span><span class="token number">1</span>move $a0<span class="token punctuation">,</span>$t5move $a1<span class="token punctuation">,</span>$t7jal qsortaddi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t1<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t7<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $t6<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>addi $sp<span class="token punctuation">,</span>$sp<span class="token punctuation">,</span><span class="token number">4</span>lw $ra<span class="token punctuation">,</span><span class="token function">0</span><span class="token punctuation">(</span>$sp<span class="token punctuation">)</span>jr $ra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>笔者在编写swap函数时<strong>出现了错误</strong>，我原来在<code>swap</code>中使用的是<code>$t0</code>,<code>$t1</code>几个寄存器，导致在<code>swap</code>时修改了正在程序中运行的<code>$t0</code>,<code>$t1</code>这几个寄存器的值，导致了重大错误。<strong>其实我在程序中不应该把i，j,pivot这些变量放在临时寄存器中，而应放在<code>$s</code>类型寄存器中</strong>，这样临时变量就可以在swap中使用了，这样的程序会更加规范，<del>笔者太菜了。。。</del>,寄存器千万不能乱用啊！！！！，<font color = red> <em>程序中重要的的一些量要保存在<code>$s</code>中，不要不管啥量都用 <code>$t</code>!</em> </font></p><h3 id="其他小知识点"><a href="#其他小知识点" class="headerlink" title="其他小知识点"></a>其他小知识点</h3><ol><li>乘法运算<code>hi</code>保存高32位，<code>lo</code>保存低32位。除法运算<code>hi</code>保存余数，<code>lo</code>保存商</li><li>load指令,<code>lw</code>，<code>lb</code>分别为从存储器加载一个字，从存储器加载一个字节。store指令,<code>sw</code>，<code>sb</code>，<code>sh</code>分别为在存储器内存储一个字，一个字节，半个字（两个字节）</li><li><code>.space</code>申请空间时尽量申请4的倍数，防止用指令sw，lw时出错</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成Mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown学习笔记</title>
      <link href="/2022/05/09/markdown-xue-xi-bi-ji/"/>
      <url>/2022/05/09/markdown-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><h2 id="date-2021-10-5"><a href="#date-2021-10-5" class="headerlink" title="(date:2021.10.5)"></a>(date:2021.10.5)</h2><hr><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>斜粗体文本</strong></em></p><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>使用三个以上的减号可以建立分割线</p><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>BAIDU</del></p><hr><h3 id="创建脚注"><a href="#创建脚注" class="headerlink" title="创建脚注"></a>创建脚注</h3><p>创建一个脚注[^RUNOOB]</p><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>文字前加一个减号和空格</p><ul><li>第一</li><li>第二</li><li>第三</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>文字前加数字和点.和空格</p><ol><li>第一<ul><li>列表嵌套，前面加4个空格</li></ul></li><li>第二</li><li>第三</li></ol><hr><h3 id="创建区块"><a href="#创建区块" class="headerlink" title="创建区块"></a>创建区块</h3><p>段落开头用&gt;加一个空格</p><blockquote><p>区块引用<br>I have dream</p><p>列表中也可以使用区块</p></blockquote><ul><li><p>第一项</p><blockquote><p>一个区块<br>I have a dream</p></blockquote></li><li><p>第二项</p></li></ul><hr><h3 id="写入代码"><a href="#写入代码" class="headerlink" title="写入代码"></a>写入代码</h3><p>写 <em><strong>函数名称</strong></em> 用反引号将其包起来 <code>printf()</code>函数</p><p>写 <em><strong>函数块</strong></em> 用三个反引号将其包起来并指定一种语言</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while(all_items[c].a!&#x3D;0)    &#123;        int a0&#x3D;all_items[c].a,p0&#x3D;all_items[c].p;        for(t&#x3D;c+1;all_items[t].p&#x3D;&#x3D;all_items[c].p;t++)        &#123;            a0+&#x3D;all_items[t].a;        &#125;        printf(&quot;%d %d &quot;,a0,p0);        c&#x3D;t;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><p>这是一个<strong>链接</strong><a href="https://shl518.github.io/">LeiYu’s Blog</a><br>链接用[链接名称] (链接地址)</p><hr><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>！[属性文本] （属性文本）</p><p>这是一张图片<img src="https://note.youdao.com/yws/api/personal/file/0472D20B23C24B4B8B57A5D749427AFF?method=download&shareKey=fd611a54037b17b03bba51b4704d00ae" alt="My photo"></p><hr><h3 id="制作表格"><a href="#制作表格" class="headerlink" title="制作表格"></a>制作表格</h3><p>使用|来分割左右，使用-分割上下,使用：来设置对齐方式</p><table><thead><tr><th align="left">表头</th><th align="right">表头</th><th align="center">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><p>[^RUNOOB]: I have a dream.</p>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logism器件</title>
      <link href="/2022/05/09/logism-qi-jian/"/>
      <url>/2022/05/09/logism-qi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="常用器件-参考文献"><a href="#常用器件-参考文献" class="headerlink" title="常用器件 [^参考文献]"></a>常用器件 [^参考文献]</h2><p><code>Spliter,Pin,Probe,Tunnel,MUX</code>均比较简单，不做叙述。</p><h3 id="Wire"><a href="#Wire" class="headerlink" title="Wire"></a>Wire</h3><ul><li><code>Bit Extender</code><br><img src="https://note.youdao.com/yws/api/personal/file/80D166054146401BB764F043AC9F30DB?method=download&shareKey=40688ad8de5a9265ecff929eadf1c8de" alt="a"></li></ul><h3 id="Gate"><a href="#Gate" class="headerlink" title="Gate"></a>Gate</h3><ul><li>可以在<code>Negate</code>中选择在哪一个输入前加一个非门，可以省去手动加<code>非门</code>的过程。</li><li><code>Oddparity</code>与<code>Evenparity</code>奇偶校验门，校验输入中1的个数。</li></ul><h3 id="Plexers"><a href="#Plexers" class="headerlink" title="Plexers"></a>Plexers</h3><ul><li><code>MUX</code>,<code>DMX</code>一个从<strong>多个输入</strong>里选一个，一个从<strong>多个输出</strong>里选一个。</li><li><code>Decoder</code> 是译码器，把select信号编译为独热码，例如：2位的select信号可以翻译成四种独热码，0000,0100，0010，,0001</li><li><code>Priority Encoder</code>,判断有无输入是1，输出是1的最高位输入是哪一个(从上到下输入端依此从0开始编号)<br><img src="https://note.youdao.com/yws/api/personal/file/F3FC88B72EB343AD8E7124445C04A171?method=download&shareKey=113072c76b93582bcea5d9189e1484cb" alt="a"></li><li><code>Bit selecter</code>顾名思义将输入的某一位输出</li></ul><h3 id="Arithmatic"><a href="#Arithmatic" class="headerlink" title="Arithmatic"></a>Arithmatic</h3><p>前几个都是加减乘除，去负数，比较器，不做介绍。</p><ul><li><code>shifter</code>位移器,关键的是位移，有逻辑位移，算数位移，循环位移，其具体含义如下：<br><img src="https://note.youdao.com/yws/api/personal/file/1BB34F2E841B45DB96592928253A7671?method=download&shareKey=d5d494b791056a5ea92f305d17fd6ce5" alt="a"></li><li><code>Bit Adder</code> 数输入中1的个数，<code>input=10001010，output=3</code></li><li><code>Bit Finder</code>找最低位的0或1，或找最高位的0或1，查找时可能会需要，不难理解，其含义如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/30C68C2FDE834574A938196A613B7148?method=download&shareKey=37947dc9e97be5e694a3403b51325855" alt="a"></li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>前几个不常用，主要用的还是<code>register</code>，<code>counter</code>,<code>RAM</code>和<code>ROM</code>.</p><ul><li><p>Register 注意这里默认的reset是异步复位，并不管是不是上升沿，只要reset&#x3D;1就复位，在实际的电路中，reset为1时寄存器和counter都要清零，以便再一次初始化（参照常用电路—寄存器的初始化）。如果要异步清零，我们<strong>把reset信号同时接在counter和寄存器上</strong>，寄存器<strong>立刻异步复位</strong>。要构成同步复位，我们<strong>只将reset接在counter上</strong>，在上升沿时，寄存器<strong>将实现同步复位</strong>。</p></li><li><p><code>RAM</code>:<code>RAM</code> 是一个可读可写的存储器，在我们的实验中，我们采用的是读与写相互分离的类型，所以在选择 RAM 时，请将数据接口选择为<code>Separate load and store port</code>,地址从上到下，从左往右依次递增，储存时以十六进制存储。</p></li><li><p><code>ROM</code>：​ROM 是一个只读类型的存储器，顾名思义，在使用过程中只能对其进行读取操作，而不能进行写操作，所以 ROM 在创建时，必须一次性将所有的信息全部导入，之后不可再进行更改。</p></li><li><p>对<code>RAM</code>，<code>ROM</code>存储方式分为</p><ul><li>手动存储</li><li>txt文件存储，文件第一行写v2.0 raw，接下来每一行为一个十六进制数据</li></ul><pre class="line-numbers language-none"><code class="language-none">v2.0 raw10*01  &#x2F;&#x2F;这里相当于写十个0x01ffac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="有限状态机-FSM"><a href="#有限状态机-FSM" class="headerlink" title="有限状态机(FSM)"></a>有限状态机(FSM)</h2><h3 id="Mealy"><a href="#Mealy" class="headerlink" title="Mealy"></a>Mealy</h3><p>输出与输入和当前状态都有关<br><img src="https://note.youdao.com/yws/api/personal/file/A80337FDFC0D463985FB1C88F050A463?method=download&shareKey=7405ef00856ef72dbdf1d9b98eefd117" alt="a"><br>上图中三个主要部件分别问<strong>状态转移</strong>（运用组合逻辑计算下一个状态），<strong>状态存储</strong>（存储下一个状态，输出当前状态），<strong>状态输出</strong>（运用组合逻辑计算输出）。</p><h3 id="Moore"><a href="#Moore" class="headerlink" title="Moore"></a>Moore</h3><p>输出至于当前状态有关，只要把上图中input连向状态输出的线删去即可。<strong>Moore 和 Mealy 的区别在于, Moore 需要等待状态转移完成后才输出结果 (因此会晚一个周期), 而 Mealy 在输入的时候可以直接响应.</strong></p><hr><h2 id="常用电路—寄存器的初始化"><a href="#常用电路—寄存器的初始化" class="headerlink" title="常用电路—寄存器的初始化"></a>常用电路—寄存器的初始化</h2><p><strong>实现寄存器的initialize</strong>，我们需要搭配使用计数,器<code>Counter</code>与复用器<code>MUX</code>,我们设置寄存器达到最大值时<code>Stay at value</code>保持在最大值，<code>Max Value</code>设置为<code>0x1</code>,复用器设置为<code>select=0</code>时选择初始化值，<code>select=1</code>时选择输入值。这样我们就可以在最开始的一个时钟周期内将寄存器初始化。<br>如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/7D798C40039A4654B54FBC623781C307?method=download&shareKey=6d164014a8e6d5a0b17a705e7e5e2de3" alt="a"><br>该图片中红色部分即为初始化的电路，在时钟第一个周期时，<code>counter=0</code>把寄存器初始化为1,之后<code>counter</code>保持在1，寄存器开始正常的进行输入。</p><h3 id="附：不同颜色线的含义"><a href="#附：不同颜色线的含义" class="headerlink" title="附：不同颜色线的含义"></a>附：不同颜色线的含义</h3><p><img src="https://note.youdao.com/yws/api/personal/file/9DE608A8E9B34906A4EB1FA7BD7BF7DE?method=download&shareKey=293fb4543b622941b8b6e16577d1367d" alt="a"></p><p>[^参考文献]: <a href="http://www.cburch.com/logisim/docs/2.7/en/html/libs/index.html">Library Reference</a><strong>多看英文的官方文档！</strong></p><hr><h3 id="一个Logisim组合电路小练习（可以自己试一下）"><a href="#一个Logisim组合电路小练习（可以自己试一下）" class="headerlink" title="一个Logisim组合电路小练习（可以自己试一下）"></a>一个Logisim组合电路小练习（可以自己试一下）</h3><p>题目描述</p><ul><li><p>输入一个 32 位的串, 由前置 0 + 串 10101 + 需要处理的串 u 三部分拼接而成 (串u的长度小于等于27)</p></li><li><p>若串的长度小于 27 位, 则在后面补 1000… 直至达到 27 位</p></li><li><p>结果为补全后的串 u’ 加上串 u 的长度<br><img src="https://note.youdao.com/yws/api/personal/file/8E23405E343D4327A423FECBC31A518C?method=download&shareKey=a400371a419a052a9efe35d69ded827f" alt="a"></p></li></ul><h3 id="logisim易错点汇总"><a href="#logisim易错点汇总" class="headerlink" title="logisim易错点汇总"></a>logisim易错点汇总</h3><ol><li>comparator比较器是比较补码，比如1111和0111比较不是15和7比较，而是-1和7比较，所以可以位拓展一下，就可以正常比较了</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成Logism </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Letter</title>
      <link href="/2022/05/09/letter/"/>
      <url>/2022/05/09/letter/</url>
      
        <content type="html"><![CDATA[<h4 id="凡事只要不是太着急，再等几天，让子弹飞一会，不要着急下决定"><a href="#凡事只要不是太着急，再等几天，让子弹飞一会，不要着急下决定" class="headerlink" title="凡事只要不是太着急，再等几天，让子弹飞一会，不要着急下决定"></a>凡事只要不是太着急，再等几天，让子弹飞一会，不要着急下决定</h4><p><img src="https://note.youdao.com/yws/api/personal/file/A7D0085872074D04B0D8575216B96820?method=download&shareKey=1898d4f1b75edbb7671ff2e005e4b687" alt="a"></p><p>今日读张朝阳言论有感，中国社会当今经济下行趋势不可避免，好好保证身体健康，等大浪过去再有所作为亦不失为一种选择，但愿中国能快点挺过这一波大风大浪，希望历史的尘埃不要恰巧就落在00后这一代人头上，希望我没有那么倒霉吧。——-2022.5.10.21:47</p><p>谁让你读了这么多的书，又知道了双水村以外还有个大世界。。。。。。如果从小你就在这个天地里日出而作，日落而息，那你现在就会和众乡亲抱同一理想，经过几年的辛劳，会成为一名出色的庄稼人，不幸的是，你知道的太多了，思考的太多了，因此才有了这种不能为周围人所理解的苦恼。《平凡的世界》 2022.5.13.18:30</p><p>之后做项目一定找好团队，垃圾队友害人不浅。——2022.5.24.22:40</p>]]></content>
      
      
      
        <tags>
            
            <tag> Private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dreams</title>
      <link href="/2022/05/09/dreams/"/>
      <url>/2022/05/09/dreams/</url>
      
        <content type="html"><![CDATA[<h2 id="The-starry-sky-of-Corse（《Cloud-Atlas-End-Title》，《Stop-Glorifying-Busy》）"><a href="#The-starry-sky-of-Corse（《Cloud-Atlas-End-Title》，《Stop-Glorifying-Busy》）" class="headerlink" title="The starry sky of Corse（《Cloud Atlas End Title》，《Stop Glorifying Busy》）"></a>The starry sky of Corse（《Cloud Atlas End Title》，《Stop Glorifying Busy》）</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180716%2F198ad934c07346b3a530bf25725e37a9.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1636204274&t=cc4f1b23f9c51cd8d4da7e66c01758d8" alt="a"><br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic.vjshi.com%2F2018-12-12%2F9b646dec3e6acf9b6ead1e139f87d65c%2F00004.jpg%3Fx-oss-process%3Dstyle%2Fwatermark&refer=http%3A%2F%2Fpic.vjshi.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1636204376&t=50d282066cdb9e83d043d712a7df5376" alt="b"></p><h3 id="送给徐淑琦小朋友的一幅画："><a href="#送给徐淑琦小朋友的一幅画：" class="headerlink" title="送给徐淑琦小朋友的一幅画："></a>送给<strong>徐淑琦</strong>小朋友的一幅画：</h3><h4 id="这是我最喜欢的一幅油画，来自于法国著名画家莫奈，在这里把它送给你，希望你一定可以实现你的美术梦想！加油呀！"><a href="#这是我最喜欢的一幅油画，来自于法国著名画家莫奈，在这里把它送给你，希望你一定可以实现你的美术梦想！加油呀！" class="headerlink" title="这是我最喜欢的一幅油画，来自于法国著名画家莫奈，在这里把它送给你，希望你一定可以实现你的美术梦想！加油呀！"></a>这是我最喜欢的一幅油画，来自于法国著名画家<strong>莫奈</strong>，在这里把它送给你，希望你一定可以实现你的美术梦想！加油呀！</h4><p><img src="https://note.youdao.com/yws/api/personal/file/B1F48E0E646E4641B7F565AE389A7182?method=download&shareKey=f167414dcde37889fda851e94e42e64c" alt="c"><br>徐淑琦</p>]]></content>
      
      
      
        <tags>
            
            <tag> Private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C Plus</title>
      <link href="/2022/05/09/cplus/"/>
      <url>/2022/05/09/cplus/</url>
      
        <content type="html"><![CDATA[<h2 id="北航C-复习"><a href="#北航C-复习" class="headerlink" title="北航C++复习"></a>北航C++复习</h2><h4 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std&#x2F;&#x2F;tip:封装继承多态(行为关系)--size control#pragma pack(1)压缩为17字节struct node&#123;    int a:1; &#x2F;&#x2F;a occupy 1 B ,bitwise struct应用于与硬件通信    int x;    int y;    double d;    char c; &#x2F;&#x2F;all 32 byte ,以最大字节数分配4*8&#x3D;32&#125;;&#x2F;&#x2F;tip OS -&gt; API -&gt;application background(database dll multiple-thread) -&gt;GUI&#x2F;&#x2F;tip c plus 封装&#x2F;&#x2F;tip 访问控制 public private class Student&#123;&#x2F;&#x2F;对象占的空间就是其属性所占空间 sizeof(Student)&#x3D;8Bprivate:&#x2F;&#x2F;不写default private    int age;    char* name;    int *p &#x3D; new int();public:    void initialize(int aage,char* aname);&#x2F;&#x2F;method  declare inside    &#x2F;&#x2F;tip constructor 构造器，可以写多个    Student(int aage,char* aaname);    &#x2F;&#x2F;tip default constructor    Student();    &#x2F;&#x2F;tip stack and heal     &#x2F;&#x2F;tip    ~Student();&#x2F;&#x2F;destructor 析构函数 对象消亡时自动调用，只能有一个，不能写多个重载的析构函数，保证内存的正常分配&#125;&#x2F;&#x2F;method define outsideStudent::~Student()&#123;    delete p;&#125;Student::Student()&#123;    &#125;void Student::initialize(int age,char* aname )&#123;    age &#x3D; aage;&#x2F;&#x2F;hiden this pointer &#x3D;&#x3D;&#x3D; this-&gt;age &#x3D; aage;  this is address of s,point to s    name &#x3D; aname;&#125;Student::Student(int age,char* aname )&#123;    age &#x3D; aage;&#x2F;&#x2F;hiden this pointer &#x3D;&#x3D;&#x3D; this-&gt;age &#x3D; aage;  this is address of s,point to s    name &#x3D; aname;&#125;int main()&#123;    struct Student s(10,&quot;a&quot;);&#x2F;&#x2F;use constructor，强制初始化    &#x2F;&#x2F;or Student* s &#x3D; new Student(10,&#39;a&#39;);     &#x2F;&#x2F;Student s2(); 这种写法是错的    &#x2F;&#x2F;Student *s2 &#x3D; new Student();  right    &#x2F;&#x2F;s.initialize(20,&quot;aa&quot;);    &#x2F;&#x2F;int i &#x3D;4 &#x3D;&#x3D;&#x3D; int i(4);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>hm: 自学写udp socked</li><li>hm:属性什么时候用值，什么时候用指针</li><li>hm:构造析构例子</li></ul><h4 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace stdvoid fun(int i) &#123;    i++;&#125;void fun2(int&amp; i) &#123;    i++;&#125;class Test &#123;    int i;    int *j;public:    Test(int ai,int aj);    Test(const Test&amp; t);&#125;class Test &#123;    int i;    int *j;    Test(const Test&amp; t);&#x2F;&#x2F;tip5 将拷贝构造私有化，所有拷贝构造的行为被编译器拦截，必须进行public:    Test(int ai,int aj);    &#125;Test::Test(int ai,int aj)&#123;    i&#x3D;ai;    this-&gt;j &#x3D; aj;&#125;Test(const Test&amp; t) &#123;    this-&gt;i &#x3D; t.i;    &#x2F;&#x2F;this-&gt;j &#x3D; t.j;&#x2F;&#x2F;浅拷贝    this-&gt;j &#x3D; new int(*t.j)&#x2F;&#x2F;深拷贝，深拷贝        &#125;void fun3(Test t)&#123;    &#125;int main() &#123;    &#x2F;&#x2F;tip1:引用    int a &#x3D; 20;    int &amp;r &#x3D; a;&#x2F;&#x2F;引用必须初始化，是一个安全的指针，对于引用操作等价于对啊的操作    r++;&#x2F;&#x2F;&#x3D;&#x3D; a++    fun(a);&#x2F;&#x2F;a &#x3D; 20,not changed C++编程思想    fun2(a);&#x2F;&#x2F;a &#x3D; 21 引用，借值之名，行指针之实    &#x2F;&#x2F;引用不可修改    int b &#x3D; 30;    r &#x3D; b;&#x2F;&#x2F;wrong ,can not be changed &#x3D;&#x3D;&#x3D; 20&#x3D;&#x3D;30    &#x2F;&#x2F;tip3    Test t1(1,2);    Test t2(t1);&#x2F;&#x2F;深拷贝logic copy和浅拷贝 bitwise copy.默认浅拷贝    fun3(t1);&#x2F;&#x2F;只要传值就会发生拷贝，传参是把值复制一份，即拷贝    &#x2F;&#x2F;tip4 自定义数据类型不要传值，传指针或者引用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="tip2-内存分配"><a href="#tip2-内存分配" class="headerlink" title="tip2:内存分配"></a>tip2:内存分配</h5><p>代码区（常量等），全局变量区（在main函数运行之前全部清零），runtime memory (stack and heap)</p><ul><li>stack 局部变量，函数局部变量</li><li>heap 存储malloc动态内存分配，malloc常用于<ul><li>人为控制生命周期</li><li>不确定变量有多少个，例如链表的构造</li></ul></li></ul><h3 id="3-21"><a href="#3-21" class="headerlink" title="3.21"></a>3.21</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#include &lt;iostream&gt;using namespace std&#x2F;&#x2F;tip1 static 1.将变量声明为此文件全局？永久保存 2.将函数声明为此文件可见 3.实现类之间的数据通信4.实现函数属于类&#x2F;&#x2F;区别 static首次使用时构造,全局变量main函数之前构造，两者都在main结束后析构extern int global_i;&#x2F;&#x2F;声明此量不在本文件中extern void fun1();&#x2F;&#x2F;函数默认其他文件也可见，可以不写extern，但变量外连接必须写static void fun2() &#123;&#x2F;&#x2F;该函数只在本文件内使用    &#125;class Static&#123;    static int i; &#x2F;&#x2F;3.实现类之间的数据通信    int j;public:    &#x2F;&#x2F;3Static(int ai,int aj);    Static(int aj);    static void fun4();&#x2F;&#x2F;4此函数属于类，不属于对象，可以通过类直接调用  Static::fun4();&#125;int Static::i &#x3D; 100;&#x2F;&#x2F;3类内部的静态变量外部一次初始化Static::fun4()&#123;    i++;&#x2F;&#x2F;4 静态类内函数只能操作静态类内变量，因为函数可以通过类直接调用，不能定位非静态j    &#x2F;&#x2F;j++;&#125;Static::Static(int aj) &#123;    &#x2F;&#x2F;3i &#x3D; ai;&#x2F;&#x2F;wrong static不能重复初始化    j &#x3D; aj;&#125;void fun()&#123;    const static i &#x3D; 0;     i++;    cout &lt;&lt; i&lt;&lt; endl;&#125;int main() &#123;    Static::fun4();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">#file2int global_i &#x3D; 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>static loacl var</p></li><li><p>static fun</p></li><li><p>static datamember</p></li><li><p>static funmember</p></li></ul><h5 id="tip2-设计模式"><a href="#tip2-设计模式" class="headerlink" title="tip2:设计模式"></a>tip2:设计模式</h5><p><strong>单件模式（实现一个类全局只能存在一个对象）</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">#include &lt;iostream&gt;using namespace stdClass Single &#123;    static Single* self;Single();&#x2F;&#x2F;构造函数私有化，不能构造    public:    static Singlr* get_instance();&#125;Single* Single::self &#x3D; NULL;Single* Single:: get_instance()&#123;    if(self &#x3D;&#x3D; NULL) &#123;        self &#x3D; new Single();    &#125;    return self;&#125;int main() &#123;    Single * s &#x3D; Single::get_instance();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="hm"><a href="#hm" class="headerlink" title="hm"></a>hm</h5><p>&#x2F;&#x2F;SQLlite 实现借书还书系统</p><p>&#x2F;&#x2F;ORMapping</p><h5 id="tips3-const"><a href="#tips3-const" class="headerlink" title="tips3:const"></a>tips3:const</h5><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">#include &lt;iostream&gt;using namespace std&#x2F;&#x2F;1 const parametervoid fun(const int* a) &#123;    (*a) &#x3D; 10;&#x2F;&#x2F;1 error 不能修改常量&#125;&#x2F;&#x2F;2 const return valueclass Const&#123;    const int i;&#x2F;&#x2F;定义类内常量    enum&#x2F;&#x2F;定义类内常量    &#123;        tcp,udp    &#125;;    public:    const Test* fun2(); &#x2F;&#x2F;3返回值是常量    void fun() const;    &#125;Test* TEst::fun2()&#123;    &#125;void Const::fun() const&#123;    &#x2F;&#x2F;此函数内只读不可写&#125;int fun3()&#123;    return 1;&#125;class Account&#123;    public:    Account&amp; operater + (int money);    Account&amp; operater ++();    Account operater ++(int);&#x2F;&#x2F;强加占位符以区分，必须写int占位&#125;&#x2F;&#x2F;++aAccount&amp; Account::operater ++()&#123;    this-&gt;balance ++;    return *this;&#125;&#x2F;&#x2F;a++Account Account::operater ++(int)&#123;    Account a &#x3D; *this;    this-&gt;balance++;    return a;&#125;Account&amp; Account::operater+(int money) &#123;    this.balance +&#x3D;money;    return *this;&#125;int main() &#123;    Const c;    c.fun2()-&gt;fun2();&#x2F;&#x2F;error 返回值是const不允许做左值、    &#x2F;&#x2F;函数返回BUILD_IN常量，自动为常量    fun3()++;&#x2F;&#x2F;error    &#x2F;&#x2F;返回自定义，不为常量,需要自己定义    const Const c;&#x2F;&#x2F;4const 对象    c.fun();&#x2F;&#x2F;error 常量对象不能直接调用函数，加上const就可以调用        &#x2F;&#x2F;tips4 new and delete    Test* p &#x3D; new Test();    &#x2F;&#x2F;new &#x3D;  &#x3D;malloc + constructor    &#x2F;&#x2F;delete &#x3D; destructor + free            &#x2F;&#x2F;tip5 运算符重载    &#x2F;&#x2F;类内部人为定义加减乘除    Account a(10);    a &#x3D; a+100;&#x2F;&#x2F;&#x3D;相当于拷贝，需要返回&amp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h3><p>&#x2F;&#x2F;effective C++</p><p>&#x2F;&#x2F;继承与组合</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace stdclass Computer&#123;    int i;    int price;    char* brand;public:    int get_price();    void maintain();    Computer(int ai);&#x2F;&#x2F;有了这个就没有默认构造&#125;int Computer::get_price()&#123;    return price;&#125;void Computer::maintain()&#123;    cout&lt;&lt;&quot;service&quot;&lt;&lt;endl;&#125;Computer::Computer(int ai)&#123;    i&#x3D;ai;&#125;class Mac : public Computer  &#x2F;&#x2F;tip1继承写法&#123;    int j;    int year;public：    void maintain();    Mac(int aj);&#125;Mac::Mac(int ai,int aj):Computer(ai)&#x2F;&#x2F;写，间隔多个    &#123;    j &#x3D; aj; &#x2F;&#x2F;tip3子类构造调用父类构造&#125;&#x2F;&#x2F;tip4 外壳的构造首先调用内部成员的构造，和上面语法一样&#x2F;&#x2F;tip5 内部成员构造顺序与类内成员声明顺序相符&#x2F;&#x2F;tip6 私有继承，父类的所有东西都继承为私有   class Mac: private Computer  私有继承&#x2F;&#x2F;私有继承削弱了父类（私有继承，只重写父类一个重载）void Mac::maintain()&#123;    if(year &lt;&#x3D; 1)        cout&lt;&lt;&quot;new&quot;&lt;&lt;endl;    else        Computer::maintain();&#x2F;&#x2F;super() C++一个类可以有多个父类        &#125;&#x2F;&#x2F;tip2 父类方法有重载，子类如果需要重写其中一个，必须把其余重载方法也重写，否则其他重载方法不可使用&#x2F;&#x2F;tip7 多重继承int main()&#123;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-11"><a href="#4-11" class="headerlink" title="4.11"></a>4.11</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>tip1：向上类型转换</p></li><li><p>tip2:binding 绑定 将函数的调用绑定对应的过程，之前所学的函数都是前绑定。后绑定（动态的绑定）实现之后才能实现多态，可以通过虚函数实现</p><ul><li>多态的前提是继承</li><li>没有向上类型转换就没有多态</li><li>多态的实现通过一个类和为其创建的虚函数表vtable实现，虚函数会在对象内创建一个虚指针vptr指向虚函数表，大小会增加一个指针的大小4bytes。</li><li>纯虚函数，一个类含有一个纯虚函数，被称为抽象类abstract class，不允许实例化</li></ul></li><li><p>抽象类的两个用途</p><ul><li>规定本类家族的共性行为</li><li>连接本不相关的多个类家族</li></ul></li><li><p>构造没有多态（父类指针可以指向子类，子类指针不能指向父类），析构函数通常需要实现多态，前面加上virtual</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class Pet&#123;public :virtual void speak()&#x3D;0; &#x2F;&#x2F;父类加上virtual 虚函数实现后绑定，父类的虚函数可以定义为纯虚函数&#125;void Needle(Pet&amp; pet)&#123; &#x2F;&#x2F;改成传引用pet.speak();&#x2F;&#x2F;此处是多态&#125;class Dog:public Pet&#123;public:void speak();&#x2F;&#x2F;这里重写&#125;int main()&#123;Dog dog;Needle(dog);&#x2F;&#x2F;向上类型转换&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;STL standard template library&#x2F;&#x2F;vector &#x2F;&#x2F;动态增长的万能容器template &lt;class T&gt;class Stack&#123;    int pool[100];    int top;public:    void push(int i);    int pop();    Stack();&#125;&#x2F;&#x2F;int stack -----&gt; double stack template &lt;class T&gt;class Stack&#123;    T pool[100];    T top;public:    void push(T i);    T pop();    Sta n  ck();&#125;&#x2F;&#x2F;如何支持动态增长，通过拷贝构造，空间不够了找另一个空间拷贝构造class Test &#123;    static int cnt;&#x2F;&#x2F;static本类所有对象共享    public: Test(const Test&amp; t);&#x2F;&#x2F;拷贝构造&#125;&#x2F;&#x2F;tip3 迭代器模式，统一对不同容器的存取int main()&#123;    list&lt;int&gt; v;    list&lt;int&gt;::iterator it &#x3D; v.begin;&#x2F;&#x2F;list 类中的迭代器类    while(it!&#x3D; v.end())&#123;        cout &lt;&lt; *it&lt;&lt;endl;&#x2F;&#x2F;运算符重载        it++;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">void Fun(int m) throw int&#123;    if(m &#x3D; 4)        throw 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C Plus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
