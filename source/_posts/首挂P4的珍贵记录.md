---
title: 首挂P4的珍贵记录
date: 2022-05-09 15:21:54
tags: 计算机组成
---

下次考试的时候需注意：

1. **先把所有的模块都生成在一个prj文件里，这样考试开始时可以快速的将各个mips文件复制进去**
2. 做完第一步后，将文件夹复制3次，分别用来解决三个测试，防止写代码的过程中改来改去
3. **先写一个先写一个MARS，生成txt文件，把wcg文件设置出来方便debug，应该包括：**
4. 修改的过程中先改数据通路，再改控制通路

### Problem1

#### 构造指令

格式：`rlb rt rs imm`

- 解释：将GPR(rs)低imm位全部取反，输出到GPR(rt)内
- 思路：在CU里面加上rlb判断信号，我们在ALU中输入GPR(rs)和imm来实现取反计算，然后输出到rt内部，改变的控制信号主要是：ALUControl,ALUsrc选取imm输入,GRF的A3端要选择rt作为输入端,RegWrite信号也要加一个
- 问题主要出在**位选信号时不能使用变量在括号**里，并且我写了一个for循环，但**for循环的终止条件判断也必须是一个常数**，所以也不可行，最终导致了TLE的发生，**其实位选信号有特殊的写法可以使其包含变量**，但是我在课下看到了这个语法，但没有特别注意也没有掌握，emo了。。。。。第一个题直接放弃了。

### Problem2

#### bnezalc

`bnezalc rs offset`

```
if GRF(rs)!=0
    PC < PC+4+signextend(offset||00)
    GRF(31) < PC+4
else 
    PC < PC+4
```

- 问题这里涉及到寄存器的写信号，跟P3一样，我一开始有没有注意到如果rs = 0，不能让RegWrite信号为1，我直接把RegWrite信号里面加了bnezalc，这样会导致错误
- 终终终于发现bug了！！！！和我课下写的BLEZ发生了冲突（由于代码不规范导致的）

```
原代码：
assign Blez = (RD1 <= 32'd0);
	 
assign Bnezalc = RD1!=0;
assign Blez_MUX = (Blez|Bnezalc)?Pcplusimm:PCplus4;
//我一看，这里bnezalc的NPC不是和Blez一样吗，太好了，可以合并啊！其实是错的。。。。。。。
这里 Blez_MUX会永远为Pcplusimm，因为RD1=0的时候，Blez为1，emo了。。。。

always @( *) begin
    case(Branch)
    3'd0:NPC = PCplus4;
    3'd1:NPC = ALUzero_MUX;
    3'd2:NPC = NPC_j;
    3'd3:NPC = Ra;
    3'd4:NPC = Blez_MUX；
	3'd5:NPC = Blez_MUX；
    
    default NPC=32'd0;
    endcase
```

**这里我们不应该对判断信号贸然的进行合并，例如这些blez，bne，beq等等等因为一个信号判断为真，必然会对其他判断信号产生影响，虽然他们的NPC都是一样的，以后写代码的时候应该注意**

```
更改后代码：
assign Blez = (RD1 <= 32'd0);
	 
assign Bnezalc = RD1!=0;
    
always @( *) begin
    case(Branch)
    3'd0:NPC = PCplus4;
    3'd1:NPC = ALUzero_MUX;
    3'd2:NPC = NPC_j;
    3'd3:NPC = Ra;
    3'd4:NPC = (Blez)?Pcplusimm:PCplus4;
	3'd5:NPC = (Bnezalc)?Pcplusimm:PCplus4;
    default NPC=32'd0;
    endcase
```

### Problem3

#### lwrr

- 格式 `lwrr rt ,offset(base)`
- 含义 

```
    addr=GRF(base)+offset
    从DM[addr]取出值WD（这里跟lw指令一模一样）
    将WD循环右移存入rt
    ！！！（注意这里的循环右移是按照8byte为一个单位右移的）
    byte < addr[1:0]
    WD应该经8byte循环右移为
    {WD[8*byte-1:0],WD[31:8*byte]}（注意这里是伪代码，位选信号不能为非常量，具体实现可以用右移操作实现，或者是直接把所有情况（4种）列出来用MUX输出即可，）
```

- 实现过程：在DM里加入控制信号，如果此时的指令为lwrr，直接在DM中就把进行循环位移处理，然后再进行输出
  **考完才发现理解错题意了，整个一个大无语，我还以为是按1byte为单位循环右移，离谱，不好好看题的结果**
  ##补充
- 循环右移 b位 a = (a >> b)|(a<< (32'd32-b));循环左移一样
- 算数右移b   a = $signed($signed(a) >>> b);注意要套两个$signed


#### 这两天的P4之前过的都很顺利，还以为计组也不是很难吗。结果该来的还是来了，还是代码写的太少，bug写的太少，做计组要笑！！！！！fighting！！下一关流水线。
