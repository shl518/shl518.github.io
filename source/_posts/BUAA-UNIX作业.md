---
title: BUAA_UNIX作业
date: 2022-05-09 15:21:14
tags: UNIX
---

## UNIX课程作业报告

### 1.1 前言

本次作业是一个简易shell，它由C语言编写，是一个为用户提供Linux操作系统的命令行式操作界面。本次作业实现的shell具有以下建议功能。

- 可以运行不带参数的命令，带参数（额外实现）的外部命令
- 只能模拟实现简单的两个内部命令即`history`和`cd`指令
- 支持`I/O`重定向
- 支持管道，可以通过管道连接多个命令
- 退出时输入`exit`即可退出

下面将由顶向下，从顶层架构到实现细节，逐步阐述本次大作业的实现思路。

### 2.1 实现架构

实现架构以流程图的方式给出：

![](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220508224659405.png)

首先程序开始后进行INIT初始化操作，在本次作业中为了区分cd指令，history指令，管道指令，重定向指令定义了四个全局变量作为四个标记，标记当前读入的指令是哪一种类型的指令。INIT初始化操作便是将这四个标记初始化。

接着我们便可以开始fgets读入指令，对读入的指令进行解析，解析的功能是将四个标记置位。解析完毕后便可以执行excute函数执行指令。执行完后会再次循环上述过程，如果中途读入了exit指令便会退出程序。

### 2.2 具体细节

#### 2.2.1 `cmd`结构体：

```C
typedef struct cmd{
	char *argv[10];
	int in_redir_fd;
	int out_redir_fd;
} command;
```

`agrv`是一个数组指针，其中保存着每个命令的参数，`in_redir_fd,out_redir_fd`是文件描述符，分别表示该指令的标准输入，标准输出，用于实现管道和重定向。

#### 2.2.2 cd 命令实现

cd命令实现较为简单，首先在parse解析时，如果解析到该指令为cd指令，则将pwdflag置1，进入excute函数执行指令后，调用字符串分割函数strtok（）得到cd 后面的path参数，接着直接调用chdir改变进程当前工作目录即可。

#### 2.2.3 history命令实现

本次作业实现的history命令可以实现的操作是`history n`显示最近的n条指令。具体的实现方法是通过一个数组记录最近输入的指令，如果检测到当前读入指令为history则会将该数组内的指令全部输出。

#### 2.2.4 管道pipe命令

**流程图：**

![](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220508224854832.png)



**用到的函数：**

| 用到的函数 | 作用                             |
| ---------- | -------------------------------- |
| pipe（）   | 实现管道                         |
| fork（）   | 创建子进程完成管道符号之前的指令 |
| dup2（）   | 实现管道所需要的输出输出重定向   |
| execvp（） | 执行指令                         |
| strtok（） | 分割字符串，识别命令，识别文件名 |

**流程与步骤：**

- **pipe()管道函数的介绍**

int pipe(int fd[2])，该函数创建的管道的两端处于一个进程中间，一个进程在由 pipe()创建管道后，一般再fork一个子进程，然后通过管道实现父子进程间的通信（管道）。管道两端可 分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另 一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。

- 首先使用strtok识别出指令

- 接着使用cmd_argvs函数识别每条指令的参数

- 创建子进程完成其中一条指令

```c#
close(fd[0]);
dup2(fd[1],STDOUT_FILENO);//修改文件描述符，改变命令输出，实现输出重定向
close(fd[1]);
execvp(cmd1.argv[0],cmd1.argv);
```

- 父进程完成另一条指令

```C#
close(pfd[1]);
dup2(pfd[0],STDIN_FILENO);//修改文件描述符，改变命令输入，实现输入重定向
close(pfd[0]);
execvp(cmd2.argv[0],cmd2.argv);
```

- 父进程等待子进程结束后运行下一条命令，这里用到了waitpid（）命令，该命令可以指定等待某一子进程，调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。

#### 2.2.5 输入输出重定向

**用到的函数：**

| 用到的函数 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| strtok()   | 字符串分割函数，用于识别重定向符号链接的两个命令             |
| dup2()     | 用于实现文件重定向，实现将标准输入输出文件描述符指定向我们定义的filename |
| close()    | 关闭文件                                                     |
| open()     | 打开我们要重定向到的文件                                     |
| execvp()   | 执行文件函数，执行UNIX命令                                   |
| fork()     | 创建子进程用于执行命令                                       |

**流程与步骤：**

- strtok,字符串分割函数，用于获取重定向符号所连接的指令，以及指令中的信息（重定向输出的文件名，重定向输入的文件名等）

- 利用cmd_argvs函数获取cmd的参数

- 使用`dup2()`函数实现重定向,具体分以下三类

  - 识别到`>`重定向标志符，`dup2(cmd1.outfd,STDOUT_FILENO);`将标准输出的文件描述符指向我们重定向需要输出的文件。

  ```C#
  if((cmd1.outfd = open(instr,OUTFILE,PERM)) < 0)
  {
  	sys_err("open failed");
  }
  dup2(cmd1.outfd,STDOUT_FILENO);//实现重定向
  close(cmd1.outfd);
  execvp(cmd1.argv[0],cmd1.argv);
  ```

  - 识别到`>>`文件描述符，依旧使用`dup2(cmd1.outfd,STDOUT_FILENO);`将标准输出的文件描述符指向我们重定向需要输出的文件,至于如何实现以append的形式输出，我们只需要使用open函数时

  ```C++
  if ((cmd1.outfd = open(instr,OUTFILE_APPEND,PERM)) < 0) {//实现以APPEND方式打开文件
      ‘//其中OUTFILE_APPEND = O_WRONLY|O_CREAT|O_APPEND
  	sys_err("open failed");
  }
  dup2(cmd1.outfd,STDOUT_FILENO);//实现重定向
  close(cmd1.outfd);
  execvp(cmd1.argv[0],cmd1.argv);
  ```

  - 识别到`<`文件描述符，使用`dup2(cmd1.outfd,STDIN_FILENO);`将标准输入的文件描述符指向我们重定向输入的文件。

  ```C#
  if((cmd1.infd = open(instr,O_RDONLY)) < 0){//只读方式打开文件
  	sys_err("open failed");
  }
  dup2(cmd1.infd,STDIN_FILENO);//重定向输入
  close(cmd1.infd);
  execvp(cmd1.argv[0],cmd1.argv);
  ```

- 子进程运行命令`execvp(cmd, args)`

- 父进程等待子进程结束后运行下一条命令，这里仍然用到了waitpid（）命令，指定等待某一子进程。

### 3.1 我学到的

#### 3.1.1 关于管道

在操作系统和UNIX课程中我已经了解到了管道的相关概念，但是在本次大作业中具体实现管道这个概念时，我一开始无从下手，查阅相关资料后我了解到在Unix已经实现了一个相关函数pipe（），我们可以利用该函数实现管道。

- 首先通过该函数创建管道， int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno。函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。

- 接着采用如下步骤实现父子进程间通信
  - 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道22的读端和写端。
  - 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。
  - 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。

![](https://img-blog.csdn.net/20161223173958916)

#### 3.1.2 关于重定向

在Unix课程学习中我了解到，Unix中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。为了表示和区分已经打开的文件，Unix 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。

| 文件描述符 | 文件名 | 类型         |
| ---------- | ------ | ------------ |
| 0          | stdin  | 标准输入     |
| 1          | stdout | 标准输出     |
| 2          | stderr | 标准错误输出 |

而一个程序运行起来，进程会默认打开三个文件，即标准输出，标准输入与标准错误。知道了这些，实现起重定向就比较简单了，只需要使用open（）函数打开我们需要重定向到的文件，接着使用`dup2()`函数将进程的标准输出或标准输入重定向到该文件即可。

### 3.2  扩展功能与优缺点

#### 3.2.1 命令格式的限制

在本次大作业中我实现的shell指令与重定向、管道符号必须要用空格隔开，比如`cat shell.c > ans.txt`不能写作`cat shell.c>ans.txt`,同时指令的参数不能带引号，比如 `grep -n cmd` 不能写作`grep -n "cmd"`。这些显然都是myshell的功能不足之处，这是因为在本次作业中我使用了strtok字符串分割函数实现指令的分割与识别，这必然不能考虑到全面的情况，未来可能可以使用正则表达式匹配的方式覆盖更加全面的的情况。

#### 3.2.2 实现的连接方式比较简单

本次大作业实现的shell可以运行的指令比较简单，比如管道只能连接两个指令，不能有过多的管道符号与重定向符号例如`cat shell.c | grep -n cmd > ans.txt `等。

### 4.1 课程感悟与思考

在本次作业中学习到了关于UNIX的很多知识，这些知识对我学习操作系统有很大的帮助，包括shell命令，文件管理，存储管理这些知识对我
