---
title: 2022北航UNIX复习资料
date: 2022-05-13 21:03:52
tags: 北航UNIX
---

一：

**1.**UNIX是一类操作系统。狭义理解，UNIX是一个分时操作系统的核心，控制和分配计算机资源（软硬件），协调各应用进程的运行。广义理解，UNIX除了其核心外，还包括一些基本的工具，如编辑器、编译器、文件操作工具、文字处理工具等。更广义地理解，UNIX还包括用户自己开发的各种工具软件。

**2.**1973年，B语言（一种解释语言）高手 Dennis Ritchie发明C语言，并用C语言重写UNIX系统，产生了第一个UNIX的正式版本----SYSTEM V。

**3.**Linux的由来1987年，荷兰阿姆斯特丹Vrije大学Andrew S. Tanenbaum教授（MIT学士，Berkeley博士）为课堂教学编写了Minix系统。1991年，年仅21岁的芬兰赫尔辛基大学的学生Linus Torvalds参考Minix开发了PC版的UNIX，命名为Linux。

**4**.Linux的特点 ①与UNIX兼容，遵从POSIX标准②自由，开源③性能高，安全性强

**5**.什么是操作系统 用户与计算机硬件之间的界面，它是控制、管理计算机系统内各种硬件和软件资源，有效地组织多道程序运行的系统软件(或程序集合)。

 

二：

**1.**基本操作----登录login: you | password: | $ | $ who | $ who am I //or whoami

$ write *username* | $ man *command* | $w<tab><tab>  or wr<tab> | $ logout 或exit

（|表示分隔，指令中没有|）

**2.** 行编辑器ed | $ ed | a | now type in… | what do you want to type? | . | w tmp | q | $

a - 从当前行开始添加  i - 在文件的最后一行之前插入新内容 

o - 把文件输入的最后一行（不论是原来存在的或者插入的）替换成新内容

. - 退出编辑文件模式进入命令行模式（注意：此时并没有退出 ed 编辑器） 

w - 保存文件    q - 真正退出 ed 编辑器

①显示命令 p

p  显示当前行      5  将当前行改为第5行并显示当前行

m，np 显示m到n行

.代表当前行，$代表最后一行

可使用相对行，如 .,.+3p  $-5,$p

②插入、删除、撤销

na 从n行后添加

ni 从n行前插入。i、a都以行首.来结束

m,nd 删除m至n行

u 撤销所做的编辑

③替换

s/old/new/ 把当前行中第一个old替换为new

s/old/new/g 把当前行中每一个old都替换为new

1,$ s/old/new/g 把文件中所有的old都替换为new

④速记符&

1，$s/big/very &/g 把文件中的big都替换为very big

s/and/\&/ 把and改为&

⑤查找/^$/ 空行

/./  非空行

/^/  任意行

/thing/ 包含字符串thing的行

/^thing/ 以thing开始的行

/thing$/  以thing结尾的行

/^thing$/ 内容为thing的行

/thing.$/ 以thing加任意符号结尾的行

/thing\.$/ 以thing.结尾的行

/\/thing\// 包含/thing/的行

/[tT]hing/ 包含thing或Thing的行

/thing[0-9]/

/thing[^0-9]/

/thing[0-9][^0-9]/

/thing1.*thing2/

/^thing1.*thing2$/

全局命令g/…/p 显示所有包含…的行

g/…/d 删除所有包含…的行

g/…/s//rep1/ 对于包含…的行，将其中第一个替换成rep1

g/…/s//rep1/g 把所有的…替换成rep1

g/…/s/pat/rep1/ 对于包含…的行，将其中第一个pat替换成rep1

v/^$/p 打印所有非空行

⑥移动、复制

命令格式：m,nmd m到n行移到d行之后。

m,ntd  m到n行拷贝到d行之后

举例说明一下。 [titan@localhost titan]$ **ed**    // 激活 **ed** 命令 
 a   // 告诉 **ed** 我要编辑新文件 
 My name is Titan.  // 输入第一行内容 
 And I love Perl very much.   // 输入第二行内容 
 .   //返回 **ed** 的命令行状态 
 i   //告诉 **ed** 我要在最后一行之前插入内容 
 I am 24.   // 将“I am 24.”插入“My name is Titan.”和“And I love Perl very much.”之间 
 .   // 返回 **ed** 的命令行状态 
 c   // 告诉 **ed** 我要替换最后一行输入内容 
 I am 24 years old.  // 将“I am 24.”替换成“I am 24 years old.”（注意：这里替换的是最后输的内容） 
 .   // 返回 **ed** 的命令行状态 
 w readme.text   // 将文件命名为“readme.text”并保存（注意：如果是编辑已经存在的文件，只需要敲入 w 即可） 
 q   // 完全退出 **ed** 编辑器 
 这是文件的内容是： [titan@localhost titan]$ cat readme.text <- 
 My name is Titan. 
 I am 24 years old. 
 And I love Perl vrey much. 
 [titan@localhost titan]$ 

\3. 文件列表ls    $ ls        $ ls –l //详细信息列表

$ ls –t //按修改时间排序        $ ls –lt //命令选项可以组合

**4.** 显示文件cat  //针对文本文件    

**5.** 移动及重命名： mv file1 file2  //文件/目录重命名、

mv -i abc /home/cdy把当前目录下的abc 移动到/home目录下面，并重命名为cdy；-i表示相同名字文件覆盖时询问，若-f则表示覆盖时不询问

复制： cp file1 file2  //将文件file1复制成文件file2

cp /tmp/file1  //将目录 /tmp 下的文档 file1复制到现行目录下，档名仍为 file1

删除：rm [文件名]

**6.** wc命令:计数,一或多个文档里的字符、单词、行数 1、字符计数中包含了换行符(\n) 

 2、默认输出三个选项(c，l，w),可单独指定 c 字符 l 行 w 单词 

\#wc test1

7 23 108 test1  //7行 23个单词 108个字符(包括"\n")

\#wc -l test1

7 test1  //-c和-w同理

**7.** $ grep ‘test’ d*
 显示所有以d开头的文件中包含 test的行。
 $ grep ‘test’ aa bb cc
 显示在aa，bb，cc文件中匹配test的行。
 $ grep ‘[a-z]\{5\}’ aa
 显示aa中所有包含每个字符串至少有5个连续小写字符的字符串的行。
 $ grep ‘w\(es\)t.*\1′ aa
 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.*\1′就可以了。

**8.** sort 将文件每一行单词或数字按从a-z顺序输出。-u选项：去除重复词 -r选项：倒序输出 -n选项：按数值排序（这样10才会排在2的后面）

**9.** cmp比较指令cmp prog.o.bak prog.o  //输入

   prog.o.bak  prog.o  differ: char 4, line 1 //表示第一行第四个字符不同

-l cmp -l prog.o.bak prog.o   5 101 141 //表示第五个字节在 prog.o.bak 中是八进制 101，在 prog.o 中是 141

cmp -s prog.c.bak prog.c //文件相同，给出值 0，不同，给出值 1，发生错误，给出值 2。

**10.**diff : diff /usr/xu mine //把目录/usr/xu 中名为mine的文件与当前目录中的mine文件进行比较。

**11.** **文件目录** $ pwd 显示当前路径（目录） $ cd 改变当前工作目录，或返回个人主目录

**.** 和..目录    $ mkdir 创建子目录   $ rmdir 删除子目录

**12.** **基本操作****----shell**

①文件名缩写（模式）$ ls *.c    $ ls a*[1-9].c     $ ls ?.c

②转义字符\   echo *,  echo \*,  ls ‘*’

③I/O重定向 $ ls > tmp    $ ls -l >tmp     $ ls >>tmp    $ wc <tmp

标准输入文件，标准输出文件，标准错误输出文件

④管道   $ who | wc -l  计算所有用户登录的终端数

$ who | grep pts | wc -l 计算用户所使用的仿真终端数量. //管道线上的程序是同时运行的，它们之间存在通信。

⑤进程 $ who; whoami  多个命令同时运行  $ *命令*& 后台运行  

$ ps 显示当前运行的进程       $ kill 终止某个进程

$ nohup command 注销后仍将运行     $ at hh:mm 定时运行某些命令

⑥设置shell内部变量值  $ PS1=C:\\\>      $ PS1='`whoami`:`pwd` >'

$ echo $HOME      $ echo $PATH      $ PATH=$PATH:$HOME/bin

$ d=/home/lls/c        $ cd $d

**三：文件系统**

**1.** 文件类型      ① 目录文件：包含其它文件的文件。  ② 常规文件：文本文件、二进制文件（程序、数据库等）。    ③设备文件：键盘、显示器、打印机、硬盘等。

查看文件类型$ls -l ; 分析文件结构$od -x 

**2.** 绝对路径：从根目录出发到某个文件的搜索路径。如：/home/user1/myc/p1.c

相对路径：从当前目录出发到某个文件的搜索路径。如：myc/p1.c,  ./bin/prog1, ../user2/file1

**3.** 文件权限

$ ls –l a.out

 -rwxr-xr-x 1 user1 users 9319 2010-02-09 23:56 a.out

rwx：读、写、运行

9个权限位，每3个为一组，分别代表文件所有者、同组用户和其他用户的权限。

更改文件权限chmod     $ chmod 777 a.out   $ chmod –w a.out

目录文件权限x： 是否可以存取目录中的文件。 r： 是否可以对目录进行文件列表。可以存取已知的文件。 w：是否可以增加、删除目录中的文件。

**4**. 文件的组成：文件名、i节点、文件内容。i节点中记录文件权限、所有者、修改日期、长度、存放位置等等。![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

$ ln file1 file2 //给file1所对应的i节点增加一个文件名file2

$ rm file2 //删除文件名file2。对应的i节点和文件内容依然存在。

$ rm file1 //删除文件名file1。由于没有文件名指向该i节点，系统删除该i节点及其对应的文件内容

**5.** 设备文件

UNIX的精华思想之一就是在文件系统中处理外部设备，按普通文件来处理外设。

$ ls -l /dev          $ echo hello! > /dev/pts/0

$ cat c/sig.c >/dev/pts/1       $ cp tmp /dev/pts/0

**四：流编辑器sed**

**1.**$ sed 's/UNIX/Linux/g' file  将file中的UNIX替换成Linux显示在屏幕上，但不改变file本身。

$ who | sed 's/ .*//' 显示当前登录用户，只显示用户名。

$ who am i |sed 's/ .*//' 获取我的登录名. 

$ sed '10q' file   显示file文件的前10行

$ sed '/pattern/d' file   不显示包含pattern的行。

$ sed -n '/pattern/p' file 仅显示包含pattern的行。sed默认显示每一行，-n选项关闭自动显示功能。 sed -n ‘/pattern/p’ file具有过滤功能，与grep pattern file功能相同。

$ ls -l | sed -n '/^d/p' 长格式列出当前目录下的子目录

$ ls -l | sed -n '/^d/p'|sed 's/.* //' 列出当前目录下的子目录

 

sed的局限性 由于sed处理的是输入流，一旦读入一行，前面的行就过去了，无法再次取回，因此sed不具备行运算的能力。例如 $ sed '$-1d' 是非法的

**2.** **过滤器**grep，fgrep，egrep

$ grep pattern file  pattern: ed pattern

$ grep '^void' sig.c 显示sig.c文件中以void开头的行

$ ls -l | grep '^d'  列出当前目录下的子目录

$ ls -l | grep '^d' | sed 's/.* //' 列出当前子目录名

fgrep功能较弱，但处理大文件的能力强，egrep使用扩展正则表达式，功能强大。

**3.** sort----排序

$ ls | sort

**4.** tail、head

$ tail file 显示file的最后10行

$ tail -5 file 显示file的最后5行 

$ head file 显示file的前10行

$ head -5 file 显示file的前5行

**五：模式匹配与处理语言awk**

一般使用形式：

$ awk 'program' filename

$ commd | awk 'program '

program的形式

pattern1 {action1} pattern2{action2}……

pattern: ed的正则表达式，逻辑表达式

action：如print、printf等

缺省

$ awk '/pattern/' file 显示匹配模式的每一行，功能同grep

$ awk '{print}' 显示每一行，功能同cat

记录、字段

每一行为一条记录，NR为记录数

每一个非空的字符串为一个字段，使用$1、$2、…标记，$0为整行，NF为字段数

$ awk '{print NR, $0}' file 显示file，并在行首加上行号

$ ls –l | awk ' /^d/{print}' 长格式列出当前目录下的子目录

$ ls –l | awk ' /^d/{print $8}' 列出当前目录下的子目录

打印（显示）

$ ls –l | awk '{print NR, ": " $1, $8}'

$ awk '{printf("%d: %s\n", NR, $0)} ' sig.c

pattern

字段运算、模式表达式、逻辑表达式

$ ls –l | awk '$5~/.....*/' 列出长度超过999字节的文件

$ ls –l | awk '$5 !~ /.....*/' 列出长度小于等于999字节的文件

$ ls –l | awk '$5=="4096"' 列出长度为4096字节的文件

$ ls –l | awk 'length($5)>3' 列出长度超过999字节的文件

$ ls –l | awk '!(length($5)>3) ' 列出长度小于等于999字节的文件

特殊pattern

awk 'BEGIN{初始化动作}'

awk 'END{结束动作}'

变量和运算

举例：打印某个文件的行数、单词数和字符数

$ awk '{

nw += NF

nc +=length($0)+1

}

END{

print NR, nw,nc

}' sig.c   //这段程序的功能与wc命令的功能完全一样。

流程控制

寻找文件中相同的相邻单词

$ awk 'NF>0{

  if ($1==lastword)

   printf("double %s, line %d:\n%s\n", $1,NR,$0)

  for (i=2; i<=NF; i++)

​    if ($i==$(i-1))

​     printf("double %s, line %d:\n%s\n", $i,NR,$0)

  lastword=$NF

} ' tmp

流程控制（二）

while语句

while (condition){

  statement1

  statement2

  …

  }

break:跳出循环

continue:下一个循环

next:下一条记录，回到awk程序开始

exit:跳转至END模式或结束

内部变量（部分）

FILENAME 当前输入文件名

RS  输入记录的分割符（默认为换行符）

FS  输入字段的分隔符（默认为空格、制表符）

NF  当前记录的字段数

NR  当前记录数

OFS  输出字段的分隔符（默认为空格）

ORS 输出记录的分隔符（默认为换行）

内部函数（部分）

cos(expr) 求余弦

exp(expr) 求自然指数

index(s1,s2)  是否字符串s2位于s1中

int(expr)     取整

length(s)  求字符串长度

log(expr)  求自然对数

sin(expr)  求正玄

split(s, a, c) 按分隔符c将s放入a[1],a[2],…中

substr(s,m,n) 求s的子串，从第m个字符开始，共n个字符。

数组

$ awk '{line[NR] = $0}

​     END{

​        \# do what you want

​        for (i=1; i<=NR; i++) print line[i]

​        } '

 

流处理程序的约定，当给定文件名时，数据从文件中读取，否则从标准输入读取。这样便于管道和重定向的使用。

***awk\******用于格式化报文或者从文件中抽取数据包\*****．**
 　1.$awk '{print $0}' gefforey.txt | tee gefforey.doc
 该命令将在屏幕输出gefforey.txt文件内容并将其内容复制到gefforey.doc文件中．
 　2.$awk -F: '{print $1}' gefforey.log
 该命令以:为单位读取gefforey.log文件中第一列内容．
 　３.$awk 'BEGIN {print "Name  Belt\n------------"} {print $1"\t"$3}' gefforey.txt
 该命令将在屏幕首先输出"Name  Belt"，第二行输出"------------"，并在输出文件内容的时候，每列之间间隔一个TAB位．可以在print语句之后加上END {print "end of output"}，那么将会在文件内容输出结束的时候打印"end of output"．
    4.$awk '$2 ~ /^baidu$/ {print $0}' gefforey.txt
 该命令显示gefforey.txt文件中以空格分隔的第二列字符串是"baidu"的所有行．
 　5.$awk '{if($2 ~ /^baidu$/) print $0}' gefforey.txt
 该命令判断如果某行第二列字符串为"baidu",则打印出该行．
    6.$awk '{if($2 < $3) print $0}' gefforey.txt
 该命令显示判断如果某行第二列值小于第三列值，则打印该行．awk的条件操作符有：
 < 小于，> = 大于等于，< = 小于等于，~ 匹配正则表达式，= = 等于，!~ 不匹配正则表达式，!= 不等于
 　7.$awk '{if($2 =="google1" && $3=="google2") print $0}' gefforey.txt
 该命令判断如果某行第二列值为"google1"并且第三列值为"google2"，则打印出该行．awk的逻辑表达式有：&& AND，|| O R，! 非．
 　8.$awk '{print NF,NR,$0} END{print FILENAME}' gefforey.txt
 该命令会输出浏览记录的域个数和已读的记录数，并在输出结尾打印文件名．

**六：vi编辑器**

由BSD UNIX的作者Bill Joy编写

分两种工作模式：命令模式、编辑模式。a、i、o、O命令进入编辑模式，ESC退出编辑模式。

在命令模式下，可使用所有的ed命令。

退出：按住esc+shift+； 然后输入wq

**七：图形界面系统管理**

**1.**X server

处理输出

接受X client的输出请求，驱动硬件显示

处理输入

接受键盘、鼠标的输入，当作“事件”传送给适当的客户程序。

窗口管理器

一个特殊的X客户程序，具有改变窗口大小、位置、堆放层次等功能。

桌面系统

另一个特殊的X客户程序，依赖窗口管理器，控制桌面、菜单的位置、风格、效果等。

\2. X 协议 ： X 系统采用客户-服务器模型，带来如下优点

X server屏蔽了硬件特性，使得X client和X server之间的X协议是一个完全抽象的协议，具有很强的可移植性

将X协议构建在网络协议之上，X server和X client可以运行在不同的机器上，这带来了很大的灵活性。

**3.**提示

当用户使用X协议登录远程计算机时，本地运行的是X server，远程计算机运行的应用程序是X client。

**4.** X 开发接口

X Library

最底层的程序界面，主要功能是存取X protocol的服务

常见的有：Xlib、Motif、Qt

X Toolkit

X Library基础上的拓展，提供大量函数或组件。

种类很多，有Motif、OpenLook、Gimp、X foums、X Toolkit（Xt）等

**5.** 激活超级用户（root）（非必须）

为了安全，Ubuntu Linux默认禁用root用户。使用sudo命令可以提升权限，只是有些麻烦。

$ sudo vi /etc/gdm/gdm.conf    将其中一行“AllowRoot=false”改为“AllowRoot=true”  //也可以通过主菜单“系统”->“系统管理”->“登录窗口”进入“登录窗口首选项”，在“安全”选项页中选中“允许本地系统管理员登录”。

$ sudo passwd root 更改root用户口令  重启系统

**6.** 网络配置

IP地址、子网掩码、默认网关

\# vi /etc/network/interfaces

auto eth0

iface eth0 inet static  # or dhcp

address xxx.xxx.xxx.xxx

netmask xxx.xxx.xxx.xxx

gateway xxx.xxx.xxx.xxx

域名服务器DNS

\# vi /etc/resolv.conf

\# Generated by NetworkManager

nameserver xxx.xxx.xxx.xxx  //add it

nameserver xxx.xxx.xxx.xxx

……

\# /etc/init.d/networking restart  重启网络，配置生效。可使用ifconfig、route等命令查看配置结果。

**7.** 创建WebServer

\# apt-get install apache2

http://xxx.xxx.xxx.xxx(Ubuntu Host IP Address)

共享文件（网络邻居）

\# apt-get install samba

建一个共享文件夹，设权限为777，在文件管理器中使用鼠标右键共享之。

**8.** 用户帐号管理     命令 useradd、adduser、userdel、usermod、passwd

使用图形界面   增、删、改、查。     修改用户密码、权限。

组管理    命令 groupadd、addgroup、groupdel、groupmod、gpasswd

使用图形界面    增、删、改、查。    修改组权限、成员。

**9.** 系统数据文件 /etc/passwd        /etc/shadow

/etc/group //都是文本文件，不要随意修改。

**10.** 磁盘管理概述

磁盘包括软盘、光盘、硬盘。设备文件分别为：/dev/fd[01]、/dev/hd[abcd]（IDE硬盘）、/dev/sd[abcd]（SCSI硬盘）、/dev/cdrom

硬盘必须分区和格式化才可使用。硬盘分区后，每个分区对应的设备名为“硬盘设备名”[1256]，例如/dev/sda1代表第一块SCSI硬盘的第一个分区。

硬盘分区：一块硬盘最多可分4个分区，需要分更多的区时，可分一个扩展分区，然后将扩展分区再分为若干逻辑分区。

管理硬盘分区的命令为fdisk。例如 

\# fdisk /dev/sdb //对第二快SCSI硬盘进行分区管理

格式化分区（创建文件系统）

\# mkfs 分区名  //分区名：如/dev/sdb1

\# mkfs -t msdos 分区名  //指定文件格式，默认文件格式为ext2

使用文件系统

\# mount 分区名 路径 //将某硬盘分区挂载到某个目录下，通常该目录为空目录

卸载文件系统    # umount 分区名或路径 //将某硬盘分区和挂载点脱钩

查看分区挂载情况    # df

**11.** 查看进程

$ ps //查看当前终端启动的进程    $ ps -t 终端名 //显示某个终端启动的进程

$ ps -u 用户名 //显示某个用户启动的进程

$ ps -e      //显示所有进程   $ ps -f       //显示进程完整信息

$ ps –ef |grep ‘pattern’ //显示你想看到的进程

结束进程：kill命令语法 kill [-signal] pid  //kill命令用来给一个进程发信号，但常用的功能是结束某个进程（发一个可以结束某个进程的信号）。

kill -l //列出可用的信号选项

例$ ./sig

$ kill -2 pid

$ kill -14 pid

$ kill -9 pid     

**八： shell编程**

**1.**将一些有用的命令组合变成实用工具

ls -l | sed -n '/^d/p'  //显示当前目录下的子目录

$ vi lsdir

$ sh lsdir

$ chmod +x lsdir

$ PATH=$HOME/bin:$PATH

**2.** 快速编写一些实用的软件

$ vi mycat

awk '{print NR,“: ”,$0}' $1  //$1 为shell命令的第1个参数

$ chmod +x mycat

$ mycat file1

**3.** 位置参数

测试位置参数

$ vi test

echo $0 $1 $2 $3 $4

$ sh test a1 a2 a3

   test a1 a2 a3

位置参数重置

$ vi test

echo $0 $1 $2 $3 $4

set b1 b2

echo $0 $1 $2 $3 $4

$ sh test a1 a2 a3

 test a1 a2 a3

 test b1 b2

\1) set命令可以重置位置参数；2）参数$0是命令名，不可重置；3）set命令重置除$0外所有参数

位置参数的移动

$ cat test

echo $0 $1 $2 $3 $4 $5 $6 $7 $8

shift

echo $0 $1 $2 $3 $4 $5 $6 $7 $8

shift 2

echo $0 $1 $2 $3 $4 $5 $6 $7 $8

shift命令可以左移位置参数，但不可移动参数$0

**4.** shell命令行结构

单个命令$ who      $ date  多个命令$ who; date       $ who; date |wc

$ (who; date )|wc       $ (who; date)|tee save |wc

后台命令$ (sleep 5; date)&       $ (sleep 5; date)& who

命令行特殊符号 > < >> << ; &      转义 $ echo \>

**5.**命令行模式

$ echo *      转义 $ echo \*

单引号 $ echo ‘*’ //取消所有特殊字符的含义

双引号 $ echo “*” //除$\``外，取消其它特殊字符的含义

**6**. shell元字符集

\>  prog>file标准输出重定向

\>> prog>>file标准输出重定向（添加）

<  prog<file标准输入重定向

<<str 即时文件读入，直到str结束

|   p1|p2  p1的标准输出连接到p2的标准输入

\*   匹配文件名中任意字符串

?   匹配文件名中任意单个字符

[ccc] 匹配文件名中单个ccc中的字符。ccc可以指定范围，如0-9，a-z等

; 命令结束符。p1;p2，先执行p1，再执行p2

& 后台命令结束符。不等命令结束，立即接受新的命令

```
…`  执行命令…，用执行后的标准输出代替…  例如$ echo `date
```

(…)  在子shell里运行括号里的命令

$1, $2, …  位置参数

$var  引用变量var的值

${var} 同上，在可能引起歧义时，使用{}将变量名括起来。

\  转义，取消字符的特殊含义

'…' 单引号，字符串，对…中的特殊字符不作解释

"…" 双引号，字符串，对…中的特殊字符仅解释$\``

\#  注释。从#开始至行尾为注释

var=value 对变量var赋值

P1 && p2  运行p1，若成功，运行p2

P1 || p2   运行p1，若不成功，运行p2

**7.** 引号（单引号、双引号、反引号）

$ echo don't do that

$ echo "don't do that"

$ echo "don't do that, $0"

$ echo "don't do that, $0, `date`"

$ echo "don't do that, \$0, \`date\`"

$ echo 'don't do that, $0, `date`'

**8.** 重定向

每个程序启动时自动打开三个文件：标准输入、标准输出和标准错误输出文件，文件描述符分别为0、1、2.

\>和>>将标准输出定向为一个文件，如$who >ttt

<将标准输出定向为一个文件，如$cat<ttt

如何重定向标准错误输出？

$ gcc sig.c >ttt  //cat ttt?

$ gcc sig.c 2>ttt //cat ttt?

$ gcc sig.c >ttt 2>&1 //cat ttt?

**9.** <<的用途

<<定义及时文件的结束符，用于在shell程序中创建文件。

如下shell程序创建一个文件

$ cat mkafile

cat >$1 <<end

hello world!

end

$ sh mkafile ttt

$ cat ttt

hello world!

**10**. shell程序的结构

①if命令

结构

if list   #list:命令序列

then

  list

[elif list then list]

[else list]

fi

例1，if list中最后一个命令的返回值

if gcc /home/lls/c/sig.c

\#who

then

  echo program is ok!

else

  echo bad program

fi

例2，判断参数个数cargus

if test $# -eq 5  //$#为shell内部变量，代表参数个数

then

  echo there are 5 argus

elif test $# -gt 5

then

  echo more than 5 argus

else

  echo less than 5 argus

fi

②test命令

常用于if、while、until命令中的条件判断

功能：判断文件类型或表达式是否为真

test –option file模式

test -e file  //文件存在

test –b file  //文件存在且为块设备文件

test –c file  //文件存在且为字符设备文件

test –d file  //文件存在且为目录文件

test –f file  //文件存在且为普通文件

test expression模式

test e1  //e1为真

test ! e1  //e1为假

test e1 –a e2  //e1,e2都为真

test e1 –o e2  //e1或e2为真

test f1 –nt f2  //文件f1比文件f2新

test f1 –ot f2  //文件f1比文件f2旧

test –option string模式

test –n str //字符串str非空

test –z str //字符串str为空

③case命令

尽量使用case来代替if

结构

case word in

pattern1) list1;;

pattern2) list2;;

…

esac

例 cargus

case $# in

5)

  echo there are 5 argus;;

[0-4])

  echo less than 5 argus;;

*)

  echo more than 5 argus

esac

例 显示某c文件的前6行

case $# in

0)

  echo usage: ccat file

  exit 1;;

esac

case $1 in

*.c)

  echo c file: $1

  head -6 $1;;

*)

  echo the file must be c file

esac

④for命令

结构一

for variable in 某个集合  //集合中元素的个数决定循环的次数

do

   list

done

例 显示所有命令行参数

for i in $*

do

 echo $i

done

echo there are $# argus

结构二   //仅bash

for ((e1;e2;e3))

do

  list

done

如：

for ((i=0; i<maxnum; i++))

do

  ……

done

例 倒序显示命令行参数

j=0

for i in $*

do

 a[j]=$i

 let j=$j+1

done

for ((i=$#-1; i>=0; i--))

do

 echo ${a[i]}

done

⑤shell内部变量

$# 命令行参数个数

$*  命令行参数集合

$@ 命令行参数集合 //与$*有细微差别

$?  最后一条命令的返回值

$$ 当前shell的进程号

$!  最后一个后台命令的进程号

$HOME $PATH $PS1 $PS2

⑥while、until命令

while命令结构

while

  list

do

  list

done

until命令结构

until

  list

do

  list

done

⑦其它命令

break 跳出循环

continue 下一个循环

exit n 终止shell程序，n为返回值

trap 设置中断处理命令。例如：

trap 'rm –f tmpfile; exit 1' 1 2 15

shell编程的优点：充分利用现有资源，快捷

shell程序的缺点：功能有限，代码不易读，可移植性差

shell本身是一个普通用户的接口，能提供如此编程环境已经不易。

**变量赋值和引用**

Shell编程中，使用变量无需事先声明，同时变量名的命名须遵循如下规则：

\1.  首个字符必须为字母（a-z，A-Z） 或者_

\2.  中间不能有空格，可以使用下划线（_）

\3.  不能使用其他标点符号

需要给变量赋值时，可以这么写：

变量名=值 

要取用一个变量的值，只需在变量名前面加一个$ ( 注意: 给变量赋值的时候，不能在"="两边留空格 )

\#!/bin/bash

\# 对变量赋值：

a="hello world" #等号两边均不能有空格存在

\# 打印变量a的值：

echo "A is:" $a

 

挑个自己喜欢的编辑器，输入上述内容，并保存为文件first，然后执行 chmod +x first 使其可执行，最后输入 ./first 执行该脚本。其输出结果如下： 

A is: hello world

 

有时候变量名可能会和其它文字混淆，比如：

num=2

echo "this is the $numnd"

 

上述脚本并不会输出"this is the 2nd"而是"this is the "；这是由于shell会去搜索变量numnd的值，而实际上这个变量此时并没有值。这时，我们可以用花括号来告诉shell要打印的是num变量：

num=2

echo "this is the ${num}nd"

 

其输出结果为：this is the 2nd


 注意花括号的位置：

num=2

echo "this is the {$num}nd"

 

其输出结果为：this is the {2}nd


 需要注意shell的默认赋值是字符串赋值。比如：

var=1

var=$var+1

echo $var

打印出来的不是2而是1＋1。为了达到我们想要的效果有以下几种表达方式：

let "var+=1"

var="$[$var+1]"

((var++))

var=$(($var+1))

var="$(expr "$var" + 1)" #不建议使用

var="`expr "$var" + 1`" #强烈不建议使用，注意加号两边的空格，否则还是按照字符串的方式赋值,`为Esc下方的`，而不是单引号'。

注意：前2种方式在bash下有效，在sh下会出错。

let表示数学运算，expr用于整数值运算，每一项用空格隔开，$[]将中括号内的表达式作为数学运算先计算结果再输出。

Shell脚本中有许多变量是系统自动设定的，我们将在用到这些变量时再作说明。除了只在脚本内有效的普通shell变量外，还有环境变量，即那些由export关键字处理过的变量。本文不讨论环境变量，因为它们一般只在登录脚本中用到。

**Shell****里的流程控制**

**if** **语** **句**

"if"表达式如果条件为真，则执行then后的部分:

if ....; then

 ....

elif ....; then

 ....

else

 ....

fi

大多数情况下，可以使用测试命令来对条件进行测试，比如可以比较字符串、判断文件是否存在及是否可读等等……通常用" [ ] "来表示条件测试，注意这里的空格很重要，要确保方括号前后的空格。

**[ -f "somefile" ]** **：判断是否是一个文件**

**[ -x "/bin/ls" ]** **：判断****/bin/ls****是否存在并有可执行权限**

**[ -n "$var" ]** **：判断****$var****变量是否有值**

**[ "$a" = "$b" ]** **：判断****$a****和****$b****是否相等**

执行man test可以查看所有测试表达式可以比较和判断的类型。下面是一个简单的if语句：

\#!/bin/bash

 

if [ ${SHELL} = "/bin/bash" ]; then

  echo "your login shell is the bash (bourne again shell)"

else

  echo "your login shell is not bash but ${SHELL}"

fi

变量$SHELL包含有登录shell的名称，我们拿它和/bin/bash进行比较以判断当前使用的shell是否为bash。

**&&** **和** **||** **操作符**

熟悉C语言的朋友可能会喜欢下面的表达式：

[ -f "/etc/shadow" ] && echo "This computer uses shadow passwords"

这里的 && 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句，你也可以把它看作逻辑运算里的与操作。上述脚本表示如果/etc/shadow文件存在，则打印“This computer uses shadow passwords”。同样shell编程中还可以用或操作(||)，例如：

\#!/bin/bash

 

mailfolder=/var/spool/mail/james

[ -r "$mailfolder" ] || { echo "Can not read $mailfolder" ; exit 1; }

echo "$mailfolder has mail from:"

grep "^From " $mailfolder

该脚本首先判断mailfolder是否可读，如果可读则打印该文件中的"From" 一行。如果不可读则或操作生效，打印错误信息后脚本退出。需要注意的是，这里我们必须使用如下两个命令：

-打印错误信息

-退出程序

我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用；普通函数稍后再作说明。即使不用与和或操作符，我们也可以用if表达式完成任何事情，但是使用与或操作符会更便利很多 。

**case** **语句**

case表达式可以用来匹配一个给定的字符串，而不是数字（可别和C语言里的switch...case混淆）。

case ... in

  ...) do something here 

  ;;

esac

file命令可以辨别出一个给定文件的文件类型，如：file lf.gz，其输出结果为：

lf.gz: gzip compressed data, deflated, original filename,

last modified: Mon Aug 27 23:09:18 2001, os: Unix

我们利用这点写了一个名为smartzip的脚本，该脚本可以自动解压bzip2, gzip和zip 类型的压缩文件：

 \#!/bin/bash

 

 ftype="$(file "$1")"

 case "$ftype" in

 "$1: Zip archive"*)

  unzip "$1" ;;

 "$1: gzip compressed"*)

  gunzip "$1" ;;

 "$1: bzip2 compressed"*)

  bunzip2 "$1" ;;

 *) echo "File $1 can not be uncompressed with smartzip";;

 esac

你可能注意到上面使用了一个特殊变量$1，该变量包含有传递给该脚本的第一个参数值。也就是说，当我们运行：

smartzip articles.zip

$1 就是字符串 articles.zip。

**select** **语句**

select表达式是bash的一种扩展应用，擅长于交互式场合。用户可以从一组不同的值中进行选择：

select var in ... ; do

　break;

done

.... now $var can be used ....

 

下面是一个简单的示例：

\#!/bin/bash

 

echo "What is your favourite OS?"

select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do

 break;

done

echo "You have selected $var"

该脚本的运行结果如下：

What is your favourite OS?

\1) Linux

\2) Gnu Hurd

\3) Free BSD

\4) Other

\#? 1

You have selected Linux

**while/for** **循环**

在shell中，可以使用如下循环：

while ...; do

  ....

done

只要测试表达式条件为真，则while循环将一直运行。关键字"break"用来跳出循环，而关键字”continue”则可以跳过一个循环的余下部分，直接跳到下一次循环中。

for循环会查看一个字符串列表（字符串用空格分隔），并将其赋给一个变量：

for var in ....; do

  ....

done

下面的示例会把A B C分别打印到屏幕上：

\#!/bin/bash

 

for var in A B C ; do

  echo "var is $var"

done

下面是一个实用的脚本showrpm，其功能是打印一些RPM包的统计信息：

\#!/bin/bash

 

\# list a content summary of a number of RPM packages

\# USAGE: showrpm rpmfile1 rpmfile2 ...

\# EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm

for rpmpackage in "$@"; do

  if [ -r "$rpmpackage" ];then

   echo "=============== $rpmpackage =============="

   rpm -qi -p $rpmpackage

  else

   echo "ERROR: cannot read file $rpmpackage"

  fi

done

这里出现了第二个特殊变量$@，该变量包含有输入的所有命令行参数值。如果你运行showrpm openssh.rpm w3m.rpm webgrep.rpm，那么 "$@"(有引号) 就包含有 3 个字符串，即openssh.rpm, w3m.rpm和 webgrep.rpm。$*的意思是差不多的。但是只有一个字串。如果不加引号，带空格的参数会被截断。

**Shell****里的一些特殊符号**

**引号**

在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓的扩展是指程序会把通配符（比如*）替换成适当的文件名，把变量替换成变量值。我们可以使用引号来防止这种扩展，先来看一个例子，假设在当前目录下有两个jpg文件：mail.jpg和tux.jpg。

\#!/bin/bash

 

echo *.jpg

运行结果为：

mail.jpg tux.jpg

引号（单引号和双引号）可以防止通配符*的扩展：

\#!/bin/bash

 

echo "*.jpg"

echo '*.jpg'

其运行结果为：

 

 

*.jpg

*.jpg

其中单引号更严格一些，它可以防止任何变量扩展；而双引号可以防止通配符扩展但允许变量扩展：

\#!/bin/bash

 

echo $SHELL

echo "$SHELL"

echo '$SHELL'

运行结果为：

/bin/bash

/bin/bash

$SHELL

此外还有一种防止这种扩展的方法，即使用转义字符——反斜杆:\：

echo \*.jpg

echo \$SHELL

输出结果为：

 

 

*.jpg

$SHELL

**九：c语言开发环境**

**1**. 实例分析

/* traditional first c program */

\#include <stdio.h>

int main(argc, argv)

  int argc; char *argv[];

{

  printf("hello world!\n");

  return 0;

}

注释/* traditional first c program */，/*  */ 之间为注释，用于阅读，编译器忽略这些内容。

预编译指令

\#include <stdio.h> 告诉编译程序，在编译之前在“常见位置”寻找stdio.h，将其内容包含到程序中。

\#为预编译指令，告诉编译程序其后的内容在编译之前需要处理。

include表示包含某个文件

<>表示“常见位置”，通常为/usr/include. 如果文件在其它位置，应使用””号。如#include “myhead.h”。

stdio.h为标准输入/输出头文件，其中包含了main函数所使用的printf函数

主函数

int main(argc, argv)

任何c程序必须有一个main函数，程序从main函数开始执行。

主函数参数

  int argc; char *argv[];

主函数参数是命令行的参数，argc是参数的数量，argv是各个参数所组成的数组。

良好的习惯：对于输入数据，如果给出了输入文件，则从该文件读入数据，否则从标准输入读入数据；对于输出数据，如果给出了输出文件，则输出至该文件，否则输出至标准输出文件。----这样便于使用管道来连接命令。

主函数返回值

  return 0

主函数最好声明为int类型。如果程序正常结束，主程序的返回值最好为0，否则返回-1或其它值。这样有利于shell编程。

使用echo命令可以查看最后一条命令的返回值。

$ ./a.out

$ echo $?

**2.** **c****编译过程：**第一步，预处理。处理预处理指令，如#inlude、#define等，输出预处理后的源文件。第二步，编译。词法和语法分析，如果有错误，则给出提示终止编译；如果没有错误，则将源程序翻译成汇编代码（或其它中间代码）。汇编代码是以助记符来代替机器代码的一种代码。第三步，汇编。将汇编代码转换成机器代码，输出目标文件。第四步，连接。连接各目标文件，生成可执行程序。

**3.** **（UNIX****系统中默认的c****编译器为cc****。在Ubuntu****中，cc****等同于gcc****）**

$ cc hello.c  //生成可执行程序 ./a.out

$ cc -o hello hello.c //生成可执行程序 hello

$ cc p1.c p2.c //源程序由两个文件组成。编译p1.c和p2.c，生成./a.out

$ cc -c p1.c //编译p1.c，生成目标文件p1.o，不连接。

$ cc -g hello.c //编译hello.c，在目标文件中加入调试信息。

**4.** **程序调试工具gdb**

主要功能包括：1）启动程序，可以按照自定义的要求运行程序。2）可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）3）当程序被停住时，可以检查此时你的程序中所发生的事。 4）动态的改变你程序的执行环境。

采用命令行界面。

命令简介：(gdb)  //gdb 命令提升符

(gdb) help  //显示gdb命令分类

(gdb) help breakpoints //显示断点设置的相关命令

(gdb) h b  //同上。只要不引起歧义，gdb命令可以简写。

(gdb) he bre //同上。

**5.** make：使用默认文件名时，只需执行命令make即可完成编译；使用其它文件名时，需要执行make -f filename来完成编译。

\6. 编译规则

一个例子p: p1.o p2.o

gcc -o p p1.o p2.o

p1.o: p1.c

gcc -c p1.c

p2.o: p2.c

gcc -c p2.c       上例中包含3条规则，每条规则包含一个文件依赖关系和一条命令。p:p1.o p2.o表示文件p依赖文件p1.o和p2.o，如果这两个文件中的任何一个比文件p新（更改时间更晚），则执行规则中的命令gcc -o p p1.o p2.o

例1 自动规则

p: p1.o p2.o

gcc -o p p1.o p2.o

$ touch p1.c

$ make

对于p1.o和p2.o，make自动生成如下规则 p1.o:p1.c; gcc –c –o p1.o p1.c 和p2.o:p2.c; gcc –c –o p2.o p2.c

例2

p: p1.o p2.o

gcc -o p p1.o p2.o

p1.o:p1.c

echo donothing

$ touch p1.c p2.c

$ make

$ make

由于p1.o的生成规则存在，make采用该规则，不再为这个依赖文件生成规则

例3

p: p1.o p2.o

gcc -o p p1.o p2.o

sig.o:sig.c

gcc -c sig.c

$ touch sig.c

$ make

sig.o不是终极目标的依赖文件，其生成规则不采用。

例4

p: p1.o p2.o x

gcc -o p p1.o p2.o

$ make

没有创建x的规则，也无法自动创建，错误！

规则的一般形式

目标文件：依赖文件1 依赖文件2 …

<tab>命令1  [#注释]

<tab>命令2  [#注释]

……

\#一条规则可以执行多条命令，每条命令的行首必须是制表符（tab），make文件中可以有注释

**7.** 使用变量

make文件中可以使用变量，这样更为简洁，避免出错。例如：

\# sample 1

objs = main.o kbd.o command.o display.o \

 insert.o search.o files.lo untils.o

edit:$(objs)

cc -o edit $(objs)

\#用\将较长的行分解为多行。\取消换行符的作用，其后面不能有空格等字符，否则会出错（很隐蔽的错误）。

\#如果不定义变量，所有.o文件会写两次，繁琐，且容易出错

**8.** 使用隐含规则

只有依赖关系而没有命令的规则为隐含规则。如

p1.o : p1.c a.h  # or p1.o : a.h

p2.o : p2.c b.h  # or p2.o : b.h

p3.o : p3.c     # or p3.o:  or <null> 

对于隐含规则，make会自动运行相应的命令来生成目标文件。如 gcc -c -o p1.o p1.c

对于p1.o:p1.c这种自动的依赖关系，可以省略不写。

只有自动依赖关系的隐含规则可以不写。

**9.**伪目标规则

伪目标规则完成某些编译以外的任务，例如：

clear:

rm *.o

dosth:

echo what you want?

执行伪目标规则中的命令

$ make clear

$ make dosth

$ make clear dosth

如果伪目标文件存在，将不会执行预期的操作，因此，最好在make文件中声明伪目标规则

.PHONY: clear dosth

**10.** 标准c函数

系统调用：操作系统需要向运行程序提供各种服务，如打开文件、读写文件、分配内存、获取当前时间、执行新的程序等。访问这些服务的接口叫做“系统调用（sysem call）”，或叫做“应用程序接口（API）”、“服务原语”等。

UNIX每个系统调用都在c库中设置一个具有同样名字的函数。这些函数按照系统要求的技术调用相应的内核服务。例如将若干c参数送入通用寄存器，然后执行某个软中断进入内核的机器指令。从应用的角度，系统调用可视为c函数。

库函数

库函数是在系统调用基础上所实现的公共函数。

一个库函数可能会调用一个或多个系统调用，也可能不使用任何系统调用。例如，printf函数是库函数，它调用write系统调用；strcpy复制一个字符串，不使用系统调用。

二者的关系

系统调用是操作系统内核提供的，而库函数是具体编程语言提供的。库函数构建在系统调用基础之上。从编程的角度，编程者可编写其它函数来替换库函数，但无法替换系统调用。系统调用通常提供某种功能的一个最小接口，而库函数通常提供比较复杂的功能。例如，系统调用write提供基本的文件写操作，而printf则提供格式化的写操作。

约定：在不需要严格区分的前提下，“标准c函数”、“库函数”指所有c语言标准头文件中定义的函数，其中包括库函数和系统调用。

**十：系统调用**

\1. 基本文件I/O函数：open、creat、read、write、lseek、close

术语：不带缓冲的I/O（指每一个read、write都调用内核中的一个系统调用），低级例程。

文件描述符：一个非负的整数，一个结构数组的下标，进程打开的文件表项的下标。

open、creat函数会返回一个文件描述符

close：

\#include <unistd.h>

int close(int filedes)

返回值：若成功，返回0，出错返回-1

filedes，文件描述符

进程终止时，内核自动关闭其打开的所有文件

lseek

移动文件“读写指针”（或称“文件偏移量”）。读写操作会自动移动文件读写指针。

\#include <unistd.h>

off_t lseek(int filedes, off_t offset, int whence)

off_t 与系统有关，通常是长整型

filedes 文件描述符

whence 移动偏移量的方式。0：绝对方式；1：相对方式；2：相对文件尾部

offset 移动的距离，非绝对方式移动时，可以为负。

返回值：新的文件偏移量。

read

从已打开的文件中读取数据，自动移动文件读写指针。

\#include <unistd.h>

ssize_t read(int filedes, void *buff, size_t nbytes)

ssize_t 通常是整型，size_t通常是无符号整型。

filedes 文件描述符

buff 存放数据的缓冲区

nbytes 需要读取的字节数

返回值：实际读取的字节数。正常读取时，返回值等于nbytes;遇到文件结束时，小于nbytes；出错返回-1

write

将数据写入已打开的文件，自动移动文件读写指针。

\#include <unistd.h>

ssize_t write(int filedes, void *buff, size_t nbytes)

ssize_t 通常是整型，size_t通常是无符号整型。

filedes 文件描述符

buff 存放数据的缓冲区

nbytes 需要写入的字节数

返回值：实际写入的字节数。正常写入时，返回值等于nbytes;磁盘空间满时，小于nbytes（这种情况也可以认为是出错）；出错返回-1

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png)

**2.** **dup2**

\#include <unistd.h>

int dup2(int filedes1, int filedes2)

将文件描述符filedes1的表项复制给filedes2的表项。如果filedes2已经打开，则先将其关闭。

返回值：正常返回filedes2，出错返回-1

**3.**原子操作 例1 多个进程添写同一个日志文件

有问题的代码：

lseek(fd, 0L, 2)

write(fd, buf, nbytes)

正确的做法：

open时，使用O_APPEND选项

write时，不需要调用lseek，直接写。

例2 多个进程创建可能重名的临时文件

有问题的代码：

if （open（tmpfile, O_WRONLY)<0)

   creat(tmpfile, mode)

正确的做法：

open(tmpfile, O_CREAT|O_WRONLY|O_TRUNC, mode)

最好的做法是保证没有重名的临时文件。

**3.** 文件属性和目录

文件属性

属性结构

struct stat {

 mode _t   st_mode;  //文件类型和权限

 ino_t     st_ino;   //i节点号

 dev_t     st_dev;   //文件系统设备号（磁盘和分区）

 dev_t     st_rdev;  //设备文件的设备号

 nlink_t    st_nlink;  //链接数

 uid_t     st_uid;   //文件所有者的用户ID

gid_t     st_gid;   //文件所有者的组ID

 off_t     st_size;   //文件长度（字节数），普通文件

 time_t    st_atime;  //最后一次访问的时间

 time_t    st_mtime; //最后一次修改文件内容的时间

 time_t    st_ctime;  //最后一次修改文件属性的时间

 }

函数

\#include <sys/stat.h>

int stat(const char *pathname, struct stat *buf)

int fstat(int filedes, struct stat *buf)

文件类型

类型：普通文件、目录文件、字符设备文件、块设备文件、 FIFO、符号链接、套接字

判断文件类型

S_ISREG(mode_t mode)  //是否普通文件

S_ISDIR(mode_t mode)  //是否目录文件

S_ISCHR(mode_t mode)  //是否字符设备文件

S_ISBLK(mode_t mode)  //是否块设备文件

S_ISFIFO(mode_t mode) //是否管道文件

S_ISLNK(mode_t mode)  //是否符号链接

S_SOCK(mode_t mode)  //是否套接字

文件的权限

9个普通权限位

S_IRUSER, S_IWUSER, S_IXUSER //用户权限位

S_IRGRP,  S_IWGRP,  S_IXGRP  //用户组权限位

S_IROTH,  S_IWOTH, S_IXOTH  //其他用户权限位

3个特殊权限位（针对可执行文件）

S_ISUID 执行时设置有效用户ID，如passwd命令文件

S_ISGID 执行时设置有效用户组ID

S_SVTX  第一次执行时，保存正文，即常驻内存。

函数

int chmod(const char *pathname, mode_t mode)

int fchmod(int filedes, mode_t mode)

创建新文件

新文件的用户ID、组ID等于创建进程的有效用户ID和组ID

新文件的权限由指定权限和屏蔽字共同决定。

指定权限，open和creat函数中给出的权限。

屏蔽字（umask值），被umask屏蔽的权限位即使在open或creat中指定了也会被屏蔽掉。

\#include <sys/stat.h>

mode_t umask(mode_t mode)

umask函数设置当前屏蔽字，返回以前的屏蔽字。

普通文件操作函数

\# include <unistd.h>

int link(const char *existingpath, const char *newpath) 创建一个新的目录项newpath，指向一个现有的文件existingpath。

int unlink(const char *pathname) 删除一个目录项，对应文件的链接数减1。

\#include <stdio.h>

int remove(const char *pathname) 删除一个文件或目录的链接。

int rename(const char *oldname, const char *newname) 文件或目录更名

目录文件操作函数

\# include <sys/stat.h>

int mkdir(const char *pathname, mode_t mode) 创建一个目录

\# include <unistd.h>

int rmdir(const char *pathname) 删除一个空目录。

目录文件读函数 //只有内核才可以写

\#include <dirent.h>

DIR *opendir(const char *pathname)

struct dirent *readdir(DIR *dp)

int closedir(DIR *dp)

void seekdir(DIR *dp, long loc)

位置函数

改变进程的当前工作目录 //cd命令

\# include <unistd.h>

int chdir(const char *pathname)

int fchdir(int filedes)

获取当前工作目录 //pwd命令

\#include <unistd.h>

char *getcwd(char *buff, size_t size)

**4.** 进程控制

进程ID(进程号)

\#include <unistd.h>

pid_t getpid(void)  获取调用者的进程ID

pid_t getppid(void) 获取调用者的父进程ID。

创建进程（fork）

\#include <unistd.h>

pid_t fork(void)

功能：创建一个新的进程，新进程是旧进程的副本。旧进程叫父进程，新进程叫子进程。

返回值：fork函数调用一次，返回两次。在父进程中返回子进程的ID，在子进程中返回0，出错返回-1

if ((pid=fork()) =0) {

  …… //子进程代码}

else if (pid>0){

  …… //父进程代码}

else{

  …… //fork 出错 }

执行程序（exec）

父进程fork一个子进程后，子进程往往需要调用一个exec函数来运行一个新程序。

exec函数用一个新程序替换调用进程原有的代码、数据、堆栈等，新程序从头开始执行。exec不产生新的进程，所有调用前后的进程号不发生变化。

exec函数

\#include <unistd.h>

int execl(const char *pathname, const char *arg0,…,(char *)0)

int execv(const char *pathname, char *const argv[])

int execle(const char *pathname, const char *arg0,…,(char *)0, char *const envp[])

int execve(const char *pathname, char *const argv[], char *const envp[])

int execlp(const char *filename, const char *arg0,…,(char *)0)

int execvp(cons char *filename, char *const argv[])

说明：

\1) execl和execlp比较直观，类似命令行输入，推荐使用。

2）execve是系统调用，其他是库函数。

3）返回值：正常不返回，出错返回-1

文件共享

fork之后，所有父进程打开的文件描述符都被复制到子进程中。父子进程相同的文件描述符指向相同的内核文件表，具有相同的文件偏移量。如果父子进程同时操作相同的文件，则需要同步机制，否则会产生混乱。

一般情况下，应该尽量回避父子进程同时操作相同文件的情况。1）父进程等待子进程结束后再运行；2）父子进程运行不同的程序段，使用不同的文件。

创建进程的目的

1）并行。网络服务中，父进程等待请求，创建子进程来响应请求。

2）运行新程序。例如shell，不断地在fork和exec

进程结束

正常结束

main函数执行完

main函数中执行return

任意位置执行exit、_exit、_Exit

非正常结束

收到某个信号而结束

无论进程如何结束，都会执行内核中的一段代码：关闭所有打开文件，释放占用的内存。

进程结束时，内核会保存其终止状态，直到该进程的父进程取走其状态。

父进程结束，其子进程成为孤儿进程，由进程1（init进程）领养。

子进程先于父进程结束，如果父进程未取走其状态，则该进程仍然占有一定的内核资源，成为“僵死进程”。

由于僵死进程占用资源，因此当一个长期运行的服务类程序调用fork后，应处理僵死进程。

wait函数

\#include <sys/wait.h>

pid_t  wait(int *statloc)

pid_t  waitpid(pid_t pid, int *statloc, int options)

waitid、wait3、wait4等

**5.** 进程间通信

进程间通信包括：半双工管道、半双工命名管道（FIFO）、全双工管道、全双工命名管道、消息队列、信号量、共享存储、套接字、STREAMS，Linux支持以上全部，其他UNIX一般只支持一部分。

套接字可支持不同主机的进程间通信（网络通信），其他为主机内通信。主机内通信常用半双工管道，网络通信常用套接字。

半双工管道：所有UNIX系统都提供的一种通信方式。

特点：1）半双工的工作方式。通信方向是双向的，但只能选择其中一种。2）只能在具有公共祖先的进程之间使用。通常是父子进程之间。

函数

\#include <unistd.h>

int pipe(int filedes[2])

创建一个管道，若成功返回0，不成功返回-1；

由参数filesdes返回两个文件描述符: filedes[0]、filesdes[1]， filedes[0]为读而打开， filedes[1]为写而打开。

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png)

创建管道之后的情形如上图所示。将数据写入fd[1]，从fd[0]中读出。

管道在单个进程中没有意义，通常在pipe函数之后，立刻会调用fork，产生一个子进程，情形如下图所示：

![img](file:///C:/Users/Lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

代码示例（父进程写，子进程读）：

int fd[2]; char line[MAXLINE];

pipe(fd);

if (pid=fork() >0){  //父进程

  close(fd[0]);

  write(fd[1],”hello world!\n”, 12); }

else if (pid==0)｛  //子进程

  close(fd[1]);

  read(fd[0], line, MAXLINE); }

利用管道连接父子进程的标准输出和输入：

if (pid=fork() >0){  //父进程

  close(fd[0]);

  dup2(fd[1],1); }

else if (pid=0)｛  //子进程

  close(fd[1]);

  dup2（fd[0],0);

  execlp(……) }

……    //父进程代码

命名管道FIFO：命名管道是一种文件

$ mkfifo f1

$ ls -l f1

$ cat <f1

$ ls -l>f1

函数

\#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode)

**6.** 信号

信号是一种异步事件，通常是非正常情况，如：人为终止进程、除数为0、非法内存访问等。所谓“异步”，指信号的出现是随机的。

信号的产生：人为按下中断键 Ctrl_C ；用户使用kill命令；进程调用kill函数；程序运行错误，除数为0、非法内存访问

软件产生的信号：闹钟超时、写一个读端已关闭的管道、网络传来带外数据。----这些基本是可以预见的信号。

信号的处理

系统默认处理或忽略

捕捉信号 通知内核在某种信号发生时调用一个用户函数。

signal函数

\#inclucde <signal.h>

void (*singnal(int signo, void (*func)(int)))(int)

解释

void (*func)(int) 一个函数指针，所指向的函数需要一个整型参数，无返回值。

singnal(int signo, void (*func)(int)), signal函数有两个参数，一个整型，一个函数指针。

void (*signal(…))(int) signal的返回值也是一个函数指针，所指向的函数需要一个整型参数，无返回值。

signal函数的使用

void my_sig(int);

int main(){

 signal(SIGINT, my_sig);

 …}

void my_sig(int signo){

…}

alarm函数

\#include <unistd.h>

unsigned int alarm(unsigned int seconds)

按秒设置下一次闹钟的时间。

返回值，如果以前设置过闹钟，再次设置时返回上一次设置时间的余数；否则返回0。

alarm函数设置的时间到达时，产生SIGALRM信号。该信号的默认动作是终止程序。

信号捕捉实例(sig.c)

 signal(SIGINT, my_sig);

 signal(SIGALRM, my_sig);

void my_sig(int signo){

 if (signo==SIGINT){

   …

   }

   else if(signo==SIGALRM){

   …

   }

}

进程控制中的信号处理

fork时，子进程继承父进程的信号处理。

exec时，恢复系统默认设置。

重入问题

printf不可重入，大多数标准IO库函数不可重入。

信号处理程序应尽可能简单，尽可能不用库函数。
