---
title: 计算机组成P5与P6的总结
date: 2022-05-09 15:20:56
tags: 计算机组成
---

**(阅前声明，我用的分布式译码方法，因此一些修改可能与集中式译码的方式不太一样）**

#### P5与P6的套路

在完成P5与P6的过程中，发现课上考的一些指令都大同小异，先将其整理为四类功能的组合。
所有新增指令是这几种功能的相互组合

- ##### 条件存储 根据不同的条件，从DM中取出的数值不同

- ##### 条件计算 根据不同的条件，ALU执行的运算结果不同

- ##### 条件跳转 根据不同的条件，NPC跳转还是不跳转

- ##### 条件写入寄存器  根据不同的条件，指令写入寄存器的地址不同（根据不同的条件，指令写或不写也归入这一类中，因为我们使用AT法写地址为0就是不写，本质上还是写地址不确定）

至于为什么目前只看到这几种不同功能之间的组合，是因为P5，P6主要考察我们对于流水线问题的理解，而流水线中最重要的部分就是数据通路中的各个功能元件的使用，和阻塞转发的理解。

#### 要考察对于功能元件的理解，我们首先想想流水线中有哪些很重要的原件？

1. **在D级中**，最重要的原件肯定是NPC和GPR，由于GPR没啥可改的，所以NPC是考试的重点，于是便有了条件跳转这种考查方式。
2. **E级**，肯定是ALU，HILO乘除槽最重要，这俩本质都是一个计算部件，于是便有了条件计算这种考查方式。
3. **M级**，无可置是DM，于是便有了条件存储这种考查方式。
4. **W级和F级**都没有什么重要的功能部件，没有特别的考察方式。

#### 要考察对于转发阻塞的理解，该如何考察呢？

由于在流水线中我们在所有的该转发的地方都转发了，阻塞只要用AT法，把Tnew，Tuse确定好就可以，总的来说已经很完备，没有什么可以改动的地方。于是便诞生了这样一种考查方式，**如果写地址在一段时间内不确定呢**？这样该如何转发和阻塞呢？
这就是我们的条件写寄存器功能，重点考察的是对于转发和阻塞功能的理解。
理解了为什么这样考察，有助于我们接下来更好的解题。

### 1.如何进行条件判断？

所有上述四个功能的实现均基于条件判断。只有判断正确，我们才能确定是执行哪个功能？
看起来很简单，但这里又是一个很大的坑？**$signed的如何正确应用**
这里可以参考学长的博客，里面有关于$signed的理解，$signed搭配三目运算符，搭配小于<,大于>号很容易犯错。例如下面这样一种情况。

```v
always @(*)begin
    if($signed(ALU_A)<0)
    //....wrong 
    if($signed(ALU_A)<$signed(0))
    //....right
end
```

进行有符号数的大小比较时，最好全部加上`$signed`符号,因为整个表达式中只要有一个数被判定为无符号数，整个表达式中所有的`$signed`符号均可能失效，导致结果错误。条件判断目前看来的坑点就在于此。

### 2.如何单独解决条件计算功能

有了条件判断我们便可以执行这四条功能。首先是条件跳转功能，条件跳转只要更改CU控制信号，NPC内部case语句，CMP内部case语句即可。

### 3.如何单独解决条件计算指功能

修改CU控制信号，修改ALU,HILO乘除槽内部逻辑。
这里还有一个坑点，老朋友$signed又来了，坑就坑在$signed与乘除法的搭配
我们知道verilog乘除法默认是无符号乘除的，如果这时冒出来什么奇奇怪怪的功能要求加减乘除混合**有符号**运算，这里又有一个坑。

```v
    {HI,LO}=HI+$signed(A)*$signed(B)// wrong
    {HI,LO}=$signed($signed(HI)+$signed(A)*$signed(B))//right
```

跟条件判断中的原因一样，还是`$signed`符号用法的坑，这时我们最好全都给他套上`$signed`,以防万一

### 4.如何实现条件存储指令

这个基本没有什么坑，只要修改CU控制信号，DM内部逻辑。

### 5.如何实现条件写指令并将其与各种功能搭配

**写在前面，这个是最复杂的**

- 先实现条件写指令与其他功能的搭配。
  - 搭配方式（三种功能全都可以搭）：
    - 条件跳转+条件写
    - 条件计算+条件写
    - 条件存储+条件写
  - 可以看到，前面4种功能都进行了条件判断，条件写指令需要他们的条件判断信号。因此我们的实现方式如下：
  - 1. 将所有的条件判断信号输出来（指的是从CMP,ALU，DM中输出），配合分布式译码输出的信号生成一个**check信号**，这些check信号都要一级一级传下去，并在每一级输入分布CU，以便条件写功能的实现，代码和具体解释如下。

```v
//以下的xxx代表了一条具备条件跳转或条件计算或条件存储功能的指令，我们把它从CU中译出来并输出
//条件跳转指令在D级生成check信号并传下去
assign D_check = xxx&&(b_jump);
//条件计算指令在E级生成check信号并传下去
assign E_check = xxx&&(ALUorHILO_judge);
//条件存储指令在M级生成check信号并传下去
assign M_check = xxx&&(DM_judge);
```

  - 2. 将check信号输入每一级CU后，根据指令搭配的说明，修改CU中的写地址译码和写数据译码，有了check信号这个概念，这步很简单，需要注意的是，如果我们的check信号不是从一开始的D级就产生，比如说在M级才产生，才输入CU，由于我们使用的是分布式译码，那么我们之前CU里面的check信号是一个x信号，出现不确定错误。这一步避免很简单，只需要在CU里面把`==`号，改成`===`号，规避x这类的错误判断

```v
    if(xxx && check === 1'b1)
        RFA3 = rt_addr
    //.................
```

  - 3. 最后修改转发阻塞逻辑。我们明显可以看出这几条搭配有一个共同特点，**一段时期不知道写地址是啥，究竟写还是不写？**

    - 条件跳转+条件写,E级知道写地址
    - 条件计算+条件写,M级知道写地址
    - 条件存储+条件写,W级知道写地址
    - （PS.你可能会问，为什么都延后了一级，我认为在实际情况中，该级的条件判断输出是不稳定的，有一定延迟，把它输入到下一级流水线寄存器才是一个稳定的信号，所以我们按实际情况来想延后了一级） 

  - **我们规定，在明确写地址后才能转发。不明确写地址前，冒然转发会导致错误，这里搭配阻塞功能，只要可能发生冲突且此时不明确写地址，均阻塞**。

  - 接下来我们按照上述逻辑修改阻塞单元。

    - 条件跳转+条件写,E级知道写地址，不用修改阻塞，因为E级才开始有转发供给者，在这一级转发必不可能有错误。
    - 条件计算+条件写,M级知道写地址，E级冒然转发可能有错误，可以在这里如果D级可能出现冲突，阻塞一个周期，等待该指令从E到M。
    - 条件存储+条件写,W级知道写地址，E，M级冒然转发可能有错误，可以在这里如果D级可能出现冲突，阻塞两个周期，等待该指令从E到W。
      举个例子，这里假设有一条lwso指令，既可能写rt，又可能写$31,我们这样修改E级阻塞.

```v
//stall rs
wire stall_rs_E = (Tuse_rs < Tnew_E)&&((lwso)?(D_rs_addr == E_rt_addr||D_rs_addr == 31):D_rs_addr == E_RFA3)&&D_rs_addr;
//stall_rt_E也是一样的修改
wire stall_rs = stall_rs_E | stall_rs_M;
```

到此为止我们全部修改完毕，功能可以正常运行
最后，这几种功能可以各种搭配，但目前为止还只有搭配条件写的这种方式，希望可以通过对于考察方式的理解，帮助你更好的完成P5，P6的课上测试。

